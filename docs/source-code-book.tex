% ----------------------------------------
% Documentation for JSLAB
% ----------------------------------------
\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[serbianc, english]{babel}
\usepackage{tabularx}
\usepackage{geometry}
\usepackage{listings}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{caption}
\usepackage{hyperref}
\usepackage{float}
\usepackage{varwidth}
\usepackage[most]{tcolorbox}

% Define variables
\newcommand{\yearvar}{2025}
\newcommand{\appversion}{v1.0.3}

% Colors
\definecolor{jsl-blue}{cmyk}{1,1,0,0}
\definecolor{jsl-orage}{cmyk}{0,.5,1,0}
\definecolor{jsl-green}{cmyk}{1,0,1,0.5}
\definecolor{jsl-gray}{cmyk}{0,0,0,0.5}
\definecolor{jsl-light-gray}{cmyk}{0,0,0,0.1}
\definecolor{jsl-yellow}{RGB}{247,223,30}

% Code
\lstdefinelanguage{JavaScript}{
  morekeywords=[1]{break, continue, delete, else, for, catch, 
	switch, function, if, in, do, case, new, return, this, typeof, 
	var, void, while, with},
  % Literals, primitive types, and reference types.
  morekeywords=[2]{false, null, true, boolean, number, undefined,
    Array, Boolean, Date, Math, Number, String, Object},
  % Built-ins.
  morekeywords=[3]{eval, parseInt, parseFloat, escape, unescape},
  sensitive,
  morecomment=[s]{/*}{*/},
  morecomment=[l]//,
  morecomment=[s]{/**}{*/}, % JavaDoc style comments
  morestring=[b]',
  morestring=[b]"
}[keywords, comments, strings]

\lstdefinelanguage{CSS}{
  keywords={color,background-image:,margin,padding,font,weight,display,position,top,left,right,bottom,list,style,border,size,white,space,min,width, transition:, transform:, transition-property, transition-duration, transition-timing-function},	
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]',
  morestring=[b]",
  alsoletter={:},
  alsodigit={-}
}

\lstdefinestyle{JavaScriptStyle}{
    language=JavaScript,
    basicstyle=\fontfamily{pcr}\selectfont\footnotesize, 
    commentstyle=\color{jsl-green},
    keywordstyle=\bf\color{jsl-blue},
    stringstyle=\color{jsl-gray},
    breaklines=true,
    showstringspaces=false,
    captionpos=b,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    inputencoding=utf8,
    extendedchars=true,
    literate=
        {°}{{\textdegree}}1
        {º}{{\textordmasculine}}1 
        {©}{{\textcopyright}}1
        {¶}{{\P}}1
        {š}{{\v{s}}}1
        {Š}{{\v{S}}}1
        {č}{{\v{c}}}1
        {Č}{{\v{C}}}1
        {ž}{{\v{z}}}1
        {Ž}{{\v{Z}}}1
        {ć}{{\'{c}}}1
        {Ć}{{\'{C}}}1
        {đ}{{\dj}}1
        {Đ}{{\DJ}}1
        {θ}{{$\theta$}}1
        {µ}{{$\micro$}}1 
        {а}{{\selectfont\char224}}1
        {б}{{\selectfont\char225}}1
        {в}{{\selectfont\char226}}1
        {г}{{\selectfont\char227}}1
        {д}{{\selectfont\char228}}1
        {ђ}{{\selectfont\char162}}1
        {е}{{\selectfont\char229}}1
        {ж}{{\selectfont\char230}}1
        {з}{{\selectfont\char231}}1
        {и}{{\selectfont\char232}}1
        {ј}{{j}}1
        {к}{{\selectfont\char234}}1
        {л}{{\selectfont\char235}}1
        {љ}{{\selectfont\char167}}1
        {м}{{\selectfont\char236}}1
        {н}{{\selectfont\char237}}1
        {њ}{{\selectfont\char187}}1
        {о}{{\selectfont\char238}}1
        {п}{{\selectfont\char239}}1
        {р}{{\selectfont\char240}}1
        {с}{{\selectfont\char241}}1
        {т}{{\selectfont\char242}}1
        {ћ}{{\selectfont\char163}}1
        {у}{{\selectfont\char243}}1
        {ф}{{\selectfont\char244}}1
        {х}{{\selectfont\char245}}1
        {ц}{{\selectfont\char246}}1
        {ч}{{\selectfont\char247}}1
        {џ}{{\selectfont\char150}}1
        {ш}{{\selectfont\char248}}1
        {А}{{\selectfont\char192}}1
        {Б}{{\selectfont\char193}}1
        {В}{{\selectfont\char194}}1
        {Г}{{\selectfont\char195}}1
        {Д}{{\selectfont\char196}}1
        {Ђ}{{\selectfont\char130}}1
        {Е}{{\selectfont\char197}}1
        {Ж}{{\selectfont\char198}}1
        {З}{{\selectfont\char199}}1
        {И}{{\selectfont\char200}}1
        {Ј}{{J}}1
        {К}{{\selectfont\char202}}1
        {Л}{{\selectfont\char203}}1
        {Љ}{{\selectfont\char135}}1
        {М}{{\selectfont\char204}}1
        {Н}{{\selectfont\char205}}1
        {Њ}{{\selectfont\char155}}1
        {О}{{\selectfont\char206}}1
        {П}{{\selectfont\char207}}1
        {Р}{{\selectfont\char208}}1
        {С}{{\selectfont\char209}}1
        {Т}{{\selectfont\char210}}1
        {Ћ}{{\selectfont\char131}}1
        {У}{{\selectfont\char211}}1
        {Ф}{{\selectfont\char212}}1
        {Х}{{\selectfont\char213}}1
        {Ц}{{\selectfont\char214}}1
        {Ч}{{\selectfont\char215}}1
        {Џ}{{\selectfont\char150}}1
        {Ш}{{\selectfont\char216}}1
}

\lstdefinestyle{C++Style}{
    language=C++,
    basicstyle=\fontfamily{pcr}\selectfont\footnotesize,
    keywordstyle=\bf\color{jsl-blue},
    commentstyle=\color{jsl-green},
    stringstyle=\color{jsl-gray},
    breaklines=true,
    showstringspaces=false,
    captionpos=b,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt
}

\lstdefinestyle{HTMLStyle}{
    language=HTML,
    basicstyle=\fontfamily{pcr}\selectfont\footnotesize,
    keywordstyle=\bf\color{jsl-blue},
    commentstyle=\color{jsl-green},
    breaklines=true,
    showstringspaces=false,
    captionpos=b,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    inputencoding=utf8,
    extendedchars=true,
    literate=
        {°}{{\textdegree}}1
        {º}{{\textordmasculine}}1 
        {©}{{\textcopyright}}1
        {¶}{{\P}}1
        {š}{{\v{s}}}1
        {Š}{{\v{S}}}1
        {č}{{\v{c}}}1
        {Č}{{\v{C}}}1
        {ž}{{\v{z}}}1
        {Ž}{{\v{Z}}}1
        {ć}{{\'{c}}}1
        {Ć}{{\'{C}}}1
        {đ}{{\dj}}1
        {Đ}{{\DJ}}1
        {θ}{{$\theta$}}1
        {µ}{{$\micro$}}1 
        {а}{{\selectfont\char224}}1
        {б}{{\selectfont\char225}}1
        {в}{{\selectfont\char226}}1
        {г}{{\selectfont\char227}}1
        {д}{{\selectfont\char228}}1
        {ђ}{{\selectfont\char162}}1
        {е}{{\selectfont\char229}}1
        {ж}{{\selectfont\char230}}1
        {з}{{\selectfont\char231}}1
        {и}{{\selectfont\char232}}1
        {ј}{{j}}1
        {к}{{\selectfont\char234}}1
        {л}{{\selectfont\char235}}1
        {љ}{{\selectfont\char167}}1
        {м}{{\selectfont\char236}}1
        {н}{{\selectfont\char237}}1
        {њ}{{\selectfont\char187}}1
        {о}{{\selectfont\char238}}1
        {п}{{\selectfont\char239}}1
        {р}{{\selectfont\char240}}1
        {с}{{\selectfont\char241}}1
        {т}{{\selectfont\char242}}1
        {ћ}{{\selectfont\char163}}1
        {у}{{\selectfont\char243}}1
        {ф}{{\selectfont\char244}}1
        {х}{{\selectfont\char245}}1
        {ц}{{\selectfont\char246}}1
        {ч}{{\selectfont\char247}}1
        {џ}{{\selectfont\char150}}1
        {ш}{{\selectfont\char248}}1
        {А}{{\selectfont\char192}}1
        {Б}{{\selectfont\char193}}1
        {В}{{\selectfont\char194}}1
        {Г}{{\selectfont\char195}}1
        {Д}{{\selectfont\char196}}1
        {Ђ}{{\selectfont\char130}}1
        {Е}{{\selectfont\char197}}1
        {Ж}{{\selectfont\char198}}1
        {З}{{\selectfont\char199}}1
        {И}{{\selectfont\char200}}1
        {Ј}{{J}}1
        {К}{{\selectfont\char202}}1
        {Л}{{\selectfont\char203}}1
        {Љ}{{\selectfont\char135}}1
        {М}{{\selectfont\char204}}1
        {Н}{{\selectfont\char205}}1
        {Њ}{{\selectfont\char155}}1
        {О}{{\selectfont\char206}}1
        {П}{{\selectfont\char207}}1
        {Р}{{\selectfont\char208}}1
        {С}{{\selectfont\char209}}1
        {Т}{{\selectfont\char210}}1
        {Ћ}{{\selectfont\char131}}1
        {У}{{\selectfont\char211}}1
        {Ф}{{\selectfont\char212}}1
        {Х}{{\selectfont\char213}}1
        {Ц}{{\selectfont\char214}}1
        {Ч}{{\selectfont\char215}}1
        {Џ}{{\selectfont\char150}}1
        {Ш}{{\selectfont\char216}}1
}

\lstdefinestyle{CSSStyle}{
    language=CSS,
    basicstyle=\fontfamily{pcr}\selectfont\footnotesize,
    keywordstyle=\bf\color{jsl-blue},
    commentstyle=\color{jsl-green},
    breaklines=true,
    showstringspaces=false,
    captionpos=b,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    inputencoding=utf8,
}

\newtcbox{\code}[1][]{%
    on line,
    colback=jsl-light-gray,
    colframe=jsl-light-gray, 
    boxrule=0pt, 
    arc=3pt,
    left=2pt,
    right=2pt,
    top=2pt,
    bottom=2pt,
    box align=base,
    fontupper=\ttfamily,
    #1
}

\newtcbox{\codeBlock}[1][]{%
    colback=jsl-light-gray,
    colframe=jsl-light-gray, 
    boxrule=0pt, 
    arc=3pt,
    left=2pt,
    right=2pt,
    top=2pt,
    bottom=2pt,
    box align=base,
    breakable,
    enhanced jigsaw,
    varwidth upper,
    fontupper=\ttfamily,
    #1
}

% Formating
\delimitershortfall=-1pt
\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\hbadness=10000

% Paper
\geometry{
  paperheight=297mm,
  paperwidth=210mm,
  top=40mm,
  bottom=22mm,
  right=20mm,
  left=25mm,
  headheight=45mm,
  headsep = 10mm,
}

\newcommand{\companyLogo}[2][1]{%
\begin{tikzpicture}[y=1cm, x=1cm, yscale=#1, xscale=#1, every node/.append style={scale=#1}, inner sep=0pt, outer sep=0pt]
  \path[fill=#2,line cap=butt,line join=miter,line width=0.1cm,shift={(0,2.3814000000000006)},scale=0.2646] (48.3133, 7.2898).. controls (48.3133, 7.2898) and (45.5748, 7.2298) .. (42.8363, 7.2385).. controls (42.5511, 7.2394) and (42.2572, 7.2395) .. (41.9563, 7.2387).. controls (37.4414, 7.2255) and (31.3175, 7.1544) .. (28.0006, 6.1414).. controls (21.9344, 4.2889) and (18.5966, 1.6908) .. (15.8504, -1.3797).. controls (15.3536, -1.9429) and (14.706, -2.7974) .. (13.9723, -3.8922).. controls (14.3648, -4.7541) and (14.5615, -5.7655) .. (14.5615, -6.9275).. controls (14.5615, -8.2166) and (14.3276, -9.3004) .. (13.8598, -10.1789).. controls (13.3919, -11.0574) and (12.795, -11.7496) .. (12.0693, -12.2557).. controls (11.3532, -12.7522) and (10.6227, -13.0816) .. (9.8779, -13.2439).. controls (9.5808, -13.3028) and (9.2396, -13.352) .. (8.8643, -13.3936).. controls (7.5711, -16.3864) and (6.3915, -19.737) .. (5.5781, -23.2604) -- (44.9074, -23.2898).. controls (45.292, -19.8927) and (45.6146, -16.9976) .. (45.9133, -14.2994).. controls (45.4314, -13.1253) and (45.19, -11.7645) .. (45.19, -10.2162).. controls (45.19, -7.5942) and (45.8113, -5.5113) .. (47.0529, -3.9666).. controls (47.4282, -0.5661) and (47.8187, 2.9505) .. (48.3133, 7.2898) -- cycle(53.9496, -2.5064).. controls (51.9444, -2.5064) and (50.3266, -3.1673) .. (49.0961, -4.4889).. controls (47.8656, -5.804) and (47.2504, -7.6529) .. (47.2504, -10.0357).. controls (47.2504, -12.2883) and (47.8624, -14.0657) .. (49.0863, -15.3678).. controls (50.3103, -16.6633) and (51.8728, -17.3111) .. (53.7738, -17.3111).. controls (55.3103, -17.3111) and (56.5766, -16.9335) .. (57.5727, -16.1783).. controls (58.5753, -15.4166) and (59.2914, -14.2545) .. (59.7211, -12.692) -- (56.9184, -11.8033).. controls (56.6775, -12.8515) and (56.2803, -13.6197) .. (55.727, -14.108).. controls (55.1736, -14.5963) and (54.5128, -14.8404) .. (53.7445, -14.8404).. controls (52.7029, -14.8404) and (51.8565, -14.4563) .. (51.2055, -13.6881).. controls (50.5544, -12.9199) and (50.2289, -11.6308) .. (50.2289, -9.8209).. controls (50.2289, -8.1152) and (50.5577, -6.8814) .. (51.2152, -6.1197).. controls (51.8793, -5.358) and (52.7419, -4.9771) .. (53.8031, -4.9771).. controls (54.5714, -4.9771) and (55.2224, -5.192) .. (55.7563, -5.6217).. controls (56.2966, -6.0514) and (56.6514, -6.6373) .. (56.8207, -7.3795) -- (59.682, -6.6959).. controls (59.3565, -5.5501) and (58.8682, -4.6712) .. (58.2172, -4.0592).. controls (57.1234, -3.024) and (55.7009, -2.5064) .. (53.9496, -2.5064) -- cycle(1.4217, -2.7506) -- (1.4217, -17.067) -- (4.3123, -17.067) -- (4.3123, -11.6666) -- (6.1971, -11.6666).. controls (7.5057, -11.6666) and (8.505, -11.5982) .. (9.1951, -11.4615).. controls (9.7029, -11.3508) and (10.201, -11.1262) .. (10.6893, -10.7877).. controls (11.1841, -10.4426) and (11.591, -9.9706) .. (11.91, -9.3717).. controls (12.229, -8.7727) and (12.3885, -8.0338) .. (12.3885, -7.1549).. controls (12.3885, -6.0156) and (12.1118, -5.0878) .. (11.5584, -4.3717).. controls (11.005, -3.649) and (10.3182, -3.1803) .. (9.4979, -2.9654).. controls (8.964, -2.8222) and (7.8182, -2.7506) .. (6.0604, -2.7506) -- (1.4217, -2.7506) -- cycle(15.7908, -2.7506) -- (21.8748, -2.7506).. controls (23.4048, -2.7506) and (24.5148, -2.8808) .. (25.2049, -3.1412).. controls (25.9015, -3.3951) and (26.4581, -3.8508) .. (26.8748, -4.5084).. controls (27.2915, -5.1659) and (27.4998, -5.9179) .. (27.4998, -6.7643).. controls (27.4998, -7.8385) and (27.184, -8.7271) .. (26.5525, -9.4303).. controls (25.921, -10.1269) and (24.977, -10.5663) .. (23.7205, -10.7486).. controls (24.3455, -11.1132) and (24.8598, -11.5136) .. (25.2635, -11.9498).. controls (25.6736, -12.386) and (26.2238, -13.1607) .. (26.9139, -14.274) -- (28.6619, -17.067) -- (25.2049, -17.067) -- (23.115, -13.9518).. controls (22.3728, -12.8385) and (21.865, -12.1386) .. (21.5916, -11.8521).. controls (21.3182, -11.5592) and (21.0285, -11.3606) .. (20.7225, -11.2564).. controls (20.4165, -11.1458) and (19.9314, -11.0904) .. (19.2674, -11.0904) -- (18.6814, -11.0904) -- (18.6814, -17.067) -- (15.7908, -17.067) -- (15.7908, -2.7506) -- cycle(32.2953, -2.7506) -- (37.5785, -2.7506).. controls (38.7699, -2.7506) and (39.6781, -2.8417) .. (40.3031, -3.024).. controls (41.143, -3.2714) and (41.8624, -3.7109) .. (42.4613, -4.3424).. controls (43.0603, -4.9739) and (43.516, -5.7486) .. (43.8285, -6.6666).. controls (44.141, -7.5781) and (44.2973, -8.7044) .. (44.2973, -10.0455).. controls (44.2973, -11.2239) and (44.1508, -12.2395) .. (43.8578, -13.0924).. controls (43.4997, -14.134) and (42.9887, -14.9772) .. (42.3246, -15.6217).. controls (41.8233, -16.11) and (41.1462, -16.4908) .. (40.2934, -16.7643).. controls (39.6553, -16.9661) and (38.8025, -17.067) .. (37.7348, -17.067) -- (32.2953, -17.067) -- (32.2953, -2.7506) -- cycle(4.3123, -5.1725) -- (5.7088, -5.1725).. controls (6.7505, -5.1725) and (7.4438, -5.205) .. (7.7889, -5.2701).. controls (8.2576, -5.3548) and (8.645, -5.5663) .. (8.951, -5.9049).. controls (9.257, -6.2434) and (9.41, -6.6731) .. (9.41, -7.1939).. controls (9.41, -7.6171) and (9.2993, -7.9882) .. (9.0779, -8.3072).. controls (8.8631, -8.6262) and (8.5636, -8.8606) .. (8.1795, -9.0104).. controls (7.7954, -9.1601) and (7.0337, -9.235) .. (5.8943, -9.235) -- (4.3123, -9.235) -- (4.3123, -5.1725) -- cycle(18.6814, -5.1725) -- (18.6814, -8.8053) -- (20.8201, -8.8053).. controls (22.2068, -8.8053) and (23.0727, -8.7467) .. (23.4178, -8.6295).. controls (23.7628, -8.5123) and (24.033, -8.3105) .. (24.2283, -8.024).. controls (24.4236, -7.7376) and (24.5213, -7.3795) .. (24.5213, -6.9498).. controls (24.5213, -6.468) and (24.3911, -6.0807) .. (24.1307, -5.7877).. controls (23.8768, -5.4882) and (23.5154, -5.2994) .. (23.0467, -5.2213).. controls (22.8123, -5.1887) and (22.1092, -5.1725) .. (20.9373, -5.1725) -- (18.6814, -5.1725) -- cycle(35.1859, -5.1725) -- (35.1859, -14.6549) -- (37.3441, -14.6549).. controls (38.1514, -14.6549) and (38.7341, -14.6093) .. (39.0922, -14.5182).. controls (39.5609, -14.401) and (39.9483, -14.2024) .. (40.2543, -13.9225).. controls (40.5668, -13.6425) and (40.8207, -13.1835) .. (41.016, -12.5455).. controls (41.2113, -11.901) and (41.309, -11.0253) .. (41.309, -9.9186).. controls (41.309, -8.8118) and (41.2113, -7.9622) .. (41.016, -7.3697).. controls (40.8207, -6.7773) and (40.5473, -6.315) .. (40.1957, -5.983).. controls (39.8441, -5.651) and (39.3982, -5.4264) .. (38.8578, -5.3092).. controls (38.4542, -5.218) and (37.6632, -5.1725) .. (36.4848, -5.1725) -- (35.1859, -5.1725) -- cycle(27.5357, -9.7939) -- (31.1723, -9.7939) -- (31.1723, -11.6123) -- (27.5357, -11.6123) -- (27.5357, -9.7939) -- cycle;
\end{tikzpicture}
}

\newcommand{\jslabLogo}[2][1]{%
\begin{tikzpicture}[y=1cm, x=1cm, yscale=#1, xscale=#1, every node/.append style={scale=#1}, inner sep=0pt, outer sep=0pt]
  \path[fill=jsl-yellow,rounded corners=#2] (0.0, 0.0) rectangle (16.6688, -16.6688);
  \path[fill=black,line width=0.2278cm] (3.5007, -15.6898).. controls (4.6304, -15.6898) and (5.4048, -15.0885) .. (5.4048, -13.7675) -- (5.4048, -9.4127) -- (4.1293, -9.4127) -- (4.1293, -13.7493).. controls (4.1293, -14.387) and (3.8651, -14.551) .. (3.446, -14.551).. controls (3.0087, -14.551) and (2.8265, -14.2503) .. (2.6261, -13.895) -- (1.5875, -14.5237).. controls (1.8881, -15.1614) and (2.4803, -15.6898) .. (3.5007, -15.6898) -- cycle;
  \path[fill=black,line width=0.2278cm] (8.4203, -15.6898).. controls (9.632, -15.6898) and (10.534, -15.0612) .. (10.534, -13.9132).. controls (10.534, -12.8473) and (9.9236, -12.3736) .. (8.8394, -11.9089) -- (8.5206, -11.7723).. controls (7.9739, -11.5354) and (7.7371, -11.3805) .. (7.7371, -10.9979).. controls (7.7371, -10.6881) and (7.9739, -10.4513) .. (8.3475, -10.4513).. controls (8.7119, -10.4513) and (8.9487, -10.6061) .. (9.1674, -10.9979) -- (10.1604, -10.3602).. controls (9.7414, -9.6222) and (9.1583, -9.3398) .. (8.3475, -9.3398).. controls (7.2086, -9.3398) and (6.4798, -10.0686) .. (6.4798, -11.0252).. controls (6.4798, -12.0638) and (7.0902, -12.5558) .. (8.0104, -12.9475) -- (8.3292, -13.0842).. controls (8.9123, -13.3393) and (9.2585, -13.4942) .. (9.2585, -13.9315).. controls (9.2585, -14.2959) and (8.9214, -14.5601) .. (8.393, -14.5601).. controls (7.7644, -14.5601) and (7.4091, -14.2321) .. (7.1358, -13.7857) -- (6.0972, -14.387).. controls (6.4707, -15.1249) and (7.236, -15.6898) .. (8.4203, -15.6898) -- cycle;
  \path[fill=black,line width=0.2278cm] (11.527, -15.6078) -- (15.6085, -15.6078) -- (15.6085, -14.4872) -- (12.8025, -14.4872) -- (12.8025, -9.4127) -- (11.527, -9.4127) -- cycle;
\end{tikzpicture}
}

% Tabele
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\fancypagestyle{tekst}{
    \fancyhf{}
    \fancyhead[C]{
        \begin{minipage}{16.5cm}
            \begin{minipage}{2cm}
                \jslabLogo[0.1]{0.1cm}
                \vspace{1mm}
            \end{minipage}
            \begin{minipage}{2.6cm}
                \vspace{1mm}
                
                \companyLogo[0.15]{black}
            \end{minipage}
           \begin{minipage}{5cm}
                \footnotesize
                web: \href{https://pr-dc.com}{pr-dc.com} \\
                email: \href{mailto:info@pr-dc.com}{info@pr-dc.com}\\
                github: \href{https://github.com/PR-DC}{github.com/PR-DC}
            \end{minipage}  
           \begin{minipage}{6.5cm}
                \raggedleft {\large\textbf{JSLAB \appversion}} \\
                \raggedleft SOURCE CODE
            \end{minipage}
            \vspace{-5mm}
        \end{minipage}
    }

    \fancyfoot[C]{\vspace{2mm} \bfseries {\thepage} / \pageref{LastPage}}
    \renewcommand{\headrulewidth}{0.4pt}
    \renewcommand{\headrule}{{\color{jsl-yellow}\hrule}}
    \renewcommand{\footrulewidth}{0.4pt}
    \renewcommand{\footrule}{{\color{jsl-yellow}\hrule}}

}

\makeatletter
\newcommand*{\ov}[1]{%
  $\m@th\overline{\mbox{#1}\raisebox{5mm}{}}$%
}

\renewcommand{\arraystretch}{1.2}
\renewcommand{\aboverulesep}{0}
\renewcommand{\belowrulesep}{0}

% Podesavanja naslova slika
\DeclareCaptionLabelSeparator{bar}{ - }
\captionsetup{labelsep=bar}

% ----------------------------------------
% POCETAK DOKUMENTA
% ----------------------------------------
\begin{document}

% ----------------------------------------
% NASLOVNA STRANA
% ----------------------------------------
\begin{titlepage}

    \centering
    
    \vphantom{vspace}
    
    \vspace{5mm}
    
    \companyLogo[0.5]{black}
	
    \vspace{5mm}
    
    \centerline{\footnotesize{web: \href{https://pr-dc.com}{pr-dc.com}, email: \href{mailto:info@pr-dc.com}{info@pr-dc.com}, github: \href{https://github.com/PR-DC}{github.com/PR-DC}}}
    
    \vspace{5mm}

    \hrule
	
    \vspace{10mm}

    \jslabLogo[0.2]{0.1cm}

    \vspace{8mm}
    
    {\Huge\textbf{JSLAB \appversion} \par}
   
    \vspace{2mm}

    {\LARGE SOURCE CODE \par}

    \vspace{8mm}
    
   \href{https://github.com/PR-DC/JSLAB}{github.com/PR-DC/JSLAB}
    
    \vspace{8mm}
    
    \hrule
    
    \vfill
    
    \textbf{PRDC d.o.o.}, Novo naselje bb, 22310 Šimanovci, Republic of Serbia

\end{titlepage}

% ----------------------------------------
% Contents
% ----------------------------------------
\pagestyle{tekst}
\tableofcontents
\newpage

% ----------------------------------------
% Start of document
% ----------------------------------------


% ----------------------------------------
\section{root}


\begin{lstlisting}[style=JavaScriptStyle, caption={package.json}]
{
  "name": "JSLAB",
  "version": "1.0.3",
  "description": "JavaScript LABoratory environment",
  "main": "js/init.js",
  "repository": "https://github.com/PR-DC/JSLAB",
  "license": "GPL-3.0-or-later",
  "author": "Milos Petrasinovic <mpetrasinovic@prdc.rs>",
  "homepage": "https://pr-dc.com",
  "scripts": {
    "preinstall": "npm install rimraf & npm install node-7z & npm install 7zip-bin & node js/dev/prepare-libs.js & npm install -g node-gyp",
    "postinstall": "node js/dev/build-configure.js & node-gyp rebuild & node js/dev/make-doc.js & electron js/init.js",
    "start": "electron js/init.js",
    "debug": "electron js/init.js --debug-app",
    "test": "electron js/init.js --test-app",
    "build": "node js/dev/build-configure.js & node-gyp rebuild & electron js/init.js",
    "pack": "node js/dev/build-configure.js --action pack & node-gyp rebuild & electron-builder --dir",
    "dist": "node js/dev/build-configure.js --action dist & node-gyp rebuild & electron-builder --win",
    "dist-portable": "node js/dev/build-configure.js --action dist-portable & node-gyp rebuild & electron-builder --win portable",
    "dist-signed": "node js/dev/build-configure.js --action dist --sign-build & node-gyp rebuild & electron-builder --win",
    "clear-app-data": "node js/dev/clear-app-data.js --confirm",
    "make-doc": "node js/dev/make-doc.js",
    "make-source-code-book": "node js/dev/make-source-code-book.js",
    "update-libs": "node js/dev/download-libs.js --force --confirm",
    "upload-source": "node js/dev/upload-source-code.js"
  },
  "build": {
    "asar": false,
    "appId": "com.pr-dc.jslab",
    "productName": "PR-DC JSLAB",
    "copyright": "Copyright 2024 @ PR-DC",
    "nodeGypRebuild": true,
    "directories": {
      "buildResources": "build",
      "output": "dist"
    },
    "files": [
      "**",
      "!cpp",
      "!dev",
      "!dist",
      "!build",
      "!bin",
      "!binding.gyp",
      "!js/dev",
      "!lib/boost-1.86.0",
      "!lib/cgal-6.0.1",
      "!lib/eigen-3.4.0"
    ],
    "fileAssociations": [
      {
        "ext": "jsl",
        "name": "JSL",
        "description": "JavaScript LABoratory script",
        "role": "Editor",
        "icon": "icons/icon.ico"
      }
    ],
    "extraResources": [
      {
        "from": "./build/Release/",
        "to": "./app/build/Release/",
        "filter": [
          "*.node",
          "*.dll"
        ]
      },
      {
        "from": "./node_modules/npm/",
        "to": "./app/node_modules/npm/"
      },
      {
        "from": "./node_modules/node-gyp/",
        "to": "./app/node_modules/node-gyp/"
      }
    ],
    "compression": "maximum",
    "mac": {
      "category": "public.app-category.utilities",
      "icon": "icons/icon.icns",
      "target": "dmg"
    },
    "win": {
      "icon": "icons/icon.ico",
      "target": "nsis",
      "signingHashAlgorithms": [
        "sha256"
      ],
      "publisherName": "PR-DC"
    },
    "linux": {
      "icon": "icons/",
      "target": "AppImage"
    },
    "portable": {
      "splashImage": "icons/splash.bmp"
    },
    "nsis": {
      "oneClick": false,
      "perMachine": true,
      "allowToChangeInstallationDirectory": true,
      "installerIcon": "icons/nsis_in_icon.ico",
      "uninstallerIcon": "icons/nsis_un_icon.ico",
      "installerHeader": "img/nsis_in_header.bmp",
      "installerHeaderIcon": "icons/icon.ico",
      "installerSidebar": "img/nsis_in_welcom.bmp",
      "uninstallerSidebar": "img/nsis_un_welcom.bmp",
      "uninstallDisplayName": "JSLAB ${version}",
      "shortcutName": "JSLAB",
      "language": "1033",
      "displayLanguageSelector": true,
      "installerLanguages": [
        "en_US",
        "sr_RS"
      ],
      "multiLanguageInstaller": true,
      "warningsAsErrors": false
    },
    "artifactName": "JSLAB_1.0.3.${ext}"
  },
  "devDependencies": {
    "electron": "36.4.0",
    "electron-builder": "26.0.12"
  },
  "dependencies": {
    "@babel/parser": "7.27.5",
    "@babel/plugin-syntax-top-level-await": "7.14.5",
    "7zip-bin": "^5.2.0",
    "big-json-viewer": "0.1.7",
    "bytenode": "1.5.7",
    "dir-compare": "5.0.0",
    "electron-context-menu": "3.6.1",
    "electron-store": "8.2.0",
    "eslint": "9.29.0",
    "fast-xml-parser": "5.2.5",
    "fmin": "0.0.4",
    "glob": "11.0.3",
    "jsdoc-api": "9.3.4",
    "ml-regression-polynomial": "3.0.2",
    "node-7z": "^3.0.0",
    "node-addon-api": "8.4.0",
    "node-gyp": "11.2.0",
    "node-mavlink": "2.1.0",
    "npm": "11.4.2",
    "path-equal": "1.2.5",
    "pdfkit": "0.17.1",
    "recast": "0.23.11",
    "rimraf": "^5.0.10",
    "seedrandom": "3.0.5",
    "serialport": "13.0.0",
    "source-map": "0.7.4",
    "svg-to-pdfkit": "0.1.8",
    "tcp-port-used": "1.0.2",
    "usb": "2.15.0",
    "zeromq": "6.0.0-beta.20"
  }
}
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={binding.gyp}]
{
  "targets": [
    {
      "target_name": "native_module",
      "sources": [
        "cpp/native-module.cpp"
      ],
      "include_dirs": [
        "<!@(node -p \"require('node-addon-api').include\")",
        "<(module_root_dir)/lib/eigen-3.4.0/"
      ],
      "cflags!": [
        "-fno-exceptions"
      ],
      "cflags_cc!": [
        "-fno-exceptions"
      ],
      "defines": [
        "NAPI_DISABLE_CPP_EXCEPTIONS"
      ],
      "msvs_settings": {
        "VCCLCompilerTool": {
          "AdditionalOptions": [
            "-std:c++17"
          ]
        }
      }
    },
    {
      "target_name": "alpha_shape_3d",
      "sources": [
        "cpp/alpha-shape-3d.cpp"
      ],
      "include_dirs": [
        "<!@(node -p \"require('node-addon-api').include\")",
        "<(module_root_dir)/lib/cgal-6.0.1/include/",
        "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/include",
        "<(module_root_dir)/lib/boost-1.86.0/"
      ],
      "libraries": [
        "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/lib/gmp.lib",
        "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/lib/mpfr.lib"
      ],
      "cflags!": [
        "-fno-exceptions"
      ],
      "cflags_cc!": [
        "-fno-exceptions",
        "-O3",
        "-DNDEBUG"
      ],
      "defines": [
        "NAPI_DISABLE_CPP_EXCEPTIONS"
      ],
      "copies": [
        {
          "destination": "<(module_root_dir)/build/Release",
          "files": [
            "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/bin/gmp-10.dll",
            "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/bin/mpfr-6.dll"
          ]
        }
      ],
      "msvs_settings": {
        "VCCLCompilerTool": {
          "AdditionalOptions": [
            "-std:c++17",
            "/GR",
            "/EHsc"
          ]
        }
      }
    }
  ]
}
\end{lstlisting}

% ----------------------------------------
\section{config}


\begin{lstlisting}[style=JavaScriptStyle, caption={config.js}]
/**
 * @file JSLAB global configuration
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for application configuration.
 */
class PRDC_APP_CONFIG {

  /**
   * Create JSLAB configuration object.
   */
  constructor() {
    this.PRODUCTION = false;
    this.DEBUG = false;
    this.TEST = false;
    this.SIGN_BUILD = false;
    
    this.GROUP_RAF = true;
    this.OUTPUT_COMPLETE_JSDOC = false;
    
    this.DEBUG_FUN_SHADOW = false;
    this.DEBUG_NEW_FUN = false;
    this.DEBUG_RENDER_GONE_ERROR = true;
    this.DEBUG_SYM_PYTHON_EVAL_CODE = false;
    this.DEBUG_PRE_TRANSFORMED_CODE = false;
    this.DEBUG_TRANSFORMED_CODE = false;
    this.DEBUG_PARALLEL_WORKER_SETUP_FUN = false;
    this.DEBUG_PARALLEL_WORKER_WORK_FUN = false;
    
    this.LOG_RENDER_GONE_ERROR = true;
    
    // Log codes
    this.LOG_CODES = {
      'other': 0,
      'render-gone-error': 1,
    };
    
    // JSLAB settings
    this.FORBIDDEN_NAMES = ['jsl', 'config', 'language', 'app_path', 'packed'];
    this.MATHJS_PREVENT_OVERRIDE = ['config', 'print', 'Infinity', 'NaN', 'isNaN', 'Node'];
    this.SUBMODULES = {
      'builtin': [
        {name: 'basic', file: 'basic', class_name: 'PRDC_JSLAB_LIB_BASIC'},
        {name: 'math', file: 'math', class_name: 'PRDC_JSLAB_LIB_MATH'},
        {name: 'non_blocking', file: 'non-blocking', class_name: 'PRDC_JSLAB_LIB_NON_BLOCKING'},
        {name: 'path', file: 'path', class_name: 'PRDC_JSLAB_LIB_PATH'},
        {name: 'windows', file: 'windows', class_name: 'PRDC_JSLAB_LIB_WINDOWS'},
        {name: 'figures', file: 'figures', class_name: 'PRDC_JSLAB_LIB_FIGURES'},
        {name: 'time', file: 'time', class_name: 'PRDC_JSLAB_LIB_TIME'},
        {name: 'array', file: 'array', class_name: 'PRDC_JSLAB_LIB_ARRAY'},
        {name: 'color', file: 'color', class_name: 'PRDC_JSLAB_LIB_COLOR'},
        {name: 'conversion', file: 'conversion', class_name: 'PRDC_JSLAB_LIB_CONVERSION'},
        {name: 'device', file: 'device', class_name: 'PRDC_JSLAB_LIB_DEVICE'},
        {name: 'serial_device', file: 'serial-device', class_name: 'PRDC_JSLAB_LIB_SERIAL_DEVICE'},
        {name: 'file_system', file: 'file-system', class_name: 'PRDC_JSLAB_LIB_FILE_SYSTEM'},
        {name: 'system', file: 'system', class_name: 'PRDC_JSLAB_LIB_SYSTEM'},
        {name: 'geography', file: 'geography', class_name: 'PRDC_JSLAB_LIB_GEOGRAPHY'},
        {name: 'networking', file: 'networking', class_name: 'PRDC_JSLAB_LIB_NETWORKING'},
        {name: 'format', file: 'format', class_name: 'PRDC_JSLAB_LIB_FORMAT'},
        {name: 'render', file: 'render', class_name: 'PRDC_JSLAB_LIB_RENDER'},
        {name: 'geometry', file: 'geometry', class_name: 'PRDC_JSLAB_LIB_GEOMETRY'},
        {name: 'control', file: 'control', class_name: 'PRDC_JSLAB_LIB_CONTROL'},
        {name: 'optim', file: 'optim', class_name: 'PRDC_JSLAB_LIB_OPTIM'},
        {name: 'presentation', file: 'presentation', class_name: 'PRDC_JSLAB_LIB_PRESENTATION'},
        {name: 'mechanics', file: 'mechanics', class_name: 'PRDC_JSLAB_LIB_MECHANICS'},
        {name: 'gui', file: 'gui', class_name: 'PRDC_JSLAB_LIB_GUI'},
      ],
      'lib': [
        {name: 'parallel', file: 'parallel', class_name: 'PRDC_JSLAB_PARALLEL'},
        {name: 'mat', file: 'matrix-math', class_name: 'PRDC_JSLAB_MATRIX_MATH'},
        {name: 'vec', file: 'vector-math', class_name: 'PRDC_JSLAB_VECTOR_MATH'},
        {name: 'sym', file: 'sym-math', class_name: 'PRDC_JSLAB_SYMBOLIC_MATH'},
      ]
    };
    
    this.DOC_SUBMODULES_ADDITIONAL = [
      {name: 'Matrix', file: 'matrix-math', class_name: 'PRDC_JSLAB_MATRIX'},
      {name: 'Vector', file: 'vector-math', class_name: 'PRDC_JSLAB_VECTOR'},
      {name: 'Symbolic', file: 'sym-math', class_name: 'PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL'},
      {name: 'Window', file: 'windows', class_name: 'PRDC_JSLAB_WINDOW'},
      {name: 'Figure', file: 'figures', class_name: 'PRDC_JSLAB_FIGURE'},
      {name: 'Plot', file: 'figures', class_name: 'PRDC_JSLAB_PLOT'},
      {name: 'freecad_link', file: 'freecad-link', class_name: 'PRDC_JSLAB_FREECAD_LINK'},
      {name: 'om_link', file: 'om-link', class_name: 'PRDC_JSLAB_OPENMODELICA_LINK'},
      {name: 'tcp_client', file: 'networking-tcp', class_name: 'PRDC_JSLAB_TCP_CLIENT'},
      {name: 'tcp_server', file: 'networking-tcp', class_name: 'PRDC_JSLAB_TCP_SERVER'},
      {name: 'udp_client', file: 'networking-udp', class_name: 'PRDC_JSLAB_UDP'},
      {name: 'udp_server', file: 'networking-udp', class_name: 'PRDC_JSLAB_UDP_SERVER'},
      {name: 'video_call', file: 'networking-videocall', class_name: 'PRDC_JSLAB_VIDEOCALL'},
      {name: 'mathjs', file: 'mathjs-doc', class_name: 'PRDC_JSLAB_MATHJS_DOC'},
      {name: 'rcmiga', file: 'optim-rcmiga', class_name: 'PRDC_JSLAB_OPTIM_RCMIGA'},
      {name: 'space_search', file: 'geometry-spacesearch', class_name: 'PRDC_JSLAB_GEOMETRY_SPACE_SERACH'},
      {name: 'map', file: 'geography-map', class_name: 'PRDC_JSLAB_GEOGRAPHY_MAP'},
      {name: 'map_3d', file: 'geography-map-3d', class_name: 'PRDC_JSLAB_GEOGRAPHY_MAP_3D'},
      {name: 'Gamepad', file: 'device-gamepad', class_name: 'PRDC_JSLAB_DEVICE_GAMEPAD'},
    ];

    this.SOURCE_CODE_BOOK_FILES = [
      'package.json',
      'binding.gyp',
      'config',
      'cpp',
      'css',
      'html',
      'js'
    ];
    
    this.SOURCE_CODE_BOOK_FILES_EXCLUDE = [
      'html/io_html_figure.html'
    ];
    
    this.LINT_OPTIONS = {
      overrideConfigFile: true,
      overrideConfig: {
        languageOptions: {
          ecmaVersion: "latest",
          sourceType: "module"
        },
        rules: {
          "no-unused-vars": "warn",
          "semi": ["warn", "always"],
          "no-extra-semi": "warn",
          "no-unreachable": "warn",
          "consistent-return": "warn",
          "no-shadow": "warn",
          "no-use-before-define": "warn"
        }
      }
    };

    this.COMPRESSED_LIBS = [
      'leaflet-1.9.4',
      'sympy-0.26.2',
      'cgal-6.0.1', 
      'boost-1.86.0', 
      'codemirror-5.49.2', 
      'eigen-3.4.0',
      'three.js-r162',
      'Cesium-1.124',
    ];
    this.COMPILE_LIBS = [];
    
    // Language 
    this.langs = ["en", "rs", "rsc"];
    
    // Windows
    this.WIN_SAVE_DEBOUNCE_TIME = 50; // [ms]
    
    // Other
    this.PLOTER = ['plotly', 'echarts'][0];
    this.DOC_LATEX_RERUNS_NUMBER = 3;
    this.SOURCE_CODE_BOOK_LATEX_RERUNS_NUMBER = 3;
    this.MAX_ACTIVE_WEBGL_CONTEXTS = '128';
    this.MAX_JSON_STRING_LENGTH = 1000;
    
    // Build sign
    this.COMPANY_NAME = process.env.COMPANY_NAME;
    this.TIMESTAMP_SERVER = process.env.TIMESTAMP_SERVER;
    this.SIGN_TOOL_PATH = process.env.SIGN_TOOL_PATH;
    
    // Upload and download libs from server
    this.SERVER_SOURCE_PATH = process.env.SERVER_PATH + "JSLAB/";
    this.SOURCE_UPLOAD_EXCLUDE = ['/bin', '/build', '/dist', '/node_modules', '/package-lock.json', '/binding.gyp', '/lib', '*.obj'];
    this.SERVER_LIBS_PATH = process.env.SERVER_LIBS_PATH;

    this.USED_LIBS = [
      'sprintf-1.1.3',
      'sympy-0.26.2',
      'cgal-6.0.1', 
      'boost-1.86.0', 
      'codemirror-5.49.2', 
      'complete.ly.1.0.1', 
      'd3-7.8.5', 
      'draggabilly-2.3.0',
      'eigen-3.4.0',
      'highlight-11.0.1',
      'jquery-3.7.0',
      'jshint-2.13.0',
      'math-11.8.2', 
      'tex-mml-chtml-3.2.0',
      'luxon-3.4.4',
      'plotly-2.24.2',
      'three.js-r162',
      'inflate-0.3.1',
      'hammer-2.0.8',
      'anime-3.2.1',
      'tween.js-23.1.1',
      'leaflet-1.9.4',
      'leaflet.rotatedMarker-0.2.0',
      'Cesium-1.124',
      'mermaid-11.4.1',
      'jstree-3.3.17',
      'PRDC_APP_LOGGER',  
      'PRDC_PANEL', 
      'PRDC_TABS', 
      'PRDC_POPUP',
      'PRDC_SVG_VIEWER'
    ];
    
    this.UPLOAD_COMPARE_SIZE = false;
    this.UPLOAD_COMPARE_CONTENT = true;
    this.UPLOAD_COMPARE_DATE = false;
    this.UPLOAD_COMPARE_SIZE_ON_DISTINCT = false;
    
    this.PANEL_RESIZER_WIDTH = 10;
    this.PANEL_MIN_SIZE = 10;
    this.PANEL_DEFAULT_COLUMNS = [20, 80];
    this.PANEL_DEFAULT_LEFT_ROWS = [100/3, 100/3, 100/3];
    this.PANEL_DEFAULT_WORKSPACE_COLUMNS = [50, 25, 25];
  }
}

exports.PRDC_APP_CONFIG = PRDC_APP_CONFIG;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={lang.json}]
{
	"1": {
		"en": "Editor",
		"rs": "Uređivač",
		"rsc": "Уређивач"
	},
  "2": {
		"en": "Help",
		"rs": "Pomoć",
		"rsc": "Помоћ"
	},
  "3": {
		"en": "Info",
		"rs": "Info",
		"rsc": "Инфо"
	},
  "4": {
		"en": "File Browser",
		"rs": "Pretraživač fajlova",
		"rsc": "Претраживач фајлова"
	},
  "5": {
		"en": "Workspace",
		"rs": "Radni prostor",
		"rsc": "Радни простор"
	},
  "6": {
		"en": "Command History",
		"rs": "Istorija Komandi",
		"rsc": "Историја Команди"
	},
  "7": {
		"en": "Command Window",
		"rs": "Komandni Prozor",
		"rsc": "Командни Прозор"
	},
  "8": {
		"en": "version",
		"rs": "verzija",
		"rsc": "верзија"
  },
  "9": {
		"en": "Settings",
		"rs": "Podešavanja",
		"rsc": "Подешавања"
  },
  "10": {
		"en": "New",
		"rs": "Nova",
		"rsc": "Нова"
  },
  "11": {
		"en": "Open",
		"rs": "Otvori",
		"rsc": "Отвори"
  },
  "12": {
		"en": "Save",
		"rs": "Sačuvaj",
		"rsc": "Сачувај"
  },
  "13": {
		"en": "Save As",
		"rs": "Sačuvaj Kao",
		"rsc": "Сачувај Као"
  },
  "14": {
		"en": "Run",
		"rs": "Pokreni",
		"rsc": "Покрени"
  },
  "15": {
		"en": "Sandbox paused",
		"rs": "Radni prostor pauziran",
		"rsc": "Радни простор паузиран"
  },
  "16": {
		"en": "Language",
		"rs": "Jezik",
		"rsc": "Језик"
  },
  "17": {
    "en": "Number of latest messages",
    "rs": "Broj najnovijih poruka",
    "rsc": "Број најновијих порука"
  },
  "18": {
    "en": "Close log save dialog",
    "rs": "Zatvorite dijalog za čuvanje dnevnika",
    "rsc": "Затворите дијалог за чување дневника"
  },
  "19": {
    "en": "Close command history",
    "rs": "Zatvori istoriju komandi",
    "rsc": "Затвори историју команди"
  },
  "20": {
    "en": "Close script directory dialog",
    "rs": "Zatvorite dijalog direktorijuma skripte",
    "rsc": "Затворите дијалог директоријума скрипте"
  },
  "21": {
    "en": "Close paths menu",
    "rs": "Zatvorite meni putanja",
    "rsc": "Затвори мени путања"
  },
  "22": {
    "en": "Close help",
    "rs": "Zatvori pomoć",
    "rsc": "Затвори помоћ"
  },
  "23": {
    "en": "Close info",
    "rs": "Zatvori informacije",
    "rsc": "Затворите информације"
  },
  "24": {
    "en": "Close settings",
    "rs": "Zatvorite podešavanja",
    "rsc": "Затворите подешавања"
  },
  "25": {
    "en": "Select language",
    "rs": "Izaberite jezik",
    "rsc": "Изаберите језик"
  },
  "26": {
    "en": "Open new script",
    "rs": "Otvorite novu skriptu",
    "rsc": "Отворите нову скрипту"
  },
  "27": {
    "en": "Open file",
    "rs": "Otvorite datoteku",
    "rsc": "Отворите датотеку"
  },
  "28": {
    "en": "Save file",
    "rs": "Sačuvaj datoteku",
    "rsc": "Сачувај датотеку"
  },
  "29": {
    "en": "File save as",
    "rs": "Datoteku sačuvaj kao",
    "rsc": "Датотеку сачувај као"
  },
  "30": {
    "en": "Save script and run",
    "rs": "Sačuvajte skriptu i pokreni",
    "rsc": "Сачувајте скрипту и покрени"
  },
  "31": {
    "en": "Click to go back",
    "rs": "Kliknite da biste se vratili",
    "rsc": "Кликните да бисте се вratili"
  },
  "32": {
    "en": "Click to go forward",
    "rs": "Kliknite da idete napred",
    "rsc": "Кликните да идете napred"
  },
  "33": {
    "en": "Click to go up",
    "rs": "Kliknite da idete gore",
    "rsc": "Кликните да идете gore"
  },
  "34": {
    "en": "Select folder",
    "rs": "Izaberi direktorijum",
    "rsc": "Изабери директоријум"
  },
  "35": {
    "en": "Save this path",
    "rs": "Sačuvajte ovu putanju",
    "rsc": "Сачувајте ову путању"
  },
  "36": {
    "en": "More folder options",
    "rs": "Više opcija direktorijuma",
    "rsc": "Вiше опциjа директоријума"
  },
  "37": {
    "en": "Refresh file browser",
    "rs": "Osvežite pregledač datoteka",
    "rsc": "Освежите прегледач датотека"
  },
  "38": {
    "en": "Clear workspace",
    "rs": "Očistite radni prostor",
    "rsc": "Очистите радни простор"
  },
  "39": {
    "en": "Clear command history",
    "rs": "Obrišite istoriju komandi",
    "rsc": "Обришите историjу команди"
  },
  "40": {
    "en": "Open settings",
    "rs": "Otvorite podešavanja",
    "rsc": "Отворите подешавања"
  },
  "41": {
    "en": "Hide timestamp",
    "rs": "Sakrij vremensku oznaku",
    "rsc": "Сакриj временску ознаку"
  },
  "42": {
    "en": "Turn off auto scroll",
    "rs": "Isključite automatsko pomeranje",
    "rsc": "Искључите аутоматско померање"
  },
  "43": {
    "en": "Clear command window",
    "rs": "Očistite komandni prozor",
    "rsc": "Очистите командни прозор"
  },
  "44": {
    "en": "Save log to file",
    "rs": "Sačuvajte dnevnik u datoteku",
    "rsc": "Сачуваjте дневник у датотеку"
  },
  "45": {
    "en": "Scroll to bottom",
    "rs": "Pomerite se do dna",
    "rsc": "Померите се до дна"
  },
  "46": {
    "en": "Close settings dialog",
    "rs": "Zatvorite dijalog podešavanja",
    "rsc": "Затворите диjалог подешавања"
  },
  "47": {
    "en": "File modified",
    "rs": "Fajl je izmenjen",
    "rsc": "Фајл је измењен"
  },
  "48": {
    "en": "The file",
    "rs": "Fajl",
    "rsc": "Фајл"
  },
  "49": {
    "en": "is about to be closed but has been modified. Do you want to save or discard the changes?",
    "rs": "će biti zatvoren ali je izmenjen. Da li želite da sačuvate ili odbacite izmene?",
    "rsc": "ће бити затворен али је измењен. Да ли желите да сачувате или одбаците измене?"
  },
  "50": {
    "en": "Save",
    "rs": "Sačuvaj",
    "rsc": "Сачувај"
  },
  "51": {
    "en": "Discard",
    "rs": "Odbaci",
    "rsc": "Одбаци"
  },
  "52": {
    "en": "Cancel",
    "rs": "Otkaži",
    "rsc": "Откажи"
  },
  "53": {
    "en": "Variable",
    "rs": "Promenljiva",
    "rsc": "Променљива"
  },
  "54": {
    "en": "Type",
    "rs": "Tip",
    "rsc": "Тип"
  },
  "55": {
    "en": "Class",
    "rs": "Klasa",
    "rsc": "Класа"
  },
  "56": {
    "en": "Command window settings",
    "rs": "Podešavanja komandnog prozora",
    "rsc": "Подешавања командног прозора"
  },
  "57": {
    "en": "Change settings",
    "rs": "Promenite podešavanja",
    "rsc": "Промените подешавања"
  },
  "58": {
    "en": "Save log",
    "rs": "Sačuvaj dnevnik",
    "rsc": "Сачувај дневник"
  },
  "59": {
    "en": "Write timestamps",
    "rs": "Upisuj vremenske oznake",
    "rsc": "Уписуј временске ознаке"
  },
  "60": {
    "en": "Save log",
    "rs": "Sačuvaj dnevnik",
    "rsc": "Сачувај дневник"
  },
  "61": {
    "en": "Session command history",
    "rs": "Istorija komandi",
    "rsc": "Историја команди"
  },
  "62": {
    "en": "Script directory",
    "rs": "Direktorijum skripte",
    "rsc": "Директоријум скрипте"
  },
  "63": {
    "en": "The directory",
    "rs": "Direktorijum",
    "rsc": "Директоријум"
  },
  "64": {
    "en": "is not a working directory nor a saved directory, would you like to change a working directory or save this directory?",
    "rs": "nije radni direktorijum niti sačuvani direktorijum, da li želite da promenite radni direktorijum ili sačuvate ovaj direktorijum?",
    "rsc": "није радни директоријум нити сачувани директоријум, да ли желите да промените радни директоријум или сачувате овај директоријум?"
  },
  "65": {
    "en": "Change working directory",
    "rs": "Promeni radni direktorijum",
    "rsc": "Промени радни директоријум"
  },
  "66": {
    "en": "Save directory",
    "rs": "Sačuvaj direktorijum",
    "rsc": "Сачувај директоријум"
  },
  "67": {
    "en": "Run",
    "rs": "Pokreni",
    "rsc": "Покрени"
  },
  "68": {
    "en": "Saved paths",
    "rs": "Sačuvane putanje",
    "rsc": "Сачуване путање"
  },
  "69": {
    "en": "Command window keyboard shortcuts",
    "rs": "Prečice tastature komandnog prozora",
    "rsc": "Пречице тастатуре командног прозора"
  },
  "70": {
    "en": "Shortcut",
    "rs": "Prečica",
    "rsc": "Пречица"
  },
  "71": {
    "en": "Action",
    "rs": "Akcija",
    "rsc": "Акција"
  },
  "72": {
    "en": "Clear input / Close dialog",
    "rs": "Obriši unos / Zatvori dijalog",
    "rsc": "Обриши унос / Затвори дијалог"
  },
  "73": {
    "en": "Go backward through the command history",
    "rs": "Idi unazad kroz istoriju komandi",
    "rsc": "Иди уназад кроз историју команди"
  },
  "74": {
    "en": "Go forward through the command history",
    "rs": "Idi unapred kroz istoriju komandi",
    "rsc": "Иди унапред кроз историју команди"
  },
  "75": {
    "en": "First command in the command history",
    "rs": "Prva komanda u istoriji komandi",
    "rsc": "Прва команда у историји команди"
  },
  "76": {
    "en": "Last command in the command history",
    "rs": "Poslednja komanda u istoriji komandi",
    "rsc": "Последња команда у историји команди"
  },
  "77": {
    "en": "Break the line",
    "rs": "Prekini liniju",
    "rsc": "Прекини линију"
  },
  "78": {
    "en": "Repeat the last command",
    "rs": "Ponovi poslednju komandu",
    "rsc": "Понови последњу команду"
  },
  "79": {
    "en": "Show the command history",
    "rs": "Prikaži istoriju komandi",
    "rsc": "Прикажи историју команди"
  },
  "80": {
    "en": "Clear the command history",
    "rs": "Obriši istoriju komandi",
    "rsc": "Обриши историју команди"
  },
  "81": {
    "en": "Complete current command from the command history",
    "rs": "Završi trenutnu komandu iz istorije komandi",
    "rsc": "Заврши тренутну команду из историје команди"
  },
  "82": {
    "en": "Focus command input",
    "rs": "Fokusiraj na unos komandi",
    "rsc": "Фокусирај на унос команди"
  },
  "83": {
    "en": "Open help",
    "rs": "Otvorite pomoć",
    "rsc": "Отворите помоћ"
  },
  "84": {
    "en": "Open settings dialog",
    "rs": "Otvorite dijalog podešavanja",
    "rsc": "Отворите дијалог подешавања"
  },
  "85": {
    "en": "Open log save dialog",
    "rs": "Otvorite dijalog za čuvanje dnevnika",
    "rsc": "Отворите дијалог за чување дневника"
  },
  "86": {
    "en": "This software uses open-source components stated below, copyright and other proprietary rights of these components belong to their respective owners.",
    "rs": "Ovaj softver koristi open-source komponente navedene ispod, autorska prava i druga prava intelektualne svojine ovih komponenti pripadaju njihovim vlasnicima.",
    "rsc": "Овај софтвер користи open-source компоненте наведене испод, ауторска права и друга права интелектуалне својине ових компоненти припадају њиховим власницима."
  },
  "87": {
    "en": "Ready...",
    "rs": "Spremno...",
    "rsc": "Спремно..."
  },
  "88": {
    "en": "Evaluating...",
    "rs": "Evaluacija...",
    "rsc": "Евалуација..."
  },
  "89": {
    "en": "Stop request sent by user...",
    "rs": "Korisnik je poslao zahtev za zaustavljanje...",
    "rsc": "Корисник је послао захтев за заустављање..."
  },
  "90": {
    "en": "Stop loop triggered...",
    "rs": "Petlja izvršavanja je zaustavljena...",
    "rsc": "Петља извршавања је заустављена..."
  },
  "91": {
    "en": "Sandbox activity",
    "rs": "Aktivnost radnog prostora",
    "rsc": "Активност радног простора"
  },
  "92": {
    "en": "Unable to scan directory",
    "rs": "Nije moguće skenirati direktorijum",
    "rsc": "Није могуће скенирати директоријум"
  },
  "93": {
    "en": "Running total of",
    "rs": "Ukupno pokrenuto",
    "rsc": "Укупно покренуто"
  },
  "94": {
    "en": "tests",
    "rs": "testova",
    "rsc": "тестова"
  },
  "95": {
    "en": "Test",
    "rs": "Test",
    "rsc": "Тест"
  },
  "96": {
    "en": "failed with error",
    "rs": "nije uspeo zbog greške",
    "rsc": "није успео због грешке"
  },
  "97": {
    "en": "failed",
    "rs": "nije uspeo",
    "rsc": "није успео"
  },
  "98": {
    "en": "passed",
    "rs": "uspešan",
    "rsc": "успешан"
  },
  "99": {
    "en": "Final results",
    "rs": "Konačni rezultati",
    "rsc": "Коначни резултати"
  },
  "100": {
    "en": "Tests passed",
    "rs": "Testovi uspešni",
    "rsc": "Тестови успешни"
  },
  "101": {
    "en": "Tests failed",
    "rs": "Testovi nisu uspešni",
    "rsc": "Тестови нису успешни"
  },
  "102": {
    "en": "There is no implemented tests.",
    "rs": "Nema implementiranih testova.",
    "rsc": "Нема имплементираних тестова."
  },
  "103": {
    "en": "Script not found at",
    "rs": "Skripta nije pronađena na",
    "rsc": "Скрипта није пронађена на"
  },
  "104": {
    "en": "Not enough lines in file",
    "rs": "Nema dovoljno linija u fajlu",
    "rsc": "Нема довољно линија у фајлу"
  },
  "105": {
    "en": "script",
    "rs": "skripta",
    "rsc": "скрипта"
  },
  "106": {
    "en": "File",
    "rs": "Fajl",
    "rsc": "Фајл"
  },
  "107": {
    "en": "is selected. There are also",
    "rs": "je odabran. Takođe postoje",
    "rsc": "је одабран. Такође постоје"
  },
  "108": {
    "en": "is selected. There is also",
    "rs": "je odabran. Takođe postoji",
    "rsc": "је одабран. Такође постоји"
  },
  "109": {
    "en": "Failed to find",
    "rs": "Nije pronađeno",
    "rsc": "Није пронађено"
  },
  "110": {
    "en": "module",
    "rs": "modul",
    "rsc": "модул"
  },
  "111": {
    "en": "Provided path is not string",
    "rs": "Data putanja nije niz karaktera",
    "rsc": "Дата путања није низ карактера"
  },
  "112": {
    "en": "line",
    "rs": "linija",
    "rsc": "линија"
  },
  "113": {
    "en": "column",
    "rs": "kolona",
    "rsc": "колона"
  },
  "114": {
    "en": "at",
    "rs": "na",
    "rsc": "на"
  },
  "115": {
    "en": "Not implemented!",
    "rs": "Nije implementirano!",
    "rsc": "Није имплементирано!"
  },
  "116": {
    "en": "Code arrived to user defined end point at line",
    "rs": "Kod je došao do korisnički definisane tačke zaustavaljanja na liniji",
    "rsc": "Код је дошао до кориснички дефинисане тачке заустављања на линији"
  },
  "117": {
    "en": "Unable to write to file",
    "rs": "Nije moguće pisati u fajl",
    "rsc": "Није могуће писати у фајл"
  },
  "118": {
    "en": "File content is not valid JSON",
    "rs": "Sadržaj fajla nije ispravan JSON",
    "rsc": "Садржај фајла није исправан JSON"
  },
  "119": {
    "en": "Folder selection canceled",
    "rs": "Odabir direktorijuma je otkazan",
    "rsc": "Одабир директоријума је отказан"
  },
  "120": {
    "en": "Content of binding.gyp is not valid JSON",
    "rs": "Sadržaj binding.gyp nije ispravan JSON",
    "rsc": "Садржај binding.gyp није исправан JSON"
  },
  "121": {
    "en": "Unknown response",
    "rs": "Nepoznat odgovor",
    "rsc": "Непознат одговор"
  },
  "122": {
    "en": "No targets defined",
    "rs": "Nisu definisani ciljevi",
    "rsc": "Нису дефинисани циљеви"
  },
  "123": {
    "en": "File binding.gyp not found",
    "rs": "Fajl binding.gyp nije pronađen",
    "rsc": "Фајл binding.gyp није пронађен"
  },
  "124": {
    "en": "Format not supported.",
    "rs": "Format nije podržan.",
    "rsc": "Формат није подржан."
  },
  "125": {
    "en": "User requested loop stop!.",
    "rs": "Korisnik je zatražio zaustavljanje petlje!.",
    "rsc": "Корисник је захтевао заустављање петље!."
  },
  "126": {
    "en": "Open canceled",
    "rs": "Otvaranje je otkazano",
    "rsc": "Отварање је отказано"
  },
  "127": {
    "en": "Callback is missing",
    "rs": "Callback nedostaje",
    "rsc": "Callback недостаје"
  },
  "128": {
    "en": "Unable to find files in folder",
    "rs": "Nije moguće pronaći fajlove u direktorijumu",
    "rsc": "Није могуће пронаћи фајлове у директоријуму"
  },
  "129": {
    "en": "Save canceled",
    "rs": "Čuvanje je otkazano",
    "rsc": "Чување је отказано"
  },
  "130": {
    "en": "Path override",
    "rs": "Pregažena putanja",
    "rsc": "Прегажена путања"
  },
  "131": {
    "en": "Script run aborted, file not saved.",
    "rs": "Izvršavanje skripte prekinuto, fajl nije sačuvan.",
    "rsc": "Извршавање скрипте прекинуто, фајл није сачуван."
  },
  "132": {
    "en": "File open canceled",
    "rs": "Otvaranje fajla je otkazano",
    "rsc": "Отварање фајла је отказано"
  },
  "133": {
    "en": "Script",
    "rs": "Skripta",
    "rsc": "Скрипта"
  },
  "134": {
    "en": "already open",
    "rs": "je već otvoren",
    "rsc": "је већ отворен"
  },
  "135": {
    "en": "For more information, visit",
    "rs": "Za više informacija, posetite",
    "rsc": "За више информација, посетите"
  },
  "136": {
    "en": "Copyright",
    "rs": "Autorsko pravo",
    "rsc": "Ауторско право"
  },
  "137": {
    "en": "This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.",
    "rs": "Ovaj program je besplatan softver: možete ga redistribuirati i/ili modifikovati pod uslovima GNU manje opšte javne licence koju je objavila Fondacija za slobodni softver, bilo verzije 3 licence, ili (po vašem izboru) bilo koje kasnije verzije.",
    "rsc": "Овај програм је бесплатан софтвер: можете га редистрибуирати и/или модификовати под условима ГНУ мање опште јавне лиценце коју је објавила Фондација за слободни софтвер, било верзије 3 лиценце, или (по вашем избору) било којe касније верзије."
  },
  "138": {
    "en": "This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.",
    "rs": "Ovaj program se distribuira u nadi da će biti koristan, ali BEZ IKAKVE GARANCIJE; čak i bez implicitne garancije o PRODAJNOSTI ili PRIKLADNOSTI ZA ODREĐENU NAMENU. Pogledajte GNU manje opštu javnu licencu za više detalja.",
    "rsc": "Овај програм се дистрибуира у нади да ће бити користан, али БЕЗ ИКАКВЕ ГАРАНЦИЈЕ; чак и без имплицитне гаранције о ПРОДАЈНОСТИ или ПРИКЛАДНОСТИ ЗА ОДРЕЂЕНУ НАМЕНУ. Погледајте ГНУ мање општу јавну лиценцу за више детаља."
  },
  "139": {
    "en": "For help type",
    "rs": "Za pomoć unesite",
    "rsc": "За помоћ унесите"
  },
  "140": {
    "en": "No saved paths.",
    "rs": "Nema sačuvanih putanja.",
    "rsc": "Нема сачуваних путања."
  },
  "141": {
    "en": "Choose N-API module folder",
    "rs": "Izaberite direktorijum N-API modula",
    "rsc": "Изаберите директоријум N-API модула"
  },
  "142": {
    "en": "Choose folder",
    "rs": "Izaberite direktorijum",
    "rsc": "Изаберите директоријум"
  },
  "143": {
    "en": "Save figure",
    "rs": "Sačuvajte grafik",
    "rsc": "Сачувајте график"
  },
  "144": {
    "en": "Save file",
    "rs": "Sačuvajte datoteku",
    "rsc": "Сачувајте датотеку"
  },
  "145": {
    "en": "Save file",
    "rs": "Sačuvajte datoteku",
    "rsc": "Сачувајте датотеку"
  },
  "146": {
    "en": "Load from file",
    "rs": "Učitajte iz datoteke",
    "rsc": "Учитајте из датотеке"
  },
  "147": {
    "en": "Load file",
    "rs": "Učitajte datoteku",
    "rsc": "Учитајте датотеку"
  },
  "148": {
    "en": "Choose working directory",
    "rs": "Izaberite radni direktorijum",
    "rsc": "Изаберите радни директоријум"
  },
  "149": {
    "en": "Set",
    "rs": "Postavi",
    "rsc": "Постави"
  },
  "150": {
    "en": "Save log file",
    "rs": "Sačuvajte datoteku dnevnikа",
    "rsc": "Сачувајте датотеку дневника"
  },
  "151": {
    "en": "Save log",
    "rs": "Sačuvajte dnevnik",
    "rsc": "Сачувајте дневник"
  },
  "152": {
    "en": "Plot save as",
    "rs": "Sačuvaj grafikon kao",
    "rsc": "Сачувај графикон као"
  },
  "153": {
    "en": "Zoom part of the plot",
    "rs": "Zumiraj deo grafikona",
    "rsc": "Зумирај део графикона"
  },
  "154": {
    "en": "Pan plot",
    "rs": "Pomeranje grafikona",
    "rsc": "Померaње графикона"
  },
  "155": {
    "en": "Rotate plot",
    "rs": "Rotiraj grafikon",
    "rsc": "Ротирај графикон"
  },
  "156": {
    "en": "Zoom in",
    "rs": "Uvećaj",
    "rsc": "Увећај"
  },
  "157": {
    "en": "Zoom out",
    "rs": "Umanji",
    "rsc": "Умањи"
  },
  "158": {
    "en": "Fit",
    "rs": "Prilagodi",
    "rsc": "Прилагоди"
  },
  "159": {
    "en": "Save As",
    "rs": "Sačuvaj kao",
    "rsc": "Сачувај као"
  },
  "160": {
    "en": "Zoom",
    "rs": "Zumiraj",
    "rsc": "Зумирај"
  },
  "161": {
    "en": "Pan",
    "rs": "Pomeranje",
    "rsc": "Померaње"
  },
  "162": {
    "en": "Rotate",
    "rs": "Rotiraj",
    "rsc": "Ротирај"
  },
  "163": {
    "en": "Zoom in",
    "rs": "Uvećaj",
    "rsc": "Увећај"
  },
  "164": {
    "en": "Zoom out",
    "rs": "Umanji",
    "rsc": "Умањи"
  },
  "165": {
    "en": "Fit",
    "rs": "Prilagodi",
    "rsc": "Прилагоди"
  },
  "166": {
    "en": "Show timestamp",
    "rs": "Prikaži vremensku oznaku",
    "rsc": "Прикажи временску ознаку"
  },
  "167": {
    "en": "Turn on auto scroll",
    "rs": "Uključite automatsko pomeranje",
    "rsc": "Укључите аутоматско померање"
  },
  "168": {
    "en": "Search",
    "rs": "Pretraga",
    "rsc": "Претрага"
  },
  "169": {
    "en": "Show search dialog",
    "rs": "Prikaži dijalog za pretragu",
    "rsc": "Прикажи дијалог за претрагу"
  },
  "170": {
    "en": "Failed to compile module!",
    "rs": "Neuspešno kompajliranje modula!",
    "rsc": "Неуспешно компајлирање модула!"
  },
  "171": {
    "en": "Unable to recompile module, try reseting sandbox with <span class='eval-code'> resetSandbox()</span> function.",
    "rs": "Nije moguće rekompajlirati modul, pokušajte reset sandbox-a sa <span class='eval-code'>resetSandbox()</span> funkcijom.",
    "rsc": "Није могуће рекомпајлирати модул, покушајте ресет sandbox-а са <span class='eval-code'>resetSandbox()</span> функцијом."
  },
  "172": {
    "en": "Figure is not opened.",
    "rs": "Grafik nije otvoren.",
    "rsc": "График није отворен."
  },
  "173": {
    "en": "Source directory does not exist.",
    "rs": "Izvorni direktorijum ne postoji.",
    "rsc": "Изворни директоријум не постоји."
  },
  "174": {
    "en": "Failed to open specified file in new window!",
    "rs": "Neuspešno otvaranje specificirane datoteke u novom prozoru!",
    "rsc": "Неуспешно отварање специфициране датотеке у новом прозору!"
  },
  "175": {
    "en": "Wait for lib to be loaded!",
    "rs": "Sačekajte da se biblioteka učita!",
    "rsc": "Сачекајте да се библиотека учита!"
  },
  "176": {
    "en": "Arrays must be of the same length!",
    "rs": "Nizovi moraju biti iste dužine!",
    "rsc": "Низови морају бити исте дужине!"
  },
  "177": {
    "en": "Invalid input types!",
    "rs": "Nevažeći tipovi ulaza!",
    "rsc": "Неважећи типови улаза!"
  },
  "178": {
    "en": "Array size does not match the dimensions provided.",
    "rs": "Veličina niza ne odgovara datim dimenzijama.",
    "rsc": "Величина низа не одговара датим димензијама."
  },
  "179": {
    "en": "FreeCAD instance already active!",
    "rs": "FreeCAD instanca je već aktivna!",
    "rsc": "FreeCAD инстанца је већ активна!"
  },
  "180": {
    "en": "Could not start FreeCAD!",
    "rs": "Nije moguće pokrenuti FreeCAD!",
    "rsc": "Није могуће покренути FreeCAD!"
  },
  "181": {
    "en": "Could not find FreeCAD TCP Server!",
    "rs": "Nije moguće pronaći FreeCAD TCP server!",
    "rsc": "Није могуће пронаћи FreeCAD TCP сервер!"
  },
  "182": {
    "en": "No FreeCAD instance!",
    "rs": "Nema FreeCAD instance!",
    "rsc": "Нема FreeCAD инстанце!"
  },
  "183": {
    "en": "File does not exist!",
    "rs": "Datoteka ne postoji!",
    "rsc": "Датотека не постоји!"
  },
  "184": {
    "en": "is a forbidden name.",
    "rs": "je zabranjeno ime.",
    "rsc": "је забрањено име."
  },
  "185": {
    "en": "Invalid variable declaration",
    "rs": "Nevažeća deklaracija promenljive",
    "rsc": "Неважећа декларација променљиве"
  },
  "186": {
    "en": "Invalid function declaration",
    "rs": "Nevažeća deklaracija funkcije",
    "rsc": "Неважећа декларација функције"
  },
  "187": {
    "en": "Invalid class declaration",
    "rs": "Nevažeća deklaracija klase",
    "rsc": "Неважећа декларација класе"
  },
  "188": {
    "en": "Invalid import",
    "rs": "Nevažeći import",
    "rsc": "Неважећи импорт"
  },
  "189": {
    "en": "Increment dx cannot be zero.",
    "rs": "Povećanje dx ne može biti nula.",
    "rsc": "Повећање dx не може бити нула."
  },
  "190": {
    "en": "Input must be an array.",
    "rs": "Ulaz mora biti niz.",
    "rsc": "Улаз мора бити низ."
  },
  "191": {
    "en": "Array is empty or contains only NaN values.",
    "rs": "Niz je prazan ili sadrži samo NaN vrednosti.",
    "rsc": "Низ је празан или садржи само NaN вредности."
  },
  "192": {
    "en": "Input must be a number, a complex number object, or an array thereof.",
    "rs": "Ulaz mora biti broj, objekat kompleksnog broja ili niz takvih objekata.",
    "rsc": "Улаз мора бити број, објекат комплексног броја или низ таквих објеката."
  },
  "193": {
    "en": "The file is not a valid OFF one.",
    "rs": "Datoteka nije validna OFF datoteka.",
    "rsc": "Датотека није валидна OFF датотека."
  },
  "194": {
    "en": "Incomplete header information in OFF file.",
    "rs": "Nepotpune informacije u zaglavlju OFF datoteke.",
    "rsc": "Непотпуне информације у заглављу OFF датотеке."
  },
  "195": {
    "en": "Problem in reading vertices.",
    "rs": "Problem pri čitanju tačaka.",
    "rsc": "Проблем при читању тачака."
  },
  "196": {
    "en": "Problem in reading faces.",
    "rs": "Problem pri čitanju stranica.",
    "rsc": "Проблем при читању страница."
  },
  "197": {
    "en": "Step size cannot be zero.",
    "rs": "Veličina koraka ne može biti nula.",
    "rsc": "Величина корака не може бити нула."
  },
  "198": {
    "en": "Step size does not align with start and end values.",
    "rs": "Veličina koraka se ne slaže sa početnim i krajnjim vrednostima.",
    "rsc": "Величина корака се не слаже са почетним и крајњим вредностима."
  },
  "199": {
    "en": "No file for window!",
    "rs": "Nema datoteke za prozor!",
    "rsc": "Нема датотеке за прозор!"
  },
  "200": {
    "en": "Alias 'as' is required when import is '*' in module ",
    "rs": "Alias 'as' je potreban kada je import '*' u modulu ",
    "rsc": "Alias 'as' је потребан када је import '*' у модулу "
  },
  "201": {
    "en": "No connection with OMC. Create a new instance of OpenModelicaLink session.",
    "rs": "Nema veze sa OMC-om. Kreirajte novu instancu OpenModelicaLink sesije.",
    "rsc": "Нема везе са OMC-ом. Креирајте нову инстанцу OpenModelicaLink сесије."
  },
  "202": {
    "en": "Model is not Linearized",
    "rs": "Model nije linearizovan",
    "rsc": "Модел није линеаризован"
  },
  "203": {
    "en": "Filename and modelname are required.",
    "rs": "Ime datoteke i ime modela su obavezni.",
    "rsc": "Име датотеке и име модела су обавезни."
  },
  "204": {
    "en": "XML file is not generated.",
    "rs": "XML datoteka nije generisana.",
    "rsc": "XML датотека није генерисана."
  },
  "205": {
    "en": "Model cannot be Simulated: executable not found.",
    "rs": "Model se ne može simulirati: izvršna datoteka nije pronađena.",
    "rsc": "Модел се не може симулирати: извршна датотека није пронађена."
  },
  "206": {
    "en": "Model cannot be Simulated: xmlfile not found.",
    "rs": "Model se ne može simulirati: XML datoteka nije pronađena.",
    "rsc": "Модел се не може симулирати: XML датотека није пронађена."
  },
  "207": {
    "en": "Linearization cannot be performed: ",
    "rs": "Linearizacija se ne može izvršiti: ",
    "rsc": "Линеаризација се не може извршити: "
  },
  "208": {
    "en": "Result File does not exist! ",
    "rs": "Datoteka sa rezultatima ne postoji! ",
    "rsc": "Датотека са резултатима не постоји! "
  },
  "209": {
    "en": " is not a parameter",
    "rs": " nije parametar",
    "rsc": " није параметар"
  },
  "210": {
    "en": " is not a Simulation Option",
    "rs": " nije opcija za simulaciju",
    "rsc": " није опција за симулацију"
  },
  "211": {
    "en": " is not a Linearization Option",
    "rs": " nije opcija za linearizaciju",
    "rsc": " није опција за линеаризацију"
  },
  "212": {
    "en": " is not an Input",
    "rs": " nije ulaz",
    "rsc": " није улаз"
  },
  "213": {
    "en": "You can see current workspace in main window. Would you like to continue?",
    "rs": "Možete videti trenutni radni prostor u glavnom prozoru. Da li želite da nastavite?",
    "rsc": "Можете видети тренутни радни простор у главном прозору. Да ли желите да наставите?"
  },
  "214": {
    "en": "yes",
    "rs": "da",
    "rsc": "да"
  },
  "215": {
    "en": "no",
    "rs": "ne",
    "rsc": "не"
  },
  "216": {
    "en": "Code arrived to breakpoint at line",
    "rs": "Kod je dostigao breakpoint na liniji",
    "rsc": "Код је досегао breakpoint на линији"
  },
  "217": {
    "en": "Code paused at line",
    "rs": "Kod je pauziran na liniji",
    "rsc": "Код је паузиран на линији"
  },
  "218": {
    "en": "No help found for ",
    "rs": "Nije pronadjena dokumentacija za ",
    "rsc": "Није пронађена документација за "
  },
  "219": {
    "en": "Open documentation",
    "rs": "Otvorite dokumentaciju",
    "rsc": "Отворите документацију"
  },
  "220": {
    "en": "No source code found for ",
    "rs": "Nije pronadjen kod za ",
    "rsc": "Није пронађен код за "
  },
  "221": {
    "en": "Reset",
    "rs": "Reset",
    "rsc": "Ресет"
  },
  "222": {
    "en": "Unable to find audio/video device!",
    "rs": "Nije moguće pronaći audio/video uređaj!",
    "rsc": "Није могуће пронаћи аудио/видео уређај!"
  },
  "223": {
    "en": "Number of commands in history",
    "rs": "Broj komandi u istoriji",
    "rsc": "Број команди у историји"
  },
  "224": {
    "en": "Program arduino-cli not found.",
    "rs": "Program arduino-cli nije pronadjen.",
    "rsc": "Програм arduino-cli није пронађен."
  },
  "225": {
    "en": "Configuration file for arduino-cli not found.",
    "rs": "Konfiguracioni fajl za arduino-cli nije pronadjen.",
    "rsc": "Конфигурациони фајл за arduino-cli није пронађен."
  },
  "226": {
    "en": "Submit command to workspace.",
    "rs": "Pošalji komandu radnom prostoru.",
    "rsc": "Пошаљи команду радном простору."
  },
  "227": {
    "en": "Compile",
    "rs": "Kompajliraj",
    "rsc": "Компајлирај"
  },
  "228": {
    "en": "Upload",
    "rs": "Otpremi",
    "rsc": "Отпреми"
  },
  "229": {
    "en": "Program file for arduino-cli not found.",
    "rs": "Fajl programa za arduino-cli nije pronadjen.",
    "rsc": "Фајл програма за arduino-cli није пронађен."
  },
  "230": {
    "en": "No available ports.",
    "rs": "Nema dostupnih portova.",
    "rsc": "Нема доступних портова."
  },
  "231": {
    "en": "Choose",
    "rs": "Izaberi",
    "rsc": "Изабери"
  },
  "232": {
    "en": "Port",
    "rs": "Port",
    "rsc": "Порт"
  },
  "233": {
    "en": "Baudrate",
    "rs": "Brzina",
    "rsc": "Брзина"
  },
  "234": {
    "en": "Type your message...",
    "rs": "Unesite svoju poruku...",
    "rsc": "Унесите своју поруку..."
  },
  "235": {
    "en": "Unknown method!",
    "rs": "Nepoznati metod!",
    "rsc": "Непознати метод!"
  },
  "236": {
    "en": "Save video",
    "rs": "Sačuvajte video",
    "rsc": "Сачувајте видео"
  },
  "237": {
    "en": "Unable to check for update without internet.",
    "rs": "Nije moguće proveriti da li postoji novija verzija bez interneta.",
    "rsc": "Није могуће проверити да ли постоји новија верзија без интернета."
  },
  "238": {
    "en": "Update available at: ",
    "rs": "Novija verzija dostupna na: ",
    "rsc": "Новија верзија доступна на: "
  },
  "239": {
    "en": "Choose presentation folder",
    "rs": "Izaberi folder prezentacije",
    "rsc": "Изабери фолдер презентације"
  },
  "240": {
    "en": "Invalid presentation folder!",
    "rs": "Neispravan folder prezentacije!",
    "rsc": "Неисправан фолдер презентације!"
  },
  "241": {
    "en": "Packed presentation available at: ",
    "rs": "Spakovana prezentacija je dostupna na adresi: ",
    "rsc": "Спакована презентација је доступна на адреси: "
  },
  "242": {
    "en": "Presentation display",
    "rs": "Prikaz prezentacije",
    "rsc": "Приказ презентације"
  },
  "243": {
    "en": "Presentation code",
    "rs": "Kod prezentacije",
    "rsc": "Код презентације"
  },
  "244": {
    "en": "PDF presentation available at: ",
    "rs": "PDF prezentacija je dostupna na adresi: ",
    "rsc": "PDF презентација је доступна на адреси: "
  },
  "245": {
    "en": "Fold slides",
    "rs": "Preklopi slajdove",
    "rsc": "Преклопи слајдове"
  },
  "246": {
    "en": "Unfold slides",
    "rs": "Otklopi slajdove",
    "rsc": "Отклопи слајдове"
  },
  "247": {
    "en": "Choose JSON file",
    "rs": "Izaberite JSON dokument",
    "rsc": "Изаберите JSON документ"
  },
  "248": {
    "en": "Invalid file!",
    "rs": "Neispravan dokument!",
    "rsc": "Неисправан документ!"
  }
} 
\end{lstlisting}

% ----------------------------------------
\section{cpp}


\begin{lstlisting}[style=C++Style, caption={alpha-shape-3d.cpp}]
// AlphaShape3D - alpha-shape-3d.cpp
// Author: Milos Petrasinovic <mpetrasinovic@prdc.rs>
// PR-DC, Republic of Serbia
// info@prdc.rs
// --------------------

#include "alpha-shape-3d.h"

namespace alpha_shape_3d_ns {
  
#ifdef PROFILE_SOLVER_MP_6RSS
// Function to start the timer and return the start time
time_point<steady_clock> tic() {
  return steady_clock::now();
}

// Function to stop the timer and return the elapsed time
long toc(const time_point<steady_clock>& startTime) {
  return duration_cast<milliseconds>(steady_clock::now() - startTime).count();
}
#endif

// Function to get current time
std::string getCurrentTime() {
  // get current time
  auto now = system_clock::now();

  // get number of milliseconds for the current second
  // (remainder after division into seconds)
  auto ms = duration_cast<milliseconds>(now.time_since_epoch()) % 1000;

  // convert to std::time_t in order to convert to std::tm (broken time)
  auto timer = system_clock::to_time_t(now);

  // convert to broken time
  std::tm bt = *std::localtime(&timer);

  std::ostringstream oss;

  oss << std::put_time(&bt, "%H:%M:%S"); // HH:MM:SS
  oss << '.' << std::setfill('0') << std::setw(3) << ms.count();

  return oss.str();
}

// Function to console log data
int consoleLog(uint8_t level, const char* format, ...) {
#ifdef DEBUG_SOLVER_MP_6RSS_LEVEL
  if(level <= DEBUG_SOLVER_MP_6RSS_LEVEL) {
    printf("\033[0;33m[%s SolverMP6RSS]\033[0m ", getCurrentTime().c_str());
    va_list vl;
    va_start(vl, format);
    auto ret = vprintf(format, vl);
    va_end(vl);
    printf("\n");
    return ret;
  }
#endif
  return 0;
}

// AlphaShape3D()
// Object constructor
// --------------------
AlphaShape3D::AlphaShape3D(const Napi::CallbackInfo& info) : Napi::ObjectWrap<AlphaShape3D>(info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called constructor");
#endif
  this->alphaShape = nullptr;
  this->delaunayTriangulation = nullptr;
}

// ~AlphaShape3D()
// Object destructor
// --------------------
AlphaShape3D::~AlphaShape3D(void) {
  if(this->delaunayTriangulation){
    delete this->delaunayTriangulation;
    this->delaunayTriangulation = nullptr;
  }
  if(this->alphaShape){
    delete this->alphaShape;
    this->alphaShape = nullptr;
  }
}

// Init() function
// --------------------
Napi::Object AlphaShape3D::Init(Napi::Env env, Napi::Object exports) {
  Napi::Function func = DefineClass(env, "AlphaShape3D", {
    InstanceMethod("newShape", &AlphaShape3D::NewShapeJS),
    InstanceMethod("getAlpha", &AlphaShape3D::GetAlphaJS),
    InstanceMethod("setAlpha", &AlphaShape3D::SetAlphaJS),
    InstanceMethod("getNumRegions", &AlphaShape3D::GetNumRegionsJS),
    InstanceMethod("getAlphaSpectrum", &AlphaShape3D::GetAlphaSpectrumJS),
    InstanceMethod("getCriticalAlpha", &AlphaShape3D::GetCriticalAlphaJS),
    InstanceMethod("getSurfaceArea", &AlphaShape3D::GetSurfaceAreaJS),
    InstanceMethod("getVolume", &AlphaShape3D::GetVolumeJS),
    InstanceMethod("getBoundaryFacets", &AlphaShape3D::GetBoundaryFacetsJS),
    InstanceMethod("writeBoundaryFacets", &AlphaShape3D::WriteBoundaryFacetsJS),
    InstanceMethod("checkInShape", &AlphaShape3D::CheckInShapeJS),
    InstanceMethod("writeOff", &AlphaShape3D::WriteOffJS),
    InstanceMethod("getTriangulation", &AlphaShape3D::GetTriangulationJS),
    InstanceMethod("getNearestNeighbor", &AlphaShape3D::GetNearestNeighborJS),
    InstanceMethod("getSimplifiedShape", &AlphaShape3D::GetSimplifiedShapeJS),
    InstanceMethod("removeUnusedPoints", &AlphaShape3D::RemoveUnusedPointsJS)
  });
  Napi::FunctionReference* constructor = new Napi::FunctionReference();
  *constructor = Napi::Persistent(func);
  env.SetInstanceData(constructor);

  exports.Set("AlphaShape3D", func);
  return exports;
}

// NewShapeJS() function
// --------------------
void AlphaShape3D::NewShapeJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called NewShapeJS()");
#endif

  Napi::Env env = info.Env();
  if(info.Length() < 1 || !info[0].IsArray()){
    Napi::TypeError::New(env, "Array of points expected").ThrowAsJavaScriptException();
    return;
  }

  Napi::Array jsPoints = info[0].As<Napi::Array>();
  uint32_t numPoints = jsPoints.Length();

  // Clear existing data to prevent accumulation
  this->inputPoints.resize(0, 0);
  this->Points.clear();
  this->Vertices.clear();

  // Initialize inputPoints matrix
  this->inputPoints.resize(numPoints, 3);

  for(uint32_t i = 0; i < numPoints; i++){
    Napi::Value point = jsPoints[i];
    if(!point.IsArray()){
      Napi::TypeError::New(env, "Each point should be an array of 3 numbers").ThrowAsJavaScriptException();
      return;
    }
    Napi::Array jsPoint = point.As<Napi::Array>();
    if(jsPoint.Length() != 3){
      Napi::TypeError::New(env, "Each point should have exactly 3 coordinates").ThrowAsJavaScriptException();
      return;
    }

    for(uint32_t j = 0; j < 3; j++){
      this->inputPoints(i, j) = jsPoint.Get(j).As<Napi::Number>().DoubleValue();
    }
  }

#ifdef DEBUG_ALPHA_SHAPE_3D  
  std::chrono::steady_clock::time_point begin = 
    std::chrono::steady_clock::now();
#endif

  uint32_t n = this->inputPoints.numRows();

#ifdef DEBUG_ALPHA_SHAPE_3D
  std::cout << "Reading " << n << " points " << std::endl;
#endif

  for(std::size_t i = 0; i < n; i++){
    this->Points.emplace_back(
      Point(this->inputPoints(i, 0), this->inputPoints(i, 1), this->inputPoints(i, 2)));
    this->Vertices.emplace_back(std::make_pair(this->Points.back(), i));
  }

#ifdef DEBUG_ALPHA_SHAPE_3D
  std::cout << "Computing delaunay triangulation." << std::endl;
#endif

  // Delete existing triangulation and alphaShape to prevent memory leaks
  if(this->delaunayTriangulation){
    delete this->delaunayTriangulation;
    this->delaunayTriangulation = nullptr;
  }
  if(this->alphaShape){
    delete this->alphaShape;
    this->alphaShape = nullptr;
  }

  this->delaunayTriangulation = new Dt(this->Vertices.begin(), this->Vertices.end());

#ifdef DEBUG_ALPHA_SHAPE_3D
  std::cout << "Number of triangulation cells is " 
            << this->delaunayTriangulation->number_of_finite_cells() << std::endl;
#endif

  this->triangulationMatrix.resize(this->delaunayTriangulation->number_of_finite_cells()*4, 3);
  uint64_t i_idx = 0;
  for(Dt::Finite_cells_iterator cit = this->delaunayTriangulation->finite_cells_begin();
        cit != this->delaunayTriangulation->finite_cells_end(); cit++){
    this->triangulationMatrix(i_idx, 0) = cit->vertex(0)->info();
    this->triangulationMatrix(i_idx, 1) = cit->vertex(1)->info();
    this->triangulationMatrix(i_idx, 2) = cit->vertex(2)->info();
    i_idx++;
    this->triangulationMatrix(i_idx, 0) = cit->vertex(0)->info();
    this->triangulationMatrix(i_idx, 1) = cit->vertex(2)->info();
    this->triangulationMatrix(i_idx, 2) = cit->vertex(3)->info();
    i_idx++;
    this->triangulationMatrix(i_idx, 0) = cit->vertex(1)->info();
    this->triangulationMatrix(i_idx, 1) = cit->vertex(2)->info();
    this->triangulationMatrix(i_idx, 2) = cit->vertex(3)->info();
    i_idx++;
    this->triangulationMatrix(i_idx, 0) = cit->vertex(0)->info();
    this->triangulationMatrix(i_idx, 1) = cit->vertex(1)->info();
    this->triangulationMatrix(i_idx, 2) = cit->vertex(3)->info();
    i_idx++;
  }
  
#ifdef DEBUG_ALPHA_SHAPE_3D
  std::cout << "Computing alpha shapes." << std::endl;
#endif
  this->alphaShape = new As3(*this->delaunayTriangulation, As3::GENERAL);

  this->numAlphaValues = this->alphaShape->number_of_alphas();

#ifdef DEBUG_ALPHA_SHAPE_3D
  std::cout << "Number of alpha values is " 
            << this->numAlphaValues << std::endl;
  std::cout << "Max alpha value is " 
            << this->alphaShape->get_nth_alpha(this->numAlphaValues) << std::endl;
  std::cout << "Min of alpha value is " 
            << this->alphaShape->get_nth_alpha(1) << std::endl;
#ifdef PROFILE_SOLVER_MP_6RSS
  std::chrono::steady_clock::time_point end = 
    std::chrono::steady_clock::now();
  std::cout << "Time elapsed = "
      << std::chrono::duration_cast<std::chrono::milliseconds> 
        (end - begin).count()
      << " ms" << std::endl;
#endif
#endif
}

// GetAlphaJS() function
// --------------------
Napi::Value AlphaShape3D::GetAlphaJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetAlphaJS()");
#endif

  Napi::Env env = info.Env();
  double result = this->getAlpha();
  return Napi::Number::New(env, result);
}

// SetAlphaJS() function
// --------------------
void AlphaShape3D::SetAlphaJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called SetAlphaJS()");
#endif

  Napi::Env env = info.Env();
  if(info.Length() < 1 || !info[0].IsNumber()){
    Napi::TypeError::New(env, "Number expected").ThrowAsJavaScriptException();
  }
  double alpha = info[0].As<Napi::Number>().DoubleValue();
  this->setAlpha(alpha);
}

// GetNumRegionsJS() function
// --------------------
Napi::Value AlphaShape3D::GetNumRegionsJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetNumRegionsJS()");
#endif

  Napi::Env env = info.Env();
  double result = this->numRegions();
  return Napi::Number::New(env, result);
}

// GetAlphaSpectrumJS() function
// --------------------
Napi::Value AlphaShape3D::GetAlphaSpectrumJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetAlphaSpectrumJS()");
#endif

  Napi::Env env = info.Env();
  Matrix spectrum = this->getAlphaSpectrum();
  Napi::Array result = Napi::Array::New(env, spectrum.numCols());
  for(size_t i = 0; i < spectrum.numCols(); i++){
    result.Set(i, Napi::Number::New(env, spectrum(0, i)));
  }
  return result;
}

// GetCriticalAlphaJS() function
// --------------------
Napi::Value AlphaShape3D::GetCriticalAlphaJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetCriticalAlphaJS()");
#endif

  Napi::Env env = info.Env();
  if(info.Length() < 1 || !info[0].IsString()){
    Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
    return env.Null();
  }
  std::string type = info[0].As<Napi::String>().Utf8Value();
  double result = this->getCriticalAlpha(type);
  return Napi::Number::New(env, result);
}

// GetSurfaceAreaJS() function
// --------------------
Napi::Value AlphaShape3D::GetSurfaceAreaJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetSurfaceAreaJS()");
#endif

  Napi::Env env = info.Env();
  double result = this->getSurfaceArea();
  return Napi::Number::New(env, result);
}

// GetVolumeJS() function
// --------------------
Napi::Value AlphaShape3D::GetVolumeJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetVolumeJS()");
#endif

  Napi::Env env = info.Env();
  double result = this->getVolume();
  return Napi::Number::New(env, result);
}

// GetBoundaryFacetsJS() function
// --------------------
Napi::Value AlphaShape3D::GetBoundaryFacetsJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetBoundaryFacetsJS()");
#endif

  Napi::Env env = info.Env();
  Matrix facets = this->getBoundaryFacets();
  Napi::Array result = Napi::Array::New(env, facets.numRows());
  for(size_t i = 0; i < facets.numRows(); i++){
    Napi::Array facet = Napi::Array::New(env, 3);
    for(size_t j = 0; j < 3; j++){
      facet.Set(j, Napi::Number::New(env, facets(i, j)));
    }
    result.Set(i, facet);
  }
  return result;
}

// WriteBoundaryFacetsJS() function
// --------------------
void AlphaShape3D::WriteBoundaryFacetsJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called WriteBoundaryFacetsJS()");
#endif

  Napi::Env env = info.Env();
  if(info.Length() < 1 || !info[0].IsString()){
    Napi::TypeError::New(env, "String expected").ThrowAsJavaScriptException();
  }
  std::string filename = info[0].As<Napi::String>().Utf8Value();
  this->writeBoundaryFacets(filename);
}

// CheckInShapeJS() function
// --------------------
Napi::Value AlphaShape3D::CheckInShapeJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called CheckInShapeJS()");
#endif

  Napi::Env env = info.Env();
  if(info.Length() < 1 || !info[0].IsArray()){
    Napi::TypeError::New(env, "Array expected").ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Array jsArray = info[0].As<Napi::Array>();
  Matrix QP(jsArray.Length(), 3);
  for(size_t i = 0; i < jsArray.Length(); i++){
    Napi::Array point = jsArray.Get(i).As<Napi::Array>();
    for(size_t j = 0; j < 3; j++){
      QP(i, j) = point.Get(j).As<Napi::Number>().DoubleValue();
    }
  }
  Matrix result = this->checkInShape(QP);
  Napi::Array jsResult = Napi::Array::New(env, result.numRows());
  for(size_t i = 0; i < result.numRows(); i++){
    jsResult.Set(i, Napi::Boolean::New(env, result(i, 0) != 0));
  }
  return jsResult;
}

// WriteOffJS() function
// --------------------
void AlphaShape3D::WriteOffJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called WriteOffJS()");
#endif

  Napi::Env env = info.Env();
  if(info.Length() < 3 || !info[0].IsString() || !info[1].IsArray() || !info[2].IsArray()){
    Napi::TypeError::New(env, "Expected arguments: filename (string), points (array), facets (array)").ThrowAsJavaScriptException();
  }

  std::string filename = info[0].As<Napi::String>().Utf8Value();
  Napi::Array jsPoints = info[1].As<Napi::Array>();
  Napi::Array jsFacets = info[2].As<Napi::Array>();

  Matrix Points(jsPoints.Length(), 3);
  Matrix bf(jsFacets.Length(), 3);

  for(size_t i = 0; i < jsPoints.Length(); i++){
    Napi::Array point = jsPoints.Get(i).As<Napi::Array>();
    for(size_t j = 0; j < 3; j++){
      Points(i, j) = point.Get(j).As<Napi::Number>().DoubleValue();
    }
  }

  for(size_t i = 0; i < jsFacets.Length(); i++){
    Napi::Array facet = jsFacets.Get(i).As<Napi::Array>();
    for(size_t j = 0; j < 3; j++){
      bf(i, j) = facet.Get(j).As<Napi::Number>().DoubleValue();
    }
  }

  this->writeOff(filename, Points, bf);
}

// GetTriangulationJS() function
// --------------------
Napi::Value AlphaShape3D::GetTriangulationJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetTriangulationJS()");
#endif

  Napi::Env env = info.Env();
  Matrix triangulation = this->getTriangulation();
  Napi::Array result = Napi::Array::New(env, triangulation.numRows());
  for(size_t i = 0; i < triangulation.numRows(); i++){
    Napi::Array row = Napi::Array::New(env, 3);
    for(size_t j = 0; j < 3; j++){
      row.Set(j, Napi::Number::New(env, triangulation(i, j)));
    }
    result.Set(i, row);
  }
  return result;
}

// GetNearestNeighborJS() function
// --------------------
Napi::Value AlphaShape3D::GetNearestNeighborJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetNearestNeighborJS()");
#endif

  Napi::Env env = info.Env();
  if(info.Length() < 1 || !info[0].IsArray()){
    Napi::TypeError::New(env, "Array expected").ThrowAsJavaScriptException();
    return env.Null();
  }
  Napi::Array jsArray = info[0].As<Napi::Array>();
  Matrix QP(jsArray.Length(), 3);
  for(size_t i = 0; i < jsArray.Length(); i++){
    Napi::Array point = jsArray.Get(i).As<Napi::Array>();
    for(size_t j = 0; j < 3; j++){
      QP(i, j) = point.Get(j).As<Napi::Number>().DoubleValue();
    }
  }
  std::pair<Matrix, Matrix> result = this->getNearestNeighbor(QP);
  
  
  Napi::Object jsResult = Napi::Object::New(env);
  
  Napi::Array indices = Napi::Array::New(env, result.first.numRows());
  Napi::Array distances = Napi::Array::New(env, result.second.numRows());
  
  for(size_t i = 0; i < result.first.numRows(); i++){
    indices.Set(i, Napi::Number::New(env, result.first(i, 0)));
    distances.Set(i, Napi::Number::New(env, result.second(i, 0)));
  }
  
  jsResult.Set("indices", indices);
  jsResult.Set("distances", distances);
  return jsResult;
}

// GetSimplifiedShapeJS() function
// --------------------
Napi::Value AlphaShape3D::GetSimplifiedShapeJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called GetSimplifiedShapeJS()");
#endif

  Napi::Env env = info.Env();
  std::pair<Matrix, Matrix> result;
  
  if(info.Length() == 0){
    result = this->getSimplifiedShape();
  }
  else if(info.Length() == 1){
    if(info[0].IsNumber()){
      double stop_ratio = info[0].As<Napi::Number>().DoubleValue();
      result = this->getSimplifiedShape(stop_ratio);
    }
    else if(info[0].IsString()){
      std::string filename = info[0].As<Napi::String>().Utf8Value();
      result = this->getSimplifiedShape(filename);
    }
    else{
      Napi::TypeError::New(env, "Invalid argument type").ThrowAsJavaScriptException();
      return env.Null();
    }
  }
  else if(info.Length() == 2 && info[0].IsNumber() && info[1].IsString()){
    double stop_ratio = info[0].As<Napi::Number>().DoubleValue();
    std::string filename = info[1].As<Napi::String>().Utf8Value();
    result = this->getSimplifiedShape(stop_ratio, filename);
  }
  else{
    Napi::TypeError::New(env, "Invalid arguments").ThrowAsJavaScriptException();
    return env.Null();
  }
  
  Napi::Object jsResult = Napi::Object::New(env);
  Napi::Array points = Napi::Array::New(env, result.first.numRows());
  Napi::Array facets = Napi::Array::New(env, result.second.numRows());
  
  for(size_t i = 0; i < result.first.numRows(); i++){
    Napi::Array point = Napi::Array::New(env, 3);
    for(size_t j = 0; j < 3; j++){
      point.Set(j, Napi::Number::New(env, result.first(i, j)));
    }
    points.Set(i, point);
  }
  
  for(size_t i = 0; i < result.second.numRows(); i++){
    Napi::Array facet = Napi::Array::New(env, 3);
    for(size_t j = 0; j < 3; j++){
      facet.Set(j, Napi::Number::New(env, result.second(i, j)));
    }
    facets.Set(i, facet);
  }
  
  jsResult.Set("points", points);
  jsResult.Set("facets", facets);
  return jsResult;
}

// RemoveUnusedPointsJS() function
// --------------------
Napi::Value AlphaShape3D::RemoveUnusedPointsJS(const Napi::CallbackInfo& info) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called RemoveUnusedPointsJS()");
#endif

  Napi::Env env = info.Env();
  if(info.Length() < 2 || !info[0].IsArray() || !info[1].IsArray()){
    Napi::TypeError::New(env, "Two arrays expected").ThrowAsJavaScriptException();
    return env.Null();
  }
  
  Napi::Array jsPoints = info[0].As<Napi::Array>();
  Napi::Array jsFacets = info[1].As<Napi::Array>();
  
  Matrix Pi(jsPoints.Length(), 3);
  Matrix bfi(jsFacets.Length(), 3);
  
  for(size_t i = 0; i < jsPoints.Length(); i++){
    Napi::Array point = jsPoints.Get(i).As<Napi::Array>();
    for(size_t j = 0; j < 3; j++){
      Pi(i, j) = point.Get(j).As<Napi::Number>().DoubleValue();
    }
  }
  
  for(size_t i = 0; i < jsFacets.Length(); i++){
    Napi::Array facet = jsFacets.Get(i).As<Napi::Array>();
    for(size_t j = 0; j < 3; j++){
      bfi(i, j) = facet.Get(j).As<Napi::Number>().DoubleValue();
    }
  }
  
  std::pair<Matrix, Matrix> result = this->removeUnusedPoints(Pi, bfi);
  
  Napi::Object jsResult = Napi::Object::New(env);
  Napi::Array points = Napi::Array::New(env, result.first.numRows());
  Napi::Array facets = Napi::Array::New(env, result.second.numRows());
  
  for(size_t i = 0; i < result.first.numRows(); i++){
    Napi::Array point = Napi::Array::New(env, 3);
    for(size_t j = 0; j < 3; j++){
      point.Set(j, Napi::Number::New(env, result.first(i, j)));
    }
    points.Set(i, point);
  }
  
  for(size_t i = 0; i < result.second.numRows(); i++){
    Napi::Array facet = Napi::Array::New(env, 3);
    for(size_t j = 0; j < 3; j++){
      facet.Set(j, Napi::Number::New(env, result.second(i, j)));
    }
    facets.Set(i, facet);
  }
  
  jsResult.Set("points", points);
  jsResult.Set("facets", facets);
  return jsResult;
}  

// getAlpha() function
// --------------------
double AlphaShape3D::getAlpha(void) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called getAlpha()");
#endif

  return this->alphaShape->get_alpha();
}

// setAlpha() function
// --------------------
void AlphaShape3D::setAlpha(double alpha) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called setAlpha()");
#endif

  this->surface_mesh.clear();
  this->alphaShape->set_alpha(alpha);
  
#ifdef DEBUG_ALPHA_SHAPE_3D
  std::cout << "Number of solid components for alpha " << alpha
      << " is " << this->numRegions() << std::endl;
  std::list<As3::Cell_handle>     cells;
  std::list<As3::Facet>           facets;
  std::list<As3::Edge>            edges;
  std::list<As3::Vertex_handle>   vertices;
  this->alphaShape->get_alpha_shape_cells(std::back_inserter(cells),
      As3::INTERIOR);
  this->alphaShape->get_alpha_shape_facets(std::back_inserter(facets),
      As3::REGULAR);
  this->alphaShape->get_alpha_shape_facets(std::back_inserter(facets),
      As3::SINGULAR);
  this->alphaShape->get_alpha_shape_edges(std::back_inserter(edges),
      As3::SINGULAR);
  this->alphaShape->get_alpha_shape_vertices(std::back_inserter(vertices),
      As3::REGULAR);
  std::cout << "Number of interior tetrahedra is " 
            << cells.size() << std::endl;
  std::cout << "Number of boundary facets is " 
            << facets.size() << std::endl;
  std::cout << "Number of singular edges is " 
            << edges.size() << std::endl;
  std::cout << "Number of singular vertices is " 
            << vertices.size() << std::endl;
  std::cout << "Boundary surface construction." << std::endl;
#endif

  std::vector<As3::Facet> bfacets;
  this->alphaShape->get_alpha_shape_facets(std::back_inserter(bfacets), 
    As3::REGULAR);

  std::size_t nbf = bfacets.size();
  std::vector<CGAL_Polygon> polygons;
  CGAL_Polygon p;
  
  for(std::size_t i = 0; i < nbf; i++){
    if(this->alphaShape->classify(bfacets[i].first) != As3::EXTERIOR)
      bfacets[i] = this->alphaShape->mirror_facet(bfacets[i]);

    int32_t indices[3] = {
      (bfacets[i].second + 1) % 4,
      (bfacets[i].second + 2) % 4,
      (bfacets[i].second + 3) % 4,
    };

    // Consistent orientation
    if(bfacets[i].second % 2 == 0) std::swap(indices[0], indices[1]);

    p.clear();
    for(uint8_t j = 0; j < 3; j++){
      p.push_back(bfacets[i].first->vertex(indices[j])->info());
    }
    polygons.push_back(p);
  }

  PMP::polygon_soup_to_polygon_mesh(this->Points, 
    polygons, this->surface_mesh);
}

// numRegions() function
// --------------------
double AlphaShape3D::numRegions(void) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called numRegions()");
#endif

  return this->alphaShape->number_of_solid_components();
}

// getAlphaSpectrum() function
// --------------------
Matrix AlphaShape3D::getAlphaSpectrum() {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called getAlphaSpectrum()");
#endif

  Matrix a(1, this->numAlphaValues);
  for(uint32_t i = 0; i < this->numAlphaValues; i++){
    a(0, i) = this->alphaShape->get_nth_alpha(i + 1);
  }
  return a;
}

// getCriticalAlpha() function
// --------------------
double AlphaShape3D::getCriticalAlpha(std::string type) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called getCriticalAlpha()");
#endif

  if(type == "all-points"){
    return this->alphaShape->find_alpha_solid();
  }
  else if(type == "one-region"){
    return *this->alphaShape->find_optimal_alpha(1);
  }
  else{
    return nan("");
  }
}

// getSurfaceArea() function
// --------------------
double AlphaShape3D::getSurfaceArea(void) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called getSurfaceArea()");
#endif

  return PMP::area(this->surface_mesh);
}

// getVolume() function
// --------------------
double AlphaShape3D::getVolume(void) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called getVolume()");
#endif

  return PMP::volume(this->surface_mesh);
}

// getBoundaryFacets() function
// --------------------
Matrix AlphaShape3D::getBoundaryFacets(void) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called getBoundaryFacets()");
#endif

  Matrix bf(this->surface_mesh.number_of_faces(), 3);
  for(Mesh::Face_index face_index : this->surface_mesh.faces()){
    CGAL::Vertex_around_face_circulator<Mesh> 
      vcirc(this->surface_mesh.halfedge(face_index), this->surface_mesh);
    bf(face_index.idx(), 0) = *vcirc++;
    bf(face_index.idx(), 1) = *vcirc++;
    bf(face_index.idx(), 2) = *vcirc++;
  }
  return bf;
}

// getBoundaryFacets() function with filename
// --------------------
Matrix AlphaShape3D::getBoundaryFacets(std::string filename) {
  Matrix bf = this->getBoundaryFacets();
  this->writeOff(filename, this->inputPoints, bf);
  return bf;
}

// writeBoundaryFacets() function
// --------------------
void AlphaShape3D::writeBoundaryFacets(std::string filename) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called writeBoundaryFacets()");
#endif

  this->writeOff(filename, this->inputPoints, this->getBoundaryFacets());
}

// checkInShape() function
// --------------------
Matrix AlphaShape3D::checkInShape(Matrix QP) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called checkInShape()");
#endif

  Matrix tf(QP.numRows(), 1);
  for(uint32_t i = 0; i < QP.numRows(); i++){
    tf(i, 0) = this->alphaShape->classify(Point(QP(i, 0), QP(i, 1), QP(i, 2)));
  }
  return tf;
}

// getTriangulation() function
// --------------------
Matrix AlphaShape3D::getTriangulation(void) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called getTriangulation()");
#endif

  return this->triangulationMatrix;
}

// getNearestNeighbor() function
// --------------------
std::pair<Matrix, Matrix> AlphaShape3D::getNearestNeighbor(Matrix QP) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called getNearestNeighbor()");
#endif

  Matrix I(QP.numRows(), 1);
  Matrix D(QP.numRows(), 1);
  
  Mesh surface_mesh_s(this->surface_mesh);  
  PMP::remove_isolated_vertices(surface_mesh_s);
  
  std::vector<Point> points;
  std::vector<uint32_t> vs;
  for(Mesh::Vertex_index i : vertices(surface_mesh_s)){
    if(!surface_mesh_s.is_removed(i)){
      points.push_back(surface_mesh_s.point(i));
      vs.push_back(i);
    }
  }
    
  search_map map(points);
  Tree tree(boost::counting_iterator<std::size_t>(0),
    boost::counting_iterator<std::size_t>(
    vertices(surface_mesh_s).size()), 
    Tree::Splitter(), Traits(map));
  K_neighbor_search::Distance tr_dist(map);
  
  for(uint32_t i = 0; i < QP.numRows(); i++){
    K_neighbor_search search(tree, Point(QP(i, 0), QP(i, 1), QP(i, 2)), 
      1, 0, true, tr_dist);
    I(i, 0) = vs[search.begin()->first];
    D(i, 0) = 
      tr_dist.inverse_of_transformed_distance(search.begin()->second);
  }
  return std::make_pair(I, D);
}

// getSimplifiedShape() function with stop_ratio
// --------------------
std::pair<Matrix, Matrix> 
    AlphaShape3D::getSimplifiedShape(double stop_ratio) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called getSimplifiedShape()");
#endif

  Mesh surface_mesh_s(this->surface_mesh);
  SMS::Edge_count_ratio_stop_predicate<Mesh> stop(stop_ratio);
  uint32_t r = SMS::edge_collapse(surface_mesh_s, stop);
  PMP::remove_isolated_vertices(surface_mesh_s);
  surface_mesh_s.collect_garbage();
  
#ifdef DEBUG_ALPHA_SHAPE_3D
  std::cout << "Number of edges removed is " << r << std::endl
            << "Number of  final edges is " 
            << surface_mesh_s.number_of_edges() << std::endl;
#endif
  
  Matrix Points(surface_mesh_s.number_of_vertices(), 3);
  Matrix bf(surface_mesh_s.number_of_faces(), 3);

  for(Mesh::Vertex_index vertex_index : surface_mesh_s.vertices()){
    Point p = surface_mesh_s.point(vertex_index);
    Points(vertex_index.idx(), 0) = p[0]; 
    Points(vertex_index.idx(), 1) = p[1]; 
    Points(vertex_index.idx(), 2) = p[2];
  }
  
  for(Mesh::Face_index face_index : surface_mesh_s.faces()){
    CGAL::Vertex_around_face_circulator<Mesh> 
      vcirc(surface_mesh_s.halfedge(face_index), this->surface_mesh);
    bf(face_index.idx(), 0) = *vcirc++;
    bf(face_index.idx(), 1) = *vcirc++;
    bf(face_index.idx(), 2) = *vcirc++;
  } 
  return std::make_pair(Points, bf);
}

// getSimplifiedShape() function without parameters
// --------------------
std::pair<Matrix, Matrix> 
    AlphaShape3D::getSimplifiedShape() {
  double stop_ratio = 0.05;
  return this->getSimplifiedShape(stop_ratio);
}

// getSimplifiedShape() function with filename
// --------------------
std::pair<Matrix, Matrix> 
    AlphaShape3D::getSimplifiedShape(std::string filename) {
  double stop_ratio = 0.05;
  std::pair<Matrix, Matrix> ret = this->getSimplifiedShape(stop_ratio);
  this->writeOff(filename, ret.first, ret.second);
  return ret;
}

// getSimplifiedShape() function with stop_ratio and filename
// --------------------
std::pair<Matrix, Matrix> 
    AlphaShape3D::getSimplifiedShape(double stop_ratio, 
    std::string filename) {
  std::pair<Matrix, Matrix> ret = this->getSimplifiedShape(stop_ratio);
  this->writeOff(filename, ret.first, ret.second);
  return ret;
}

// removeUnusedPoints() function
// --------------------
std::pair<Matrix, Matrix> 
    AlphaShape3D::removeUnusedPoints(Matrix Pi, Matrix bfi) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called removeUnusedPoints()");
#endif

  Mesh surface_mesh_s;
  std::vector<CGAL_Polygon> polygons;
  CGAL_Polygon p;
  std::vector<Point> points;
  
#ifdef DEBUG_ALPHA_SHAPE_3D
  std::cout << "Boundary surface reconstruction. " << std::endl;
#endif
  
  uint32_t n = Pi.numRows();
  uint32_t nbf = bfi.numRows();
  
  for(std::size_t i = 0; i < n; i++){
    points.push_back(Point(Pi(i, 0), Pi(i, 1), Pi(i, 2)));
  }
  
  for(std::size_t i = 0; i < nbf; i++){
    p.clear();
    for(uint8_t j = 0; j < 3; j++){
      p.push_back(bfi(i, j));
    }
    polygons.push_back(p);
  }
  
  PMP::orient_polygon_soup(points, polygons);
  PMP::repair_polygon_soup(points, polygons);
  PMP::polygon_soup_to_polygon_mesh(points, 
    polygons, surface_mesh_s);
  surface_mesh_s.collect_garbage();
  
  Matrix Points(surface_mesh_s.number_of_vertices(), 3);
  Matrix bf(surface_mesh_s.number_of_faces(), 3);

  for(Mesh::Vertex_index vertex_index : surface_mesh_s.vertices()){
    Point p = surface_mesh_s.point(vertex_index);
    Points(vertex_index.idx(), 0) = p[0]; 
    Points(vertex_index.idx(), 1) = p[1]; 
    Points(vertex_index.idx(), 2) = p[2];
  }
  
  for(Mesh::Face_index face_index : surface_mesh_s.faces()){
    CGAL::Vertex_around_face_circulator<Mesh> 
      vcirc(surface_mesh_s.halfedge(face_index), this->surface_mesh);
    bf(face_index.idx(), 0) = *vcirc++;
    bf(face_index.idx(), 1) = *vcirc++;
    bf(face_index.idx(), 2) = *vcirc++;
  } 
  return std::make_pair(Points, bf);
}

// writeOff() function
// --------------------
void AlphaShape3D::writeOff(std::string filename, Matrix Points, Matrix bf) {
#ifdef DEBUG_ALPHA_SHAPE_3D
  consoleLog(0, "Called writeOff()");
#endif

  uint32_t n = Points.numRows();
  uint32_t nbf = bf.numRows();
  
  std::stringstream pts;
  std::stringstream ind;

  for(std::size_t i = 0; i < n; i++){
    pts << Points(i, 0) << " " << Points(i, 1) << " " << Points(i, 2) << std::endl;
  }
  
  for(std::size_t i = 0; i < nbf; i++){
    ind << "3 " << (uint64_t)bf(i, 0) << " " << (uint64_t)bf(i, 1) 
      << " " << (uint64_t)bf(i, 2) << std::endl;
  }
    
  std::ofstream of(filename);
  CGAL::set_ascii_mode(of);
  of << "OFF" << std::endl << n << " " << nbf << " 0" << std::endl;
  of << pts.str();
  of << ind.str();
  of.close();
}

Napi::Object InitAll(Napi::Env env, Napi::Object exports) {
  return AlphaShape3D::Init(env, exports);
}

NODE_API_MODULE(NODE_GYP_MODULE_NAME, InitAll)

}  // namespace alpha_shape_3d_ns

\end{lstlisting}

\begin{lstlisting}[style=C++Style, caption={alpha-shape-3d.h}]
// AlphaShape3D - alpha-shape-3d.h
// Author: Milos Petrasinovic <mpetrasinovic@prdc.rs>
// PR-DC, Republic of Serbia
// info@prdc.rs
// --------------------

#ifndef ALPHA_SHAPE_3D_H
#define ALPHA_SHAPE_3D_H

//#define DEBUG_ALPHA_SHAPE_3D
//#define DEBUG_ALPHA_SHAPE_3D_LEVEL 0
//#define PROFILE_ALPHA_SHAPE_3D

#include <napi.h>
#include <chrono>
#include <thread>
#include <Windows.h>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <string>
#include <fstream>
#include <iostream>
#include <filesystem>
#include <cassert>
#include <list>
#include <vector>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>

#include <CGAL/Delaunay_triangulation_3.h>
#include <CGAL/Triangulation_vertex_base_with_info_3.h>
#include <CGAL/Alpha_shape_3.h>
#include <CGAL/Alpha_shape_cell_base_3.h>
#include <CGAL/Alpha_shape_vertex_base_3.h>

#include <CGAL/Surface_mesh.h>
#include <CGAL/Surface_mesh_simplification/edge_collapse.h>
#include <CGAL/Surface_mesh_simplification/Policies/Edge_collapse/Edge_count_ratio_stop_predicate.h>

#include <CGAL/Polygon_mesh_processing/repair_polygon_soup.h>
#include <CGAL/Polygon_mesh_processing/orient_polygon_soup.h>
#include <CGAL/Polygon_mesh_processing/polygon_soup_to_polygon_mesh.h>
#include <CGAL/Polygon_mesh_processing/measure.h>
#include <CGAL/Polygon_mesh_processing/repair.h>

#include <CGAL/Search_traits_3.h>
#include <CGAL/Search_traits_adapter.h>
#include <CGAL/Orthogonal_k_neighbor_search.h>
#include <CGAL/boost/iterator/counting_iterator.hpp>

namespace alpha_shape_3d_ns {

using namespace std;
using namespace std::chrono;

namespace SMS = CGAL::Surface_mesh_simplification;
namespace PMP = CGAL::Polygon_mesh_processing;

typedef CGAL::Exact_predicates_inexact_constructions_kernel Gt;

typedef CGAL::Triangulation_vertex_base_with_info_3<unsigned, Gt> Tvb;
typedef CGAL::Alpha_shape_vertex_base_3<Gt, Tvb> Vb;
typedef CGAL::Alpha_shape_cell_base_3<Gt> Fb;
typedef CGAL::Triangulation_data_structure_3<Vb, Fb> Tds;
typedef CGAL::Delaunay_triangulation_3<Gt, Tds, CGAL::Fast_location> Dt;
typedef Dt::Point Point;

class search_map {
    const std::vector<Point>& points;
  public:
    typedef Point value_type;
    typedef const value_type& reference;
    typedef std::size_t key_type;
    typedef boost::lvalue_property_map_tag category;
    search_map(const std::vector<Point>& pts):points(pts){}
    reference operator[](key_type k) const {return points[k];}
    friend reference get(const search_map& ppmap, key_type i)
    {return ppmap[i];}
};

typedef CGAL::Alpha_shape_3<Dt> As3;
typedef CGAL::Surface_mesh<Point> Mesh;
typedef std::vector<std::size_t> CGAL_Polygon;

typedef CGAL::Search_traits_3<Gt> Trb;
typedef CGAL::Search_traits_adapter<std::size_t, search_map, Trb> Traits;
typedef CGAL::Orthogonal_k_neighbor_search<Traits>  K_neighbor_search;
typedef K_neighbor_search::Tree Tree;

template <typename T>
class CustomMatrix {
  private:
    std::vector<T> data;
    uint32_t rows;
    uint32_t cols;

  public:
    CustomMatrix() : rows(0), cols(0) {}
    CustomMatrix(uint32_t r, uint32_t c) : rows(r), cols(c), data(r * c) {}

    T& operator()(uint32_t i, uint32_t j) {
      return data[i * cols + j];
    }

    const T& operator()(uint32_t i, uint32_t j) const {
      return data[i * cols + j];
    }

    uint32_t numRows() const { return rows; }
    uint32_t numCols() const { return cols; }

    void resize(uint32_t r, uint32_t c) {
      rows = r;
      cols = c;
      data.resize(r * c);
    }
};
typedef CustomMatrix<double> Matrix;

class AlphaShape3D : public Napi::ObjectWrap<AlphaShape3D> {
 public:
  static Napi::Object Init(Napi::Env env, Napi::Object exports);
  AlphaShape3D(const Napi::CallbackInfo& info);
  ~AlphaShape3D();

  Matrix inputPoints;
  std::vector<Point> Points;
  std::vector<std::pair<Point, unsigned>> Vertices;
  double getAlpha(void); 
  void setAlpha(double); 
  double numRegions(void);
  Matrix getAlphaSpectrum(void); 
  double getCriticalAlpha(std::string);
  double getSurfaceArea(void);
  double getVolume(void);
  Matrix getBoundaryFacets(void);
  Matrix getBoundaryFacets(std::string);
  void writeBoundaryFacets(std::string);
  Matrix checkInShape(Matrix);
  Matrix getTriangulation(void);
  std::pair<Matrix, Matrix> getNearestNeighbor(Matrix);
  std::pair<Matrix, Matrix> getSimplifiedShape(double);
  std::pair<Matrix, Matrix> getSimplifiedShape();
  std::pair<Matrix, Matrix> getSimplifiedShape(std::string);
  std::pair<Matrix, Matrix> getSimplifiedShape(double, std::string);
  std::pair<Matrix, Matrix> removeUnusedPoints(Matrix, Matrix);
  void writeOff(std::string, Matrix, Matrix);

  // New JavaScript wrapper methods
  void NewShapeJS(const Napi::CallbackInfo& info);
  Napi::Value GetAlphaJS(const Napi::CallbackInfo& info);
  void SetAlphaJS(const Napi::CallbackInfo& info);
  Napi::Value GetNumRegionsJS(const Napi::CallbackInfo& info);
  Napi::Value GetAlphaSpectrumJS(const Napi::CallbackInfo& info);
  Napi::Value GetCriticalAlphaJS(const Napi::CallbackInfo& info);
  Napi::Value GetSurfaceAreaJS(const Napi::CallbackInfo& info);
  Napi::Value GetVolumeJS(const Napi::CallbackInfo& info);
  Napi::Value GetBoundaryFacetsJS(const Napi::CallbackInfo& info);
  void WriteBoundaryFacetsJS(const Napi::CallbackInfo& info);
  Napi::Value CheckInShapeJS(const Napi::CallbackInfo& info);
  void WriteOffJS(const Napi::CallbackInfo& info);
  Napi::Value GetTriangulationJS(const Napi::CallbackInfo& info);
  Napi::Value GetNearestNeighborJS(const Napi::CallbackInfo& info);
  Napi::Value GetSimplifiedShapeJS(const Napi::CallbackInfo& info);
  Napi::Value RemoveUnusedPointsJS(const Napi::CallbackInfo& info);
    
private:
  As3 *alphaShape;
  Dt *delaunayTriangulation;
  Matrix triangulationMatrix;
  std::size_t numAlphaValues;
  Mesh surface_mesh;
};

}// namespace alpha_shape_3d_ns

#endif // ALPHA_SHAPE_3D_H
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={binding.gyp}]
[
  {
    "target_name": "native_module",
    "sources": [
      "cpp/native-module.cpp"
    ],
    "include_dirs": [
      "<!@(node -p \"require('node-addon-api').include\")",
      "<(module_root_dir)/lib/eigen-3.4.0/"
    ],
    "cflags!": [
      "-fno-exceptions"
    ],
    "cflags_cc!": [
      "-fno-exceptions"
    ],
    "defines": [
      "NAPI_DISABLE_CPP_EXCEPTIONS"
    ],
    "msvs_settings": {
      "VCCLCompilerTool": {
        "AdditionalOptions": [
          "-std:c++17"
        ]
      }
    }
  },
  {
    "target_name": "alpha_shape_3d",
    "sources": [
      "cpp/alpha-shape-3d.cpp"
    ],
    "include_dirs": [
      "<!@(node -p \"require('node-addon-api').include\")",
      "<(module_root_dir)/lib/cgal-6.0.1/include/",
      "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/include",
      "<(module_root_dir)/lib/boost-1.86.0/"
    ],
    "libraries": [
      "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/lib/gmp.lib",
      "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/lib/mpfr.lib"
    ],
    "cflags!": [
      "-fno-exceptions"
    ],
    "cflags_cc!": [
      "-fno-exceptions",
      "-O3",
      "-DNDEBUG"
    ],
    "defines": [
      "NAPI_DISABLE_CPP_EXCEPTIONS"
    ],
    "copies": [
      {
        "destination": "<(module_root_dir)/build/Release",
        "files": [
          "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/bin/gmp-10.dll",
          "<(module_root_dir)/lib/cgal-6.0.1/auxiliary/gmp/bin/mpfr-6.dll"
        ]
      }
    ],
    "msvs_settings": {
      "VCCLCompilerTool": {
        "AdditionalOptions": [
          "-std:c++17",
          "/GR",
          "/EHsc"
        ]
      }
    }
  }
]
\end{lstlisting}

\begin{lstlisting}[style=C++Style, caption={native-module.cpp}]
// JSLAB - native-module.cpp
// Author: Milos Petrasinovic <mpetrasinovic@prdc.rs>
// PR-DC, Republic of Serbia
// info@prdc.rs
// --------------------

#include "native-module.h"

namespace native_module_ns {

#ifdef PROFILE_NATIVE_MODULE
// Function to start the timer and return the start time
time_point<steady_clock> tic() {
    return steady_clock::now();
}

// Function to stop the timer and return the elapsed time
long toc(const time_point<steady_clock>& startTime) {
    return duration_cast<milliseconds>(steady_clock::now() - startTime).count();
}
#endif

// Function to get currebt time
std::string getCurrentTime() {
  // get current time
  auto now = system_clock::now();

  // get number of milliseconds for the current second
  // (remainder after division into seconds)
  auto ms = duration_cast<milliseconds>(now.time_since_epoch()) % 1000;

  // convert to std::time_t in order to convert to std::tm (broken time)
  auto timer = system_clock::to_time_t(now);

  // convert to broken time
  std::tm bt = *std::localtime(&timer);

  std::ostringstream oss;

  oss << std::put_time(&bt, "%H:%M:%S"); // HH:MM:SS
  oss << '.' << std::setfill('0') << std::setw(3) << ms.count();

  return oss.str();
}

// Function to console log data
int consoleLog(uint8_t level, const char* format, ...) {
#ifdef DEBUG_NATIVE_MODULE_LEVEL
  if(level <= DEBUG_NATIVE_MODULE_LEVEL) {
    printf("\033[0;33m[%s NativeModule]\033[0m ", getCurrentTime().c_str());
    va_list vl;
    va_start(vl, format);
    auto ret = vprintf(format, vl);
    va_end(vl);
    printf("\n");
    return ret;
  }
#endif
  return 0;
}

// NativeModule()
// Object constructor
// --------------------
NativeModule::NativeModule(const Napi::CallbackInfo& info)
    : Napi::ObjectWrap<NativeModule>(info) {
#ifdef DEBUG_NATIVE_MODULE
  consoleLog(0, "Called constructor");
#endif

}

// ~NativeModule()
// Object destructor
// --------------------
NativeModule::~NativeModule() {
}

// Init() function
// --------------------
Napi::Object NativeModule::Init(Napi::Env env, Napi::Object exports) {
  Napi::Function func =
      DefineClass(env,
                  "NativeModule", {
                     InstanceMethod("roots", &NativeModule::roots),
                     InstanceMethod("cumtrapz", &NativeModule::cumtrapz),
                     InstanceMethod("trapz", &NativeModule::trapz),
                     InstanceMethod("listSubprocesses", &NativeModule::listSubprocesses),
                   });
                   
  Napi::FunctionReference* constructor = new Napi::FunctionReference();
  *constructor = Napi::Persistent(func);
  env.SetInstanceData(constructor);

  exports.Set("NativeModule", func);
  return exports;
}

// roots() function
// --------------------
Napi::Value NativeModule::roots(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();
  const double TOLERANCE = 1e-10;
  
  // Ensure the input is an array
  if(!info[0].IsArray()) {
    Napi::TypeError::New(env, "Expected an array of coefficients").ThrowAsJavaScriptException();
    return Napi::Array::New(env);
  }

  // Extract the polynomial coefficients from the input
  Napi::Array coefficientsArray = info[0].As<Napi::Array>();
  int degree = coefficientsArray.Length() - 1;
  
  // Create an Eigen vector for the coefficients
  VectorXd coefficients(degree + 1);
  for(int i = 0; i <= degree; ++i) {
    coefficients(i) = coefficientsArray.Get(i).As<Napi::Number>().DoubleValue();
  }

  // Create the companion matrix
  MatrixXd companionMatrix = MatrixXd::Zero(degree, degree);
  for(int i = 1; i < degree; ++i) {
    companionMatrix(i, i - 1) = 1.0;
  }
  for(int i = 0; i < degree; ++i) {
    companionMatrix(i, degree - 1) = -coefficients(degree - i) / coefficients(0);
  }

  // Use Eigen's eigenvalue solver to find the roots
  EigenSolver<MatrixXd> solver(companionMatrix);
  VectorXcd roots = solver.eigenvalues();

  // Convert the result to a JavaScript array
  Napi::Array result = Napi::Array::New(env, degree);
  for (int i = 0; i < degree; ++i) {
    double realPart = roots(i).real();
    double imagPart = roots(i).imag();

    if(abs(imagPart) < TOLERANCE || isnan(imagPart)) {
      // If the imaginary part is close to zero, return as a real number
      result[i] = Napi::Number::New(env, realPart);
    } else {
      // Otherwise, return as a complex number object
      Napi::Object complexRoot = Napi::Object::New(env);
      complexRoot.Set("real", Napi::Number::New(env, realPart));
      complexRoot.Set("imag", Napi::Number::New(env, imagPart));
      result[i] = complexRoot;
    }
  }

  return result;
}

// cumtrapz() function
// --------------------
Napi::Value NativeModule::cumtrapz(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  // Ensure at least one argument is provided
  if(info.Length() < 1) {
    Napi::TypeError::New(env, "cumtrapz expects at least one argument").ThrowAsJavaScriptException();
    return env.Null();
  }

  // Ensure the first argument is an array
  if(!info[0].IsArray()) {
    Napi::TypeError::New(env, "First argument must be an array").ThrowAsJavaScriptException();
    return env.Null();
  }

  Napi::Array yInput = info[0].As<Napi::Array>();
  Napi::Array xInput;
  bool hasX = info.Length() > 1;

  // If x is provided, ensure it's an array
  if(hasX) {
    if(!info[1].IsArray()) {
      Napi::TypeError::New(env, "Second argument must be an array").ThrowAsJavaScriptException();
      return env.Null();
    }
    xInput = info[1].As<Napi::Array>();
  }

  // Get the length of yInput
  uint32_t n = yInput.Length();

  // If x is provided, its length must match yInput
  if(hasX && xInput.Length() != n) {
    Napi::RangeError::New(env, "x and y arrays must have the same length").ThrowAsJavaScriptException();
    return env.Null();
  }

  // Handle empty array
  if(n == 0) {
    return Napi::Array::New(env, 0);
  }

  // Initialize Eigen vectors
  Eigen::VectorXd y(n);
  Eigen::VectorXd x(n);
  Eigen::VectorXd result(n);

  // Load y values from JavaScript array
  for(uint32_t i = 0; i < n; ++i) {
    Napi::Value val = yInput.Get(i);
    if(!val.IsNumber()) {
      Napi::TypeError::New(env, "y array must contain only numbers").ThrowAsJavaScriptException();
      return env.Null();
    }
    y[i] = val.As<Napi::Number>().DoubleValue();
  }

  // If x is provided, load x values; otherwise, assume uniform spacing
  if(hasX) {
    for(uint32_t i = 0; i < n; ++i) {
      Napi::Value val = xInput.Get(i);
      if (!val.IsNumber()) {
        Napi::TypeError::New(env, "x array must contain only numbers").ThrowAsJavaScriptException();
        return env.Null();
      }
      x[i] = val.As<Napi::Number>().DoubleValue();
    }
  } else {
    // Uniform spacing: x = [0, 1, 2, ..., n-1]
    for(uint32_t i = 0; i < n; ++i) {
      x[i] = static_cast<double>(i);
    }
  }

  // Initialize result: first value is always 0
  result[0] = 0.0;

  // Cumulative trapezoidal integration
  for(uint32_t i = 1; i < n; ++i) {
    double dx = x[i] - x[i - 1];  // Difference in x
    double dy = 0.5 * (y[i] + y[i - 1]);  // Average height (trapezoid rule)
    result[i] = result[i - 1] + dx * dy;
  }

  // Convert Eigen vector back to JavaScript array
  Napi::Array jsResult = Napi::Array::New(env, n);
  for(uint32_t i = 0; i < n; ++i) {
    jsResult.Set(i, Napi::Number::New(env, result[i]));
  }

  return jsResult;
}

// trapz() function
// --------------------
Napi::Value NativeModule::trapz(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  // Ensure at least one argument is provided
  if(info.Length() < 1) {
    Napi::TypeError::New(env, "trapz expects at least one argument").ThrowAsJavaScriptException();
    return env.Null();
  }

  // Ensure the first argument is an array
  if(!info[0].IsArray()) {
    Napi::TypeError::New(env, "First argument must be an array").ThrowAsJavaScriptException();
    return env.Null();
  }

  Napi::Array yInput = info[0].As<Napi::Array>();
  Napi::Array xInput;
  bool hasX = info.Length() > 1;

  // If x is provided, ensure it's an array
  if(hasX) {
    if(!info[1].IsArray()) {
      Napi::TypeError::New(env, "Second argument must be an array").ThrowAsJavaScriptException();
      return env.Null();
    }
    xInput = info[1].As<Napi::Array>();
  }

  // Get the length of yInput
  uint32_t n = yInput.Length();

  // If x is provided, its length must match yInput
  if(hasX && xInput.Length() != n) {
    Napi::RangeError::New(env, "x and y arrays must have the same length").ThrowAsJavaScriptException();
    return env.Null();
  }

  // Handle cases with fewer than 2 points
  if(n < 2) {
    Napi::RangeError::New(env, "trapz requires at least two data points").ThrowAsJavaScriptException();
    return env.Null();
  }

  // Initialize Eigen vectors
  Eigen::VectorXd y(n);
  Eigen::VectorXd x(n);

  // Load y values from JavaScript array
  for(uint32_t i = 0; i < n; ++i) {
    Napi::Value val = yInput.Get(i);
    if(!val.IsNumber()) {
      Napi::TypeError::New(env, "y array must contain only numbers").ThrowAsJavaScriptException();
      return env.Null();
    }
    y[i] = val.As<Napi::Number>().DoubleValue();
  }

  // If x is provided, load x values; otherwise, assume uniform spacing
  if(hasX) {
    for(uint32_t i = 0; i < n; ++i) {
      Napi::Value val = xInput.Get(i);
      if (!val.IsNumber()) {
        Napi::TypeError::New(env, "x array must contain only numbers").ThrowAsJavaScriptException();
        return env.Null();
      }
      x[i] = val.As<Napi::Number>().DoubleValue();
    }
  } else {
    // Uniform spacing: x = [0, 1, 2, ..., n-1]
    for(uint32_t i = 0; i < n; ++i) {
      x[i] = static_cast<double>(i);
    }
  }

  // Perform trapezoidal integration
  double total = 0.0;
  for(uint32_t i = 1; i < n; ++i) {
    double dx = x[i] - x[i - 1];
    double dy = 0.5 * (y[i] + y[i - 1]);
    total += dx * dy;
  }

  return Napi::Number::New(env, total);
}

// listSubprocesses() function
// --------------------
Napi::Value NativeModule::listSubprocesses(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  // Ensure at least one argument is provided
  if(info.Length() < 1) {
    Napi::TypeError::New(env, "listSubprocesses expects at least one argument").ThrowAsJavaScriptException();
    return env.Null();
  }

  // Ensure the first argument is an number
  if(!info[0].IsNumber()) {
    Napi::TypeError::New(env, "First argument must be an number").ThrowAsJavaScriptException();
    return env.Null();
  }
  
  uint32_t parent_pid = info[0].As<Napi::Number>().Uint32Value();
  uint32_t i = 0;
  Napi::Array jsResult = Napi::Array::New(env);

  // Create a snapshot of all processes in the system.
  HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
  if(hSnapshot == INVALID_HANDLE_VALUE) {
    Napi::Error::New(env, "Unable to create process snapshot.").ThrowAsJavaScriptException();
    return jsResult;
  }

  PROCESSENTRY32 pe;
  pe.dwSize = sizeof(PROCESSENTRY32);

  // Retrieve the first process.
  if(Process32First(hSnapshot, &pe)) {
    do {
      if(pe.th32ParentProcessID == parent_pid) {
        jsResult.Set(i, Napi::Number::New(env, pe.th32ProcessID));
        i = i+1;
      }
    } while(Process32Next(hSnapshot, &pe));
  } else {
    Napi::Error::New(env, "Unable to retrieve process information").ThrowAsJavaScriptException();
  }

  CloseHandle(hSnapshot);
  return jsResult;
}

Napi::Object InitAll(Napi::Env env, Napi::Object exports) {
  return NativeModule::Init(env, exports);
}

NODE_API_MODULE(NODE_GYP_MODULE_NAME, InitAll)

}  // namespace native_module_ns

\end{lstlisting}

\begin{lstlisting}[style=C++Style, caption={native-module.h}]
// JSLAB - native-module.h
// Author: Milos Petrasinovic <mpetrasinovic@prdc.rs>
// PR-DC, Republic of Serbia
// info@prdc.rs
// --------------------

#ifndef NATIVE_MODULE_H
#define NATIVE_MODULE_H

//#define DEBUG_NATIVE_MODULE
//#define DEBUG_NATIVE_MODULE_LEVEL 0
//#define PROFILE_NATIVE_MODULE

#include <napi.h>
#include <chrono>
#include <thread>
#include <Windows.h>
#include <tlhelp32.h>
#include <ctime>
#include <iomanip>
#include <sstream>
#include <string>
#include <fstream>
#include <iostream>
#include <filesystem>
#include <vector>
#include <complex>
#include <Eigen/Dense>

namespace native_module_ns {

using namespace std;
using namespace std::chrono;
using namespace Eigen;

class NativeModule : public Napi::ObjectWrap<NativeModule> {
 public:
  static Napi::Object Init(Napi::Env env, Napi::Object exports);
  NativeModule(const Napi::CallbackInfo& info);
  ~NativeModule();
 
  Napi::Value roots(const Napi::CallbackInfo& info);
  Napi::Value cumtrapz(const Napi::CallbackInfo& info);
  Napi::Value trapz(const Napi::CallbackInfo& info);
  Napi::Value listSubprocesses(const Napi::CallbackInfo& info);
};

}// namespace native_module_ns

#endif // NATIVE_MODULE_H
\end{lstlisting}

% ----------------------------------------
\section{css}


\begin{lstlisting}[style=CSSStyle, caption={basic.css}]
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}

html {
  overflow: hidden;
}

:focus {
  outline: 0;
}

div {
  z-index: 2;
  box-sizing: border-box;
}

section {
  position: relative;
  z-index: 2;
}

body  {
  font-family: 'Roboto', Arial;
  width: 100%;
  background: #fff;
}

.clear {
  clear: both;
}

.float-left {
  float: left;
}

.float-right {
  float: right;
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={big-json-viewer-notepadpp-theme.css}]
.json-node-root a {
  font-weight: 400!important;
}

.json-node-type {
  color: #7f7f7f;
}

.json-node-toggler,
.json-node-stub-toggler {
  text-decoration: none;
  color: inherit;
}

.json-node-children,
.json-node-root {
  padding-left: 1em;
}

.json-node-header mark {
  background-color: rgba(199, 193, 0, 0.5);
  padding: 0;
}

.json-node-header mark.highlight-active {
  background-color: rgba(199, 103, 46, 0.5);
}

.json-node-label {
  color: #111;
}

.json-node-number .json-node-value {
  color: #ff8000;
}

.json-node-string .json-node-value {
  color: #808080;
}

.json-node-boolean .json-node-value {
  color: #0000ff;
}

.json-node-null .json-node-value {
  color: #ff8000;
}

.json-node-number .json-node-type,
.json-node-string .json-node-type,
.json-node-boolean .json-node-type,
.json-node-undefined .json-node-type,
.json-node-null .json-node-type {
  display: none;
}

.json-node-accessor {
  position: relative;
}

.json-node-accessor::before {
  position: absolute;
  content: '▶';
  font-size: 0.7em;
  line-height: 1.6em;
  right: 0.5em;
  top: 0.1em;
  transition: transform 100ms ease-out;
  color: #333;
  opacity: 0.7;
}

.json-node-open .json-node-accessor::before {
  transform: rotate(90deg);
}

.json-node-stub-toggler .json-node-label,
.json-node-collapse {
  color: #7f7f7f;
}
.json-node-collapse {
  font-size: 0.8em;
}

@keyframes json-node-children-open {
  from {
    transform: scaleY(0);
  }
  to {
    transform: scaleY(1);
  }
}

.json-node-link {
  display: none;
  padding-left: 0.5em;
  font-size: 0.8em;
  color: #7f7f7f;
  text-decoration: none;
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={codemirror-custom.css}]
#code {
  height: calc(100vh - 74px);
}

.CodeMirror {
  height: calc(100% - 6px);
  margin: 5px;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  font-size: 16px;
  margin-top: 1px;
}

.CodeMirror div {
  z-index: auto;
}

.CodeMirror-gutter-wrapper, .CodeMirror-cursor {
  z-index: 4!important;
}

.CodeMirror-vscrollbar::-webkit-scrollbar,
.CodeMirror-vscrollbar::-webkit-scrollbar-button,
.CodeMirror-vscrollbar::-webkit-scrollbar-track,
.CodeMirror-vscrollbar::-webkit-scrollbar-track-piece,
.CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
.CodeMirror-vscrollbar::-webkit-scrollbar-corner,
.CodeMirror-vscrollbar::-webkit-resizer {
  background: transparent;
}

.CodeMirror-vscrollbar {

}

.CodeMirror-vscrollbar::-webkit-scrollbar {
  width:  12px;
  height: 12px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-vscrollbar::-webkit-scrollbar-track-piece {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-vscrollbar::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 5px;
  background-clip: content-box;
  border: 2px solid transparent;
}

.CodeMirror-vscrollbar::-webkit-scrollbar-button {
  width:0;
  height:0;
}

.CodeMirror-ruler {
  z-index: 1!important;
}

.CodeMirror-foldmarker {
  color: #000;
  text-shadow: none;
}

.CodeMirror-lint-tooltip {
  background-color: #fff;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  color: #666;
  font-family: Roboto;
  line-height: 16px;
}

.CodeMirror-lint-tooltip {
  background-color: #fff;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  color: #666;
  font-family: Roboto;
  line-height: 16px;
}

.CodeMirror-hint {
  line-height: 16px;
}

.CodeMirror-focused .cm-matchhighlight {
  background-color: #0f0;
}

.CodeMirror-search-match {
  background: gold;
  border-top: 1px solid orange;
  border-bottom: 1px solid orange;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  opacity: .5;
}

.CodeMirror-selection-highlight-scrollbar {
  background-color: #0f0;
  width: 13px!important;
  z-index: 100!important;
}

\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={codemirror-editor-custom.css}]
#code {
  height: calc(100vh - 74px);
}

.CodeMirror {
  height: calc(100% - 6px);
  margin: 5px;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  font-size: 16px;
  margin-top: 1px;
}

.CodeMirror div {
  z-index: auto;
}

.CodeMirror-gutter-wrapper, .CodeMirror-cursor {
  z-index: 4!important;
}

.CodeMirror-vscrollbar::-webkit-scrollbar,
.CodeMirror-vscrollbar::-webkit-scrollbar-button,
.CodeMirror-vscrollbar::-webkit-scrollbar-track,
.CodeMirror-vscrollbar::-webkit-scrollbar-track-piece,
.CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
.CodeMirror-vscrollbar::-webkit-scrollbar-corner,
.CodeMirror-vscrollbar::-webkit-resizer {
  background: transparent;
}

.CodeMirror-vscrollbar {
  z-index: 3!important;
}

.CodeMirror-vscrollbar::-webkit-scrollbar {
  width:  12px;
  height: 12px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-vscrollbar::-webkit-scrollbar-track-piece {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-vscrollbar::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 5px;
  background-clip: content-box;
  border: 2px solid transparent;
}

.CodeMirror-vscrollbar::-webkit-scrollbar-button {
  width:0;
  height:0;
}

.CodeMirror-ruler {
  z-index: 1!important;
}

.CodeMirror-foldmarker {
  color: #000;
  text-shadow: none;
}

.CodeMirror-lint-tooltip {
  background-color: #fff;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  color: #666;
  font-family: Roboto;
  line-height: 16px;
}

.CodeMirror-lint-tooltip {
  background-color: #fff;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  color: #666;
  font-family: Roboto;
  line-height: 16px;
}

.CodeMirror-hint {
  line-height: 16px;
}

.CodeMirror-focused .cm-matchhighlight {
  background-color: #0f0;
}

.CodeMirror-search-match {
  background: gold;
  border-top: 1px solid orange;
  border-bottom: 1px solid orange;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  opacity: .5;
}

.CodeMirror-selection-highlight-scrollbar {
  background-color: #0f0;
  width: 13px!important;
  z-index: 100!important;
}

.CodeMirror-selected, .CodeMirror-focused .CodeMirror-selected {
  background-color: #c0c0c0!important;
}

.CodeMirror-hints::-webkit-scrollbar,
.CodeMirror-hints::-webkit-scrollbar-button,
.CodeMirror-hints::-webkit-scrollbar-track,
.CodeMirror-hints::-webkit-scrollbar-track-piece,
.CodeMirror-hints::-webkit-scrollbar-thumb,
.CodeMirror-hints::-webkit-scrollbar-corner,
.CodeMirror-hints::-webkit-resizer {
  background: transparent;
}

.CodeMirror-hints::-webkit-scrollbar {
  width:  12px;
  height: 12px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-hints::-webkit-scrollbar-track-piece {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-hints::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 5px;
  background-clip: content-box;
  border: 2px solid transparent;
}

.CodeMirror-hints::-webkit-scrollbar-button {
  width:0;
  height:0;
}

.CodeMirror-search-dialog {
  font-family: Roboto;
  font-size: 16px;
  display: none;
  position: absolute;
  top: 0;
  right: 15px;
  background-color: rgba(255, 255, 255, 0.9);
  padding: 10px;
  border-radius: 0 0 5px 5px;
  box-shadow: 0 0 10px #00000026;
  z-index: 3!important;
}

.CodeMirror-search-find, .CodeMirror-search-replace {
  margin: 0;
  border: 1px solid #ddd;
  padding: 3px 5px;
  display: block;
  font-size: 16px;
  border-radius: 3px;
  margin-right: 10px;
  float: left;
  margin-bottom: 10px;
  font-weight: 100;
}

.CodeMirror-search-find::placeholder, .CodeMirror-search-replace::placeholder {
  font-weight: 100;
  color: #999;
}

.CodeMirror-search-find:focus, .CodeMirror-search-replace:focus {
  border: 1px solid #f7df1e;
}

.CodeMirror-search-find-prev-btn, .CodeMirror-search-find-next-btn,
.CodeMirror-search-replace-btn, .CodeMirror-search-replace-all-btn {
  cursor: pointer;
  background-size: 20px;
  height: 20px;
  width: 20px;
  opacity: 0.5;
  display: block;
  float: left;
  margin-top: 3px;
}

.CodeMirror-search-find-prev-btn:hover, .CodeMirror-search-find-next-btn:hover,
.CodeMirror-search-replace-btn:hover, .CodeMirror-search-replace-all-btn:hover {
  opacity: 1;
}

.CodeMirror-search-find-prev-btn {
  background-image: url(../img/arrow.svg);
  transform: rotate(90deg);
  margin-right: 10px;
}

.CodeMirror-search-find-next-btn {
  background-image: url(../img/arrow.svg);
  transform: rotate(-90deg);
}

.CodeMirror-search-replace-btn {
  background-image: url(../img/replace.svg);
  margin-right: 10px;
}

.CodeMirror-search-replace-all-btn {
  background-image: url(../img/replace-all.svg);
}

.CodeMirror-search-case-btn, .CodeMirror-search-regex-btn {
  cursor: pointer;
  background-size: 20px;
  height: 20px;
  width: 20px;
  opacity: 0.5;
  display: block;
  float: left;
}

.CodeMirror-search-case-btn:hover, .CodeMirror-search-regex-btn:hover {
  opacity: 0.7;
}

.CodeMirror-search-case-btn.active, .CodeMirror-search-regex-btn.active {
  opacity: 1;
}

.CodeMirror-search-case-btn {
  margin-left: 5px;
  margin-right: 10px;
  background-image: url(../img/match-case.svg);
}

.CodeMirror-search-regex-btn {
  background-image: url(../img/regex.svg);
}

.CodeMirror-search-bottom-right {
  float: right;
  margin-top: 5px;
  font-weight: 100;
  color: #999;
}

.CodeMirror-search-close-btn {
  cursor: pointer;
  background-size: 15px;
  height: 15px;
  width: 15px;
  opacity: 0.4;
  display: block;
  float: right;
  background-image: url(../img/close.svg);
  margin-left: 10px;
}

.CodeMirror-search-close-btn:hover {
  opacity: 1;
}

\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={codemirror-main-custom.css}]
.CodeMirror {
  height: auto;
  font-size: 16px;
  font-family: 'Roboto', Arial;
}

.CodeMirror div {
  z-index: auto;
}

.CodeMirror-gutter-wrapper, .CodeMirror-cursor {
  z-index: 4!important;
}

.CodeMirror-lint-tooltip {
  background-color: #fff;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  color: #666;
  font-family: Roboto;
  line-height: 16px;
}

.CodeMirror-lint-tooltip {
  background-color: #fff;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  color: #666;
  font-family: 'Roboto', Arial;
  line-height: 16px;
}

.CodeMirror-hint {
  font-family: 'Roboto', Arial;
  line-height: 16px;
}

.CodeMirror-focused .cm-matchhighlight {
  background-color: #0f0;
}

.CodeMirror-search-match {
  background: gold;
  border-top: 1px solid orange;
  border-bottom: 1px solid orange;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  opacity: .5;
}

.CodeMirror-gutters {
  border-right: none;
  background-color: #fff;
}

.CodeMirror-selected, .CodeMirror-focused .CodeMirror-selected {
  background-color: #c0c0c0!important;
}

.CodeMirror-hints::-webkit-scrollbar,
.CodeMirror-hints::-webkit-scrollbar-button,
.CodeMirror-hints::-webkit-scrollbar-track,
.CodeMirror-hints::-webkit-scrollbar-track-piece,
.CodeMirror-hints::-webkit-scrollbar-thumb,
.CodeMirror-hints::-webkit-scrollbar-corner,
.CodeMirror-hints::-webkit-resizer {
  background: transparent;
}

.CodeMirror-hints::-webkit-scrollbar {
  width:  12px;
  height: 12px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-hints::-webkit-scrollbar-track-piece {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-hints::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 5px;
  background-clip: content-box;
  border: 2px solid transparent;
}

.CodeMirror-hints::-webkit-scrollbar-button {
  width:0;
  height:0;
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={codemirror-notepadpp-theme.css}]
.cm-s-notepadpp span.cm-comment {
  color: #008000;
}
.cm-s-notepadpp span.cm-keyword {
  line-height: 1em;
  font-weight: bold;
  color: #0000ff;
}
.cm-s-notepadpp span.cm-string {
  color: #808080;
}
.cm-s-notepadpp span.cm-string-2 {
  color: #060683;
}

.cm-s-notepadpp span.cm-builtin {
  line-height: 1em;
  font-weight: bold;
  color: #804000;
}
.cm-s-notepadpp span.cm-special {
  line-height: 1em;
  font-weight: bold;
  color: #0aa;
}
.cm-s-notepadpp span.cm-variable {
  color: black;
}
.cm-s-notepadpp span.cm-number {
  color: #ff8000;
}

.cm-s-notepadpp span.cm-atom {
  color: #0000ff;
}
.cm-s-notepadpp span.cm-meta {
  color: #814203;
}

.cm-s-notepadpp span.cm-type {
  color: #8206ff;
}

.cm-s-notepadpp span.cm-link {
  color: #3a3;
}

.cm-s-notepadpp .CodeMirror-activeline-background {
  background: #e8e8ff;
}
.cm-s-notepadpp .CodeMirror-matchingbracket {
  outline: 1px solid grey;
  color: black !important;
}

.cm-s-notepadpp span.cm-tag, .cm-s-notepadpp span.cm-def {
  color: #0000ff;
}

.cm-s-notepadpp span.cm-attribute, .cm-s-notepadpp span.cm-qualifier {
  color: #ff2324ff;
}


\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={codemirror-presentation-editor-custom.css}]
#code {
  height: calc(100vh - 83px);
}

.CodeMirror {
  height: calc(100% - 6px);
  margin: 5px;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  font-size: 16px;
  margin-top: 1px;
}

.CodeMirror div {
  z-index: auto;
}

.CodeMirror-gutter-wrapper, .CodeMirror-cursor {
  z-index: 4!important;
}

.CodeMirror-vscrollbar::-webkit-scrollbar,
.CodeMirror-vscrollbar::-webkit-scrollbar-button,
.CodeMirror-vscrollbar::-webkit-scrollbar-track,
.CodeMirror-vscrollbar::-webkit-scrollbar-track-piece,
.CodeMirror-vscrollbar::-webkit-scrollbar-thumb,
.CodeMirror-vscrollbar::-webkit-scrollbar-corner,
.CodeMirror-vscrollbar::-webkit-resizer {
  background: transparent;
}

.CodeMirror-vscrollbar {
  z-index: 3!important;
}

.CodeMirror-vscrollbar::-webkit-scrollbar {
  width:  12px;
  height: 12px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-vscrollbar::-webkit-scrollbar-track-piece {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-vscrollbar::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 5px;
  background-clip: content-box;
  border: 2px solid transparent;
}

.CodeMirror-vscrollbar::-webkit-scrollbar-button {
  width:0;
  height:0;
}

.CodeMirror-ruler {
  z-index: 1!important;
}

.CodeMirror-foldmarker {
  color: #000;
  text-shadow: none;
}

.CodeMirror-lint-tooltip {
  background-color: #fff;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  color: #666;
  font-family: Roboto;
  line-height: 16px;
}

.CodeMirror-lint-tooltip {
  background-color: #fff;
  border: 1px solid #f7df1e;
  border-radius: 3px;
  color: #666;
  font-family: Roboto;
  line-height: 16px;
}

.CodeMirror-hint {
  line-height: 16px;
}

.CodeMirror-focused .cm-matchhighlight {
  background-color: #0f0;
}

.CodeMirror-search-match {
  background: gold;
  border-top: 1px solid orange;
  border-bottom: 1px solid orange;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
  opacity: .5;
}

.CodeMirror-selection-highlight-scrollbar {
  background-color: #0f0;
  width: 13px!important;
  z-index: 100!important;
}

.CodeMirror-selected, .CodeMirror-focused .CodeMirror-selected {
  background-color: #c0c0c0!important;
}

.CodeMirror-hints::-webkit-scrollbar,
.CodeMirror-hints::-webkit-scrollbar-button,
.CodeMirror-hints::-webkit-scrollbar-track,
.CodeMirror-hints::-webkit-scrollbar-track-piece,
.CodeMirror-hints::-webkit-scrollbar-thumb,
.CodeMirror-hints::-webkit-scrollbar-corner,
.CodeMirror-hints::-webkit-resizer {
  background: transparent;
}

.CodeMirror-hints::-webkit-scrollbar {
  width:  12px;
  height: 12px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-hints::-webkit-scrollbar-track-piece {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.CodeMirror-hints::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 5px;
  background-clip: content-box;
  border: 2px solid transparent;
}

.CodeMirror-hints::-webkit-scrollbar-button {
  width:0;
  height:0;
}

.CodeMirror-search-dialog {
  font-family: Roboto;
  font-size: 16px;
  display: none;
  position: absolute;
  top: 0;
  right: 15px;
  background-color: rgba(255, 255, 255, 0.9);
  padding: 10px;
  border-radius: 0 0 5px 5px;
  box-shadow: 0 0 10px #00000026;
  z-index: 3!important;
}

.CodeMirror-search-find, .CodeMirror-search-replace {
  margin: 0;
  border: 1px solid #ddd;
  padding: 3px 5px;
  display: block;
  font-size: 16px;
  border-radius: 3px;
  margin-right: 10px;
  float: left;
  margin-bottom: 10px;
  font-weight: 100;
}

.CodeMirror-search-find::placeholder, .CodeMirror-search-replace::placeholder {
  font-weight: 100;
  color: #999;
}

.CodeMirror-search-find:focus, .CodeMirror-search-replace:focus {
  border: 1px solid #f7df1e;
}

.CodeMirror-search-find-prev-btn, .CodeMirror-search-find-next-btn,
.CodeMirror-search-replace-btn, .CodeMirror-search-replace-all-btn {
  cursor: pointer;
  background-size: 20px;
  height: 20px;
  width: 20px;
  opacity: 0.5;
  display: block;
  float: left;
  margin-top: 3px;
}

.CodeMirror-search-find-prev-btn:hover, .CodeMirror-search-find-next-btn:hover,
.CodeMirror-search-replace-btn:hover, .CodeMirror-search-replace-all-btn:hover {
  opacity: 1;
}

.CodeMirror-search-find-prev-btn {
  background-image: url(../img/arrow.svg);
  transform: rotate(90deg);
  margin-right: 10px;
}

.CodeMirror-search-find-next-btn {
  background-image: url(../img/arrow.svg);
  transform: rotate(-90deg);
}

.CodeMirror-search-replace-btn {
  background-image: url(../img/replace.svg);
  margin-right: 10px;
}

.CodeMirror-search-replace-all-btn {
  background-image: url(../img/replace-all.svg);
}

.CodeMirror-search-case-btn, .CodeMirror-search-regex-btn {
  cursor: pointer;
  background-size: 20px;
  height: 20px;
  width: 20px;
  opacity: 0.5;
  display: block;
  float: left;
}

.CodeMirror-search-case-btn:hover, .CodeMirror-search-regex-btn:hover {
  opacity: 0.7;
}

.CodeMirror-search-case-btn.active, .CodeMirror-search-regex-btn.active {
  opacity: 1;
}

.CodeMirror-search-case-btn {
  margin-left: 5px;
  margin-right: 10px;
  background-image: url(../img/match-case.svg);
}

.CodeMirror-search-regex-btn {
  background-image: url(../img/regex.svg);
}

.CodeMirror-search-bottom-right {
  float: right;
  margin-top: 5px;
  font-weight: 100;
  color: #999;
}

.CodeMirror-search-close-btn {
  cursor: pointer;
  background-size: 15px;
  height: 15px;
  width: 15px;
  opacity: 0.4;
  display: block;
  float: right;
  background-image: url(../img/close.svg);
  margin-left: 10px;
}

.CodeMirror-search-close-btn:hover {
  opacity: 1;
}

\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={editor.css}]
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}

html {
  overflow: hidden;
}

:focus {
  outline: 0;
}

div {
  z-index: 2;
  box-sizing: border-box;
}

section {
  position: relative;
  z-index: 2;
}

body  {
  font-family: 'Roboto', Arial;
  width: 100%;
  background: #fff;
}

lang {
  display: none;
}

.clear {
  clear: both;
}

.float-left {
  float: left;
}

.float-right {
  float: right;
}

#app-logo {
  height: 18px;
  padding-top: 6px;
  padding-left: 10px;
  padding-right: 10px;
  float: left;
}

#app-title {
  float: right;
  font-size: 16px;
  padding-top: 8px;
  font-weight: 100;
  border-right: 1px solid #ffffff2b;
  padding-right: 10px;
  height: 30px;
}

#window-controls {
  -webkit-app-region: no-drag;
  float: right;
  padding-left: 6px
}

#window-controls li {
  float: left;
  padding: 1px 10px;
  display: inline-block;
  font-size: 18px;
  font-weight: 100;
  line-height: 24px;
  -webkit-transition: all .2s linear;
  transition: all .2s linear;
  cursor: pointer;
  -webkit-app-region: no-drag;
}

#window-controls li img {
  width: 16px;
  height: 16px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;  
}

#window-controls li:hover,
#window-controls li:active {
  background: #ffffff99;
}

#window-controls #win-close:hover,
#window-controls #win-close:active {
  background: #cf000f;
}

#window-controls img {
  width: 100%;
  height: 100%;
  filter: invert(1);
}

.tabs {
  font-family: 'Roboto', Arial;
  border-radius: 0;
  padding-right: 65px;
  background: #eee;
  font-size: 16px;
  padding-top: 5px;
  height: 43px;
}

.tab-content, .tab-close {
  cursor: pointer!important;
}

.tab-saved {
  flex-grow: 0;
  flex-shrink: 0;
  position: relative;
  width: 5px;
  height: 5px;
  border-radius: 50%;
  background: transparent;
  top: 5px;
  right: 5px;
}

.changed .tab-saved {
  background: #2e85c7;
}

#new-tab {
  position: absolute;
  top: 5px;
  right: 35px;
  height: 30px;
  background: transparent;
  padding: 5px;
  border-radius: 15px;
  transition: all .2s linear;
  cursor: pointer;
}

#new-tab:hover {
  background: #ccc;
}

#editor-more-icon {
  position: absolute;
  top: 5px;
  right: 5px;
  height: 30px;
  background: transparent;
  padding: 5px;
  border-radius: 15px;
  transition: all .2s linear;
  cursor: pointer;
  opacity: 0.7;
}

#editor-more-icon:hover {
  background: #ccc;
}

#editor-menu-container {
  background: #12568a;
  background: linear-gradient(to left, #2e85c7, #12568a);
  color: #fff;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  -webkit-app-region: drag;
  border-top: 2px solid #f7df1e;
}

#editor-menu li {
  float: left;
  padding: 5px 10px;
  display: inline-block;
  font-size: 16px;
  font-weight: 100;
  line-height: 20px;
  -webkit-transition: all .2s linear;
  transition: all .2s linear;
  cursor: pointer;
  -webkit-app-region: no-drag;
}

#editor-menu li:hover {
  background: #ffffff40;
}

#editor-menu li img {
  float: left;
  width: 20px;
  height: 20px;
  margin-right: 5px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

#close-dialog-cont {
  position: absolute;
  top: 75px;
  left: 6px;
  right: 6px;
  bottom: 7px;
  background-color: rgba(255, 255, 255, 0.5);
}

#close-dialog {
  margin: 0 auto;
  width: 400px;
  position: relative;
  background: #fff;
  box-shadow: 0 0 10px #00000026;
  border-radius: 10px;
  padding: 20px;
  padding-bottom: 20px;
  color: #333;
  margin-bottom: 20px;
  margin-top: 20px;
  line-height: 22px;
}

#close-dialog-header {
  position: relative;
  border-bottom: 1px solid #666;
  margin-bottom: 25px;
  padding-bottom: 10px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

#close-dialog-header span {
  color: #666;
  display: block;
  font-weight: bold;
  font-size: 24px;
  border-radius: 3px;
}

#close-file {
  font-weight: bold;
}

#close-dialog-buttons {
  float: right;
  padding-top: 10px;
}

#close-dialog-buttons button {
  color: #fff;
  background: #2e85c7;
  cursor: pointer;
  border: 2px solid #2e85c7;
  transition: background 0.2s linear, color 0.2s linear;
  -webkit-transition: background 0.2s linear, color 0.2s linear;
  border-radius: 3px;
  padding: 2px 5px;
  font-size: 16px;
  margin: 3px 1px;
  font-weight: normal;
  text-decoration: none;
}

#close-dialog-buttons button:hover {
  background: transparent;
  color: #2e85c7;
}

#editor-more-popup {
  position: absolute;
  display: block;
  border-radius: 5px;
  width: 245px;
  top: 81px;
  right: 10px;
  background: #ffffff;
  border: 1px solid #f7df1e;
  border-bottom: 1px solid #f7df1e;
}

#editor-more-popup .popup-triangle {
  position: absolute;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 10px 10px 0 10px;
  border-color: #f7df1e transparent transparent transparent;
  top: -11px;
  right: 5px;
  transform: rotate(180deg);
}

#editor-more-popup li {
  margin: 5px;
  border-radius: 5px;
  border: 1px solid #dddddd;
  color: #999;
  padding: 5px 10px;
  font-weight: 300;
  font-size: 18px;
  cursor: pointer;
  transition: background 0.2s linear;
  -webkit-transition: background 0.2s linear;
}

#editor-more-popup li:hover {
  background: #f3f3f3;
}

#editor-more-popup li img {
  float: left;
  width: 20px;
  height: 20px;
  margin-right: 10px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  margin-top: -1px;
  filter: invert(1);
  opacity: 0.3;
}

.arduino {
  display: none;
}

.file-ino .arduino {
  display: block;
}

.file-ino #run-menu {
  opacity: 0.6;
  pointer-events: none;
}

@media only screen and (max-width: 830px) {
  #editor-menu li img {
    display: none;
  }
}

@media only screen and (max-width: 670px) {
  #editor-menu li {
    padding: 5px;
  }
  
  #editor-menu li img {
    display: block;
    margin-right: 0px;
  }
  
  #editor-menu li str {
    display: none;
  }
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={figure.css}]
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}

html {
  overflow: hidden;
}

:focus {
  outline: 0;
}

div {
  z-index: 2;
  box-sizing: border-box;
}

section {
  position: relative;
  z-index: 2;
}

body  {
  font-family: 'Roboto', Arial;
  width: 100%;
  background: #fff;
}

.clear {
  clear: both;
}

.float-left {
  float: left;
}

.float-right {
  float: right;
}

#figure-menu-button {
  position: absolute;
  left: 0;
  right: 0;
  top: -5px;
  z-index: 9999;
  transition: all .2s linear;
  width: 20px;
  height: 20px;
  border-radius: 0 0 50% 50%;
  background-color: #12568a;
  margin: 5px;
  cursor: pointer;
}

#figure-menu-button.active, #figure-menu-button.hovered {
  margin-top: 25px;
}
   
#figure-menu-button img {
  transition: transform .2s linear;
  transform: rotate(180deg);
  width: 60%;
  display: block;
  margin: 0 auto;
  margin-top: 4px;
}

#figure-menu-button.active img, #figure-menu-button.hovered img {
  transform: rotate(0deg);
}
 
#figure-menu-container {
  background: #12568a;
  background: linear-gradient(to left, #2e85c7, #12568a);
  color: #fff;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  max-height: 5px;
  overflow: hidden;
  transition: all .2s linear;
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  z-index: 9998;
}

#figure-menu-container.active, #figure-menu-container.hovered {
  max-height: 30px;
  border-bottom: 2px solid #ccc;
}

#figure-menu ul {
  padding-left: 25px;
}

#figure-menu li {
  float: left;
  padding: 5px;
  display: inline-block;
  font-size: 16px;
  font-weight: 100;
  line-height: 20px;
  -webkit-transition: all .2s linear;
  transition: all .2s linear;
  cursor: pointer;
}

#figure-menu li:hover {
  background: #ffffff40;
}

#figure-menu li img {
  float: left;
  width: 20px;
  height: 20px;
  margin-right: 7px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

.plot-cont {
  position: absolute;
  top: 5px;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 1;
}

.modebar-container, .plotly-notifier {
  display: none;
}

#figure-menu li.specific-2d, #figure-menu li.specific-3d {
  display: none;
}

#figure-menu.figure-2d li.specific-2d {
  display: initial;
}

#figure-menu.figure-3d li.specific-3d {
  display: initial;
}

@media only screen and (max-width: 720px) {
  #figure-menu li img {
    display: none;
  }
}

@media only screen and (max-width: 600px) {
  #figure-menu li img {
    display: block;
    padding-bottom: 10px;
  }
  
  #figure-menu li {
    padding: 5px;
    width: 20px; 
    height: 20px;
    overflow: hidden;
  }
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={highlight-notepadpp-theme.css}]
.hljs {
  color: #000;
}

.hljs-built_in,
.hljs-name,
.hljs-selector-tag,
.hljs-tag {
  color: #00f;
}
.hljs-addition,
.hljs-attribute,
.hljs-section,
.hljs-template-tag,
.hljs-template-variable,
.hljs-type {
  color: #a31515;
}

.hljs-literal {
  color: #0000ff;
}

.hljs-deletion,
.hljs-meta,
.hljs-selector-attr,
.hljs-selector-pseudo {
  color: #2b91af;
}
.hljs-doctag {
  color: grey;
}
.hljs-attr {
  color: red;
}
.hljs-bullet,
.hljs-link,
.hljs-symbol {
  color: #00b0e8;
}
.hljs-emphasis {
  font-style: italic;
}
.hljs-strong {
  font-weight: 700;
}

.hljs-keyword {
  color: #00f;
  font-weight: bold;
}

.hljs-variable, .hljs-title {
  color: black;
}

.hljs-number {
  color: #ff8000;
}

.hljs-comment {
  color: #008000;
}

.hljs-string,
.hljs-quote {
  color: #808080;
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={main.css}]
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}

html {
  overflow: hidden;
}

b {
  font-weight: bold;
}

i {
  font-style: italic;
}

:focus {
  outline: 0;
}

div {
  z-index: 2;
  box-sizing: border-box;
}

section {
  position: relative;
  z-index: 2;
}

body  {
  font-family: 'Roboto', Arial;
  width: 100%;
  background: #fff;
}

lang {
  display: none;
}

.clear {
  clear: both;
}

.float-left {
  float: left;
}

.float-right {
  float: right;
}

.monospaced {
  font-family: 'RobotoMono';
}

#app-logo {
  height: 24px;
  padding-top: 8px;
  padding-left: 10px;
  float: left;
}

#app-title {
  float: right;
  font-size: 20px;
  padding-top: 9px;
  font-weight: 100;
  border-right: 1px solid #ffffff2b;
  padding-right: 10px;
  height: 40px;
}

#window-controls {
  -webkit-app-region: no-drag;
  float: right;
  padding-left: 6px
}
#window-controls li {
  float: left;
  padding: 4px 10px;
  display: inline-block;
  font-size: 18px;
  font-weight: 100;
  line-height: 24px;
  -webkit-transition: all .2s linear;
  transition: all .2s linear;
  cursor: pointer;
  -webkit-app-region: no-drag;
}

#window-controls li img {
  width: 16px;
  height: 16px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;  
}

#window-controls li:hover,
#window-controls li:active {
  background: #ffffff99;
}

#window-controls #win-close:hover,
#window-controls #win-close:active {
  background: #cf000f;
}

#window-controls img {
  width: 100%;
  height: 100%;
  filter: invert(1);
}

#main-menu-container {
  background: #12568a;
  background: linear-gradient(to left, #2e85c7, #12568a);
  color: #fff;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  -webkit-app-region: drag;
  border-top: 2px solid #f7df1e;
}

#company-logo {
  filter: invert(1);
  height: 30px;
  float: left;
  padding: 5px;
  padding-left: 10px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  margin-left: 10px;
  border-left: 1px solid #00000054;
  border-right: 1px solid #00000054;
  padding-right: 10px;
}

#main-menu {
  padding: 0 10px;
  -webkit-app-region: no-drag;
}

#main-menu li {
  float: left;
  padding: 8px 10px;
  display: inline-block;
  font-size: 18px;
  font-weight: 100;
  line-height: 24px;
  -webkit-transition: all .2s linear;
  transition: all .2s linear;
  cursor: pointer;
  -webkit-app-region: no-drag;
}

#main-menu li:hover {
  background: #ffffff40;
}

#main-menu li img {
  float: left;
  width: 24px;
  height: 24px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  margin-right: 5px;
}

#paths-container li {
  padding-bottom: 5px;
  padding-top: 5px;
  line-height: 22px;
  padding-left: 10px;
  padding-right: 10px;
  margin: 0 10px;
  position: relative;
  white-space: pre-wrap;
  border-bottom: 1px solid #f7df1e;
  min-height: 22px;
  cursor: pointer;
  transition: all linear 0.3s;
}

#paths-container li.inactive {
  color: #cf000f;
}

#paths-container li:after {
  transition: all linear 0.3s;
}

#paths-container li:not(.no-paths):hover:after {
  content: '';
  position: absolute;
  top: 3px;
  left: 0px;
  right: 0px;
  bottom: 3px;
  border: 1px solid #999;
  border-radius: 3px;
  background: #ffffff69;
  z-index: -1;
}

#paths-container li:last-child {
  border-bottom: 1px solid transparent;
}

#paths-container img.remove-path {
  height: 15px;
  width: 15px;
  position: absolute;
  right: 5px;
  top: 8px;
  opacity: 0.3;
  display:none;
  transition: all linear 0.3s;
}

#paths-container li:hover img.remove-path {
  display: block;
}

#paths-container li:hover img.remove-path:hover {
  display: block;
  opacity: 0.6;
}

#paths-container li.no-paths {
  text-align: center;
  font-size: 24px;
}

#folder-navigation-container {
  padding: 5px 10px;
  border-bottom: 1px solid #dadce0;
  color: #5f6368;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

#folder-navigation-container img, #folder-navigation-container i {
  height: 18px;
  width: 18px;
  display: block;
  margin: 0 auto;
  -webkit-user-drag: none;
}

#folder-navigation-container #save-path i {
  background-image: url(../img/star.svg);
  background-size: 18px 18px;
  background-position: center;
  transition: all .2s linear;
}

#folder-navigation-container #save-path.saved i {
  background-image: url(../img/star-filled.svg);
}

#folder-navigation-container i.i-next-folder {
  background-image: url(../img/next.svg);
  background-size: 14px 14px;
  background-position: center;
  width: 18px;
  height: 14px;
  display: inline-block;
  margin-bottom: -2px;
}

#folder-navigation-container .next-folder {
  transform: rotate(180deg);
}

#folder-navigation-container .up-folder {
  transform: rotate(90deg);
}

#folder-navigation-container .previous-folder.disabled,
#folder-navigation-container .next-folder.disabled,
#folder-navigation-container .up-folder.disabled {
  opacity: 0.3;
  pointer-events: none;
}

#folder-navigation-container .address-line-container {
  float: left;
  width: calc(100% - 165px);
  position: relative;
}

#folder-navigation-container .address-line {
  width: calc(100% - 76px);
  height: 20px;
  background: #f1f3f4;
  border-radius: 14px;
  padding: 2px 35px;
  margin-left: 3px;
  border: 2px solid #f1f3f4;
  -webkit-transition: all .2s linear;
  transition: all .2s linear;
  color: #5f6368;
  font-family: 'Roboto', Arial;
  font-size: 14px;
}

#folder-navigation-container .current-address-cont {
  position: absolute;
  left: 40px;
  right: 35px;
  top: 2px;
  background: #f1f3f4;
  padding: 4px 0;
  pointer-events: none;
  white-space: nowrap;                   
  overflow: hidden; 
  bottom: 2px;
}

#folder-navigation-container .current-address-wrap {
  position: relative;
  max-width: 100%;
  display: inline-block;
}

#folder-navigation-container .current-address {
  float: right;
}

#folder-navigation-container .current-address {
  content: '';
  clear: both;
}

#folder-navigation-container .address-line:focus {
  background: #fff;
  border: 2px solid #f7df1e;
}

#folder-navigation-container .address-line:focus ~ .current-address-cont,
#folder-navigation-container .address-line:focus ~ .save-icon {
  display: none;
}

#folder-navigation-container .folder-icon {
  position: absolute;
  left: 14px;
  top: 4px;
  pointer-events: none;
}

#folder-navigation-container span.folder {
  cursor: pointer;
  pointer-events: all;
}

#folder-navigation-container .folder-address {
  font-size: 14px;
}

#folder-navigation-container #save-path {
  position: absolute;
  top: 2.5px;
  padding: 2px;
  right: 5px;
  background: #ffffff00;
  margin: 0px 2px;
  cursor: pointer;
  width: 28px;
  -webkit-transition: all .2s linear;
  transition: all .2s linear;
  display: block;
  height: 22px;
  -webkit-user-drag: none;
}

#folder-navigation-container #save-path:hover {
  background: #fff;
  border-radius: 12px;
}

#folder-navigation-container .button {
  padding: 5px;
  margin: 0px 2px;
  -webkit-transition: all .2s linear;
  transition: all .2s linear;
  cursor: pointer;
}

#folder-navigation-container .button:hover {
  background: #f1f3f4;
  border-radius: 14px;
}

#panels-container {
  position: absolute;
  top: 81px;
  bottom: 25px;
  left: 0px;
  right: 0px;
}

#panels-container .horizontal-resizer {
  width: 100%;
  background-image: url(../img/hdrag.svg);
  background-repeat: no-repeat;
  background-position: center center;
  background-size: auto 6px;
  cursor: n-resize;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  position: absolute;
}

#panels-container .horizontal-resizer:after {
  content: '';
  border-bottom: 1px solid transparent;
  position: absolute;
  top: 4px;
  left: 0px;
  right: 0px;
  pointer-events: none;
}

#panels-container .vertical-resizer {
  height: 100%;
  background-image: url(../img/vdrag.svg);
  background-repeat: no-repeat;
  background-position: center center;
  background-size: 6px auto;
  cursor: w-resize;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  position: absolute;
}

#panels-container .vertical-resizer:after {
  content: '';
  border-right: 1px solid transparent;
  position: absolute;
  top: 0px;
  bottom: 0px;
  left: 4px;
  pointer-events: none;
}

#panels-container .vertical-resizer:hover:after, #panels-container .horizontal-resizer:hover:after  {
  border-right: 1px solid #f7df1e;
}

#panels-container .horizontal-resizer:hover:after  {
  border-bottom: 1px solid #f7df1e;
}

#panels-container .panel-container {
  height: 100%;  
}

#panels-container .cell-padding { 
  padding: 5px;
  height: 100%;
  width: 100%;
  position: relative;
}

#left-panel {
  height: 100%;
  width: 20%;
  position: absolute;
  left: 0;
  top: 0;
}

#right-panel {
  height: 100%;
  width: 80%;
  position: absolute;
  left: 20%;
  top: 0;
}

#left-top-panel, #left-middle-panel, #left-bottom-panel {
  width: 100%;
  height: 33.333%;
}

#panels-container .panel-title {
  margin: 5px 10px;
  margin-bottom: 0px;
  color: #666;
  padding-bottom: 3px;
  border-bottom: 1px solid #f7df1e;
  font-weight: 300;
  font-size: 14px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#left-middle-panel .panel-title, #left-bottom-panel .panel-title {
  padding-right: 20px;
}

#right-panel .panel-title {
  padding-right: 155px;
}

#panels-container .panel-container {
  border: 1px solid #f1f3f4;
  -webkit-transition: border .2s linear;
  transition: border .2s linear;
  position: relative;
  border-radius: 3px;
}

#panels-container .panel-container:hover {
  border: 1px solid #f7df1e;
}

#panels-container .panel {
  overflow: auto;
  position: absolute;
  top: 23px;
  left: 0px;
  right: 0px;
  bottom: 0px;
}

#help-container, #info-container, #settings-container, #paths-container, #script-path-container {
  display: none;
  top: 79px;
  left: 0;
  right: 0;
  bottom: 25px;
  position: absolute;
  -webkit-backdrop-filter: blur(5px);
  backdrop-filter: blur(5px);
  background-color: rgba(255, 255, 255, 0.7);
}

#info-container .app-logo {
  width: 150px;
  text-align: center;
  margin: 0 auto;
  display: block;
}

#info-container .app-name {
  font-size: 34px;
  color: #000;
  text-align: center;
  padding-top: 10px;
  line-height: 46px;
}

#info-container .app-version {
  font-size: 16px;
  text-align: center;
  font-weight: 100;
  line-height: 18px;
}

#info-container .app-company {
  font-size: 24px;
  text-align: center;
  font-weight: 100;
  line-height: 30px;
}

#info-container .company-logo {
  width: 100px;
  margin: 0 auto;
  display: block;
  padding: 10px;
}

#info-container p {
  line-height: 22px;
  text-align: center;
  font-weight: 100;
}

#info-container ul {
  padding-top: 20px;
  padding-left: 40px;
  list-style: inside square;
}

#info-container li { 
  padding: 10px 0;
}

#info-container li a { 
  text-decoration: none;
  color: #444;
  font-size: 22px;
}

#info-container li a:hover { 
  opacity: 0.4;
}

#file-browser-cont {
  margin: 0 10px;
  margin-left: 0px;
}

#file-browser-cont ul {
  margin-left: 15px;
}

#file-browser li {
  position: relative;
  background-repeat: no-repeat;
  background-position: 18px 5px;
  background-size: 18px 18px;
}

#file-browser li span {
  font-size: 14px;
  padding-bottom: 5px;
  padding-top: 5px;
  line-height: 18px;
  padding-left: 40px;
  padding-right: 0px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;  
  min-height: 18px;
  cursor: pointer;
  color: #666;
  position: relative;
  display: block;
}

#file-browser li.folder {
  background-image: url(../img/browser-folder.svg);
}

#file-browser li.link {
  background-image: url(../img/browser-link.svg);
}

#file-browser li.file {
  background-image: url(../img/browser-file.svg);
}

#file-browser li.file.js {
  background-image: url(../img/browser-file-js.svg);
}

#file-browser li.file.jsl {
  background-image: url(../img/browser-file-jsl.svg);
}

#file-browser li.file.json {
  background-image: url(../img/browser-file-json.svg);
}

#file-browser li i.expend {
  cursor: pointer;
  background: url(../img/expand.svg);
  background-size: 12px;
  height: 12px;
  width: 12px;
  display: block;
  position: absolute;
  left: 0px;
  top: 7px;
  transition: all .2s linear;
  filter: grayscale(1);
}

#file-browser li i.expend.expended {
  transform: rotate(90deg);
  filter: none;
}

#command-history > div {
  font-size: 14px;
  padding-bottom: 5px;
  padding-top: 5px;
  line-height: 18px;
  padding-left: 10px;
  padding-right: 10px;
  margin: 0 10px;
  position: relative;
  white-space: pre-wrap;
  border-bottom: 1px solid #eee;
  min-height: 18px;
  cursor: pointer;
  color: #666;
  word-break: break-word;
}

#workspace {
  overflow-y: scroll!important;
  margin-left: 10px;
}

#workspace .table .col {
  font-size: 14px;
  padding-bottom: 5px;
  padding-top: 5px;
  line-height: 18px;
  padding-left: 10px;
  padding-right: 10px;
  margin: 0 10px;
  position: relative;
  white-space: nowrap; 
  overflow: hidden;
  text-overflow: ellipsis; 
  border-bottom: 1px solid #eee;
  min-height: 18px;
  cursor: pointer;
  color: #666;
  margin: 0;
  float: left;
  border-bottom: none;
  left: 0!important;
}

#workspace-table-head .col {
  font-size: 14px;
  padding-bottom: 5px;
  padding-top: 5px;
  line-height: 18px;
  padding-left: 10px;
  padding-right: 10px;
  min-height: 18px;
  cursor: pointer;
  color: #666;
  float: left;
  border-right: 1px solid #ddd;
  white-space: nowrap; 
  overflow: hidden;
  text-overflow: ellipsis; 
  float: left;
  text-align: center;
  margin-bottom: -1px;
  margin-top: 3px;
}

#workspace .table .row {
  border-bottom: 1px solid #eee;
}

#workspace .row:after, #workspace-table-head .row:after {
  content: '';
  clear: both;
  display: block;
}

#workspace-table-head {
  border-bottom: 1px solid #ddd;
  margin: 0 10px;
  position: absolute;
  top: 23px;
  left: 0;
  right: 0;
  background: #fff;
  z-index: 3;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  margin-right: 12px;
  pointer-events: none;
}

#workspace .table {
  margin-top: 3px;
  text-align: center;
  padding-top: 29px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

#workspace .vertical-resizer {
  cursor: ew-resize;
  position: absolute;
  top: 0px;
  bottom: 3px;
  width: 5px;
  left: calc(50% - 5px);
  pointer-events: auto;
  background: none;
}

#workspace .vertical-resizer:after {
  content: '';
  border-right: 1px solid transparent;
  position: absolute;
  top: 0px;
  bottom: 0px;
  left: 4px;
  pointer-events: none;
}

#workspace .vertical-resizer:hover:after {
  border-right: 1px solid #f7df1e;
}

#workspace .col-1, #workspace-table-head .col-1 {
  width: 50%;
  text-align: left;
}

#workspace .col-2, #workspace .col-3,
#workspace-table-head .col-2, #workspace-table-head .col-3{
  width: 25%;
}

#workspace .table .row {
  display: block;
  position: relative;
}

#command-history > div.comment{
  color: #26a65b;
}

#command-history > div:after, #workspace .table .row:before, 
#file-browser li span:hover:after {
  transition: all linear 0.3s;
}

#command-history > div:last-child, #workspace .row:last-child {
  border-bottom: 1px solid transparent;
}

#workspace-table-head .col-3, #workspace .table .col {
  border-right: 1px solid transparent;
}

#command-history > div:not(.comment):hover:after, 
#workspace .table .row:hover:before,
#file-browser li span:hover:after
{
  content: '';
  position: absolute;
  top: 3px;
  left: 0px;
  right: 0px;
  bottom: 3px;
  border: 1px solid #999;
  border-radius: 3px;
  z-index: -1;
  display: block;
  clear: both;
}

#file-browser li span:hover:after {
  left: 15px;
}

#command-history-options, #workspace-options, #file-browser-options {
  position: absolute;
  top: -1px;
  right: 8px;
}

#command-history-options.options .options-right, 
#workspace-options.options .options-right,
#file-browser-options.options .options-right {
  float: right;
}

#command-history-options.options i.clear,
#workspace-options.options i.clear {
  background: url(../img/clear.svg) no-repeat center;
}

#file-browser-options.options i.refresh {
  background: url(../img/refresh.svg) no-repeat center;
}

#command-history-options.options i,
#workspace-options.options i,
#file-browser-options.options i {
  width: 16px;
  height: 18px;
  display: block;
  background-size: 16px!important;
  float: left;
  clear: none;
  padding: 3px 5px;
  opacity: 0.3;
  user-select: none;
  -webkit-user-drag: none;
}

#command-history-options.options i:hover,
#workspace-options.options i:hover,
#file-browser-options.options i:hover {
  opacity: 1;
  cursor: pointer;
}

#command-history-options.options i.active,
#workspace-options.options i.active,
#file-browser-options.options i.active{
  opacity: 0.8;
}

#script-path-dialog-msg {
  color: #333;
  line-height: 22px;
}

#script-path {
  font-weight: bold;
}

#script-path-dialog-buttons{
  float: right;
  padding-top: 10px;
}

#script-path-dialog-buttons button {
  color: #fff;
  background: #2e85c7;
  cursor: pointer;
  border: 2px solid #2e85c7;
  transition: background 0.2s linear, color 0.2s linear;
  -webkit-transition: background 0.2s linear, color 0.2s linear;
  border-radius: 3px;
  padding: 2px 5px;
  font-size: 16px;
  margin: 3px 1px;
  font-weight: normal;
  text-decoration: none;
  width: auto;
}

#script-path-dialog-buttons button:hover {
  background: transparent;
  color: #2e85c7;
}

.page-cont {
  margin: 0 auto;
  width: 460px;
  position: relative;
  background: #ffffff6b;
  box-shadow: 0 0 10px #00000026;
  border-radius: 10px;
  padding: 20px;
  padding-bottom: 20px;
  color: #777;
  margin-bottom: 20px;
  margin-top: 20px;
  display: flex;
  flex-direction: column;
  max-height: calc(100% - 40px);
}

.page-cont.wide {
  width: 800px;
}

.page-panel {
  overflow-y: auto;
  padding: 10px;
  padding-top: 25px;
}

.page-panel h1 {
  font-size: 24px;
  color: #000;
  font-weight: 100;
}

.page-panel table {
  width: 100%;
  color: #333;
  font-size: 18px;
  text-align: left;
  margin-top: 20px;
}

.page-panel table, .page-panel th, .page-panel td {
  border: 1px solid #ccc;
  border-collapse: collapse;
}

.page-panel th {
  font-weight: bold;
  padding: 10px;
}

.page-panel td {
  padding: 10px;
}

.panel::-webkit-scrollbar,
.panel::-webkit-scrollbar-button,
.panel::-webkit-scrollbar-track,
.panel::-webkit-scrollbar-track-piece,
.panel::-webkit-scrollbar-thumb,
.panel::-webkit-scrollbar-corner,
.panel::-webkit-resizer {
  background: transparent;
}

.panel::-webkit-scrollbar {
  width:  12px;
  height: 12px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.panel::-webkit-scrollbar-track-piece {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.panel::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 5px;
  background-clip: content-box;
  border: 2px solid transparent;
}

.panel::-webkit-scrollbar-button {
  width:0;
  height:0;
}

.options-cont input[type="text"], .options-cont input[type="number"], .options-cont input[type="submit"], .options-cont input[type="password"], .options-cont textarea, .options-cont select, .options-cont button,
.main-dialog input[type="text"], .main-dialog input[type="number"], .main-dialog input[type="submit"], .main-dialog input[type="password"], .main-dialog textarea, .main-dialog select, .main-dialog button {
  font-family: 'Roboto';
  border: 2px solid #ccc;
  color: #333;
  font-size: 18px;
  padding-left: 10px;
  padding-right: 10px;
  padding-top: 8px;
  padding-bottom: 8px;
  width: calc(100% - 24px);
  margin-bottom: 10px;
  transition: all 0.2s linear;
  -webkit-transition: all 0.2s linear;
  font-weight: bold;
  border-radius: 3px;
  -webkit-appearance: none;
  background: #fff;
  font-family: 'Roboto';
  -webkit-box-sizing:content-box;
  box-sizing:content-box;
  cursor: pointer;
  line-height: 22px;
}

.options-cont textarea, .main-dialog textarea {
  resize: vertical;
}

.options-cont input[type="submit"], .main-dialog input[type="submit"] {
  color: #fff;
  background: #2e85c7;
  background-size: 30px 30px;
  border: 0;
  margin-left: 2px;
  margin-bottom: 10px;
  cursor: pointer;
  text-transform: uppercase;
  border: 2px solid  #2e85c7;
}

.options-cont input[type="text"]:focus, .options-cont input[type="number"]:focus, .options-cont textarea:focus, .options-cont select:focus, 
.main-dialog input[type="text"]:focus, .main-dialog input[type="number"]:focus, .main-dialog textarea:focus, .main-dialog select:focus {
  border: 2px solid  #2e85c7;
}

.options-cont input[type="text"]:read-only:focus, .options-cont input[type="number"]:read-only:focus,
.main-dialog input[type="text"]:read-only:focus, .main-dialog input[type="number"]:read-only:focus {
  border: 2px solid  #ccc;
}

.options-cont input[type="text"]:read-only:hover, .options-cont input[type="number"]:read-only:hover,
.main-dialog input[type="text"]:read-only:hover, .main-dialog input[type="number"]:read-only:hover {
  cursor: auto;
}

.options-cont input[type="submit"]:hover, .main-dialog input[type="submit"]:hover {
  color: #2e85c7;
  background: #fff;
}

.options-cont input[type="submit"]:disabled, .main-dialog input[type="submit"]:disabled {
  background-image: linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
    transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
    transparent 75%, transparent);
  background-size: 30px 30px;
  animation: animate-stripes 1s linear infinite;
  -webkit-animation: animate-stripes 1s linear infinite;
}

@keyframes animate-stripes {
    0% {background-position: 0 0;} 100% {background-position: 60px 0;}
}

@-moz-keyframes animate-stripes {
    0% {background-position: 0 0;} 100% {background-position: 60px 0;}
}

@-webkit-keyframes animate-stripes {
    0% {background-position: 0 0;} 100% {background-position: 60px 0;}
}

.options-cont input:disabled, .options-cont textarea:disabled, .options-cont select:disabled,
.main-dialog input:disabled, .main-dialog textarea:disabled, .main-dialogselect:disabled  {
  opacity: 0.5;
  pointer-events: none;
}

.options-cont ::placeholder, .options-cont ::-webkit-input-placeholder,
.main-dialog ::placeholder, .main-dialog ::-webkit-input-placeholder  {
  color: #ccc;
  font-weight: normal;
  text-transform: none;
}

.options-cont label, .main-dialog label {
  color: #12568a;
  margin-bottom: 2px;
  display: block;
  margin-left: 3px;
}

.options-cont label span, .main-dialog label span {
  color: #555;
}

.options-cont label.checkcont, .main-dialog label.checkcont {
  margin: 15px 0;
  font-size: 18px;
  padding-top: 3px;
  padding-bottom: 3px;
}

.options-cont label.checkcont, .main-dialog label.checkcont {
  padding-top: 6px;
  color: #333;
}

.checkcont {
  display: block;
  position: relative;
  padding-left: 35px;
  margin-bottom: 12px;
  cursor: pointer;
  font-size: 22px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

.checkcont input {
  position: absolute;
  opacity: 0;
  cursor: pointer;
  height: 0;
  width: 0;
}

.checkmark {
  position: absolute;
  top: 0;
  left: 0;
  height: 25px;
  width: 25px;
  background-color: #fff;
  border: 2px solid #ccc;
  border-radius: 3px;
}

.checkcont:hover input ~ .checkmark {
  background-color: #ccc;
}

.checkcont input:checked ~ .checkmark {
  background-color: #2e85c7;
}

.checkmark:after {
  content: "";
  position: absolute;
  display: none;
}

.checkcont input:checked ~ .checkmark:after {
  display: block;
}

.checkcont .checkmark:after {
  left: 9px;
  top: 5px;
  width: 5px;
  height: 10px;
  border: solid white;
  border-width: 0 3px 3px 0;
  -webkit-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
}

.float-input {
  display: flex;
  flex-flow: column-reverse;
  position: relative;
  margin-top: 5px;
}

.float-select {
  display: flex;
  flex-flow: column-reverse;
  position: relative;
  margin-top: 5px;
}

.no-float-input {
  position: relative;
  margin-top: 5px;
}

label.float-label {
  pointer-events: none;
  position: absolute;
  top: -13px;
  margin-left: 12px!important;
  padding: 1px 8px;
  border-radius: 3px;
  color: #777!important;
  font-weight: bold;
  background: #eee;
}

.float-select label.float-label {
  color: #777;
  font-weight: bold;
  background: #eee;
}

label.float-label, .float-input input, .float-input textarea {
  transition: all 0.2s;
  touch-action: manipulation;
}
.float-input input:placeholder-shown + label.float-label, .float-input textarea:placeholder-shown + label.float-label {
  cursor: text;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  transform-origin: left bottom;
  transform: translate(0, 1.7rem) scale(1.2);
  background: none;
}

.float-input input::-webkit-input-placeholder, .float-input input::placeholder, .float-input textarea::-webkit-input-placeholder, .float-input textarea::placeholder {
  opacity: 0;
  transition: inherit;
}

.float-input input:focus::-webkit-input-placeholder, .float-input textarea:focus::-webkit-input-placeholder {
  opacity: 1;
}

.float-input input:not(:placeholder-shown) + label.float-label,
.float-input input:focus + label.float-label,
.float-input textarea:not(:placeholder-shown) + label.float-label,
.float-input textarea:focus + label.float-label,
.float-input input:-webkit-autofill + label.float-label
.float-input textarea:-webkit-autofill + label.float-label {
  transform: translate(0, 0) scale(1);
  cursor: pointer;
  background: #eee;
}

.float-input input:not(:placeholder-shown) + label.float-label,
.float-input input:focus + label.float-label,
.float-input textarea:not(:placeholder-shown) + label.float-label,
.float-input textarea:focus + label.float-label,
.float-input input:-webkit-autofill + label.float-label,
.float-input textarea:-webkit-autofill + label.float-label{
  color: #777!important;
  font-weight: bold;
  background: #eee;
}

.options-cont button:not([disabled]):hover {
  color: #2e85c7;
  background: #fff;
}

.options-cont button {
  color: #fff;
  background: #2e85c7;
  background-size: 30px 30px;
  border: 0;
  cursor: pointer;
  text-transform: uppercase;
  border: 2px solid #2e85c7;
  margin-top: 15px;
}

.options-cont button:disabled {
  background-image: linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
    transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
    transparent 75%, transparent);
  background-size: 30px 30px;
}

#status-container {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: #f1f3f4;
  padding: 5px 20px;
  font-size: 14px;
  line-height: 14px;
  color: #5f6368;
}

#status {
  height: 14px;
  overflow: hidden;
  float: left;
}

#status-icons {
  float: right;
}

#status-icons img {
  height: 14px;
  width: 14px;
  display: block;
  float: left;
  -webkit-user-select: none;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  cursor: pointer;
}

#status-icons img:hover {
  opacity: 0.5;
}

#status-icons #help-icon {
  opacity: 0.4;
}

#status-icons #help-icon:hover {
  opacity: 0.2;
}

#sandbox-stats-icon {
  height: 14px;
  overflow: hidden;
  float: left;
  width: 14px;
  background: #999;
  border-radius: 50%;
  margin-right: 10px;
  margin-top: -1px;
  cursor: pointer;
}

#sandbox-stats-icon.ready {
  background: #26a65b;
}

#sandbox-stats-icon.async-busy {
  background: #ffb40c;
}

#sandbox-stats-icon.busy {
  background: #cf000f;
}

#sandbox-stats-icon:active {
  opacity: 0.7;
}

#sandbox-stats-popup {
  position: absolute;
  display: block;
  border-radius: 5px;
  width: 245px;
  bottom: 35px;
  left: 10px;
  background: #ffffff;
  border: 1px solid #f7df1e;
  border-bottom: 1px solid #f7df1e;
}

#sandbox-stats-popup .popup-triangle {
  position: absolute;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 10px 10px 0 10px;
  border-color: #f7df1e transparent transparent transparent;
  margin-left: 6px;
  bottom: -11px;
}

#sandbox-stats-header {
  margin: 5px 10px;
  margin-bottom: 0px;
  color: #666;
  padding-bottom: 3px;
  border-bottom: 1px solid #f7df1e;
  font-weight: 300;
  font-size: 14px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.sandbox-stats-cont {
  position: relative;
  padding: 8px 10px;
  padding-right: 100px;
  color: #666;
}

.sandbox-stats-val {
  position: absolute;
  right: 10px;
  top: 5px;
  width: 45px;
  text-align: center;
  background: #999;
  color: #fff;
  padding: 3px;
  border-radius: 3px;
}

#command-window-messages span.eval-code {
  font-weight: bold;
  text-decoration: underline;
  cursor: pointer;
}

#command-window-messages span.open-editor {
  color: #12568a;
  text-decoration: underline;
  cursor: pointer;
}

@media only screen and (max-width: 900px) {
  .page-cont.wide {
    width: 460px;
  }
  
  #main-menu li img {
    display: none;
  }
}

@media only screen and (max-width: 780px) {
  #main-menu li img {
    display: block;
    margin-right: 0;
  }
  
  #main-menu li str {
    display: none;
  }
}


\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={mermaid-graph.css}]
body {
  height: 100vh;
}

.graph.prdc-svg-viewer {
  height: 100%;
  width: 100%;
}

.graph.prdc-svg-viewer iframe {
  height: 100%;
  width: 100% !important;
  max-width: 100% !important;
}

.graph.prdc-svg-viewer svg {
  height: 100%;
  width: 100%
}

.graph .node rect, 
.graph .node circle, 
.graph .node ellipse, 
.graph .node polygon, 
.graph .node path,
.graph .actor, 
.graph .actor-line {
  fill: #73add938!important;
  stroke: #2e85c7!important;
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={notepadpp-theme.css}]
.cm-s-notepadpp span.cm-comment { color: #008000; }
.cm-s-notepadpp span.cm-keyword { line-height: 1em; font-weight: bold; color: #0000ff; }
.cm-s-notepadpp span.cm-string { color: #808080; }
.cm-s-notepadpp span.cm-builtin { line-height: 1em; font-weight: bold; color: #804000; }
.cm-s-notepadpp span.cm-special { line-height: 1em; font-weight: bold; color: #0aa; }
.cm-s-notepadpp span.cm-variable { color: black; }
.cm-s-notepadpp span.cm-number, .cm-s-notepadpp span.cm-atom { color: #ff8000; }
.cm-s-notepadpp span.cm-meta { color: #555; }
.cm-s-notepadpp span.cm-link { color: #3a3; }

.cm-s-notepadpp .CodeMirror-activeline-background { background: #e8e8ff; }
.cm-s-notepadpp .CodeMirror-matchingbracket { outline:1px solid grey; color:black !important; }

\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={presentation-editor.css}]
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}

html {
  overflow: hidden;
}

:focus {
  outline: 0;
}

div {
  z-index: 2;
  box-sizing: border-box;
}

section {
  position: relative;
  z-index: 2;
}

body  {
  font-family: 'Roboto', Arial;
  background: #fff;
  height: 100vh;
  width: 100vw;
  overflow: hidden;
  border-top: 1px solid #f7df1e;
}

lang {
  display: none;
}

.dragging webview { 
  pointer-events: none; 
}

.clear {
  clear: both;
}

.float-left {
  float: left;
}

.float-right {
  float: right;
}

#left-panel-cont {
  display: flex;
  flex-direction: column;
  padding: 10px;
  justify-content: center;
  align-items: center;
  height: 100%;
  width: 100%;
}

#right {
  border: 1px solid #eee;
  position: relative;
  border-radius: 3px;
  margin: 5px;
  overflow: hidden;
}

#webview-wrap {
  position: relative;
  width: 100%;
  box-shadow: 0 0 10px 0 #0000000d;
  overflow: hidden;
}

#preview {
  position: absolute;
  top: 0;
  left: 0;
  width: 1920px;
  height: 1080px;
  border: 0;
  background: #eee;
  transform-origin: 0 0;
}

.tabs {
  font-family: 'Roboto', Arial;
  border-radius: 0;
  padding-right: 65px;
  background: #eee;
  font-size: 16px;
  padding-top: 5px;
  height: 43px;
  margin-top: 5px;
}

.tab-saved {
  flex-grow: 0;
  flex-shrink: 0;
  position: relative;
  width: 5px;
  height: 5px;
  border-radius: 50%;
  background: transparent;
  top: 5px;
  right: 5px;
}

.changed .tab-saved {
  background: #2e85c7;
}

.tabs .tab .tab-close {
  display: none;
}

#tab-save {
  position: absolute;
  top: 5px;
  right: 35px;
  height: 30px;
  background: transparent;
  padding: 5px;
  border-radius: 15px;
  transition: all .2s linear;
  cursor: pointer;
}

#tab-save:hover {
  background: #ccc;
}

#editor-more-icon {
  position: absolute;
  top: 5px;
  right: 5px;
  height: 30px;
  background: transparent;
  padding: 5px;
  border-radius: 15px;
  transition: all .2s linear;
  cursor: pointer;
  opacity: 0.7;
}

#editor-more-icon:hover {
  background: #ccc;
}

#editor-menu-container {
  background: #12568a;
  background: linear-gradient(to left, #2e85c7, #12568a);
  color: #fff;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  -webkit-app-region: drag;
  border-top: 2px solid #f7df1e;
}

#editor-menu li {
  float: left;
  padding: 5px 10px;
  display: inline-block;
  font-size: 16px;
  font-weight: 100;
  line-height: 20px;
  -webkit-transition: all .2s linear;
  transition: all .2s linear;
  cursor: pointer;
  -webkit-app-region: no-drag;
}

#editor-menu li:hover {
  background: #ffffff40;
}

#editor-menu li img {
  float: left;
  width: 20px;
  height: 20px;
  margin-right: 5px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

#editor-more-popup {
  position: absolute;
  display: block;
  border-radius: 5px;
  width: 245px;
  top: 77px;
  right: 10px;
  background: #ffffff;
  border: 1px solid #f7df1e;
  border-bottom: 1px solid #f7df1e;
}

#editor-more-popup .popup-triangle {
  position: absolute;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 10px 10px 0 10px;
  border-color: #f7df1e transparent transparent transparent;
  top: -11px;
  right: 5px;
  transform: rotate(180deg);
}

#editor-more-popup li {
  margin: 5px;
  border-radius: 5px;
  border: 1px solid #dddddd;
  color: #999;
  padding: 5px 10px;
  font-weight: 300;
  font-size: 18px;
  cursor: pointer;
  transition: background 0.2s linear;
  -webkit-transition: background 0.2s linear;
}

#editor-more-popup li:hover {
  background: #f3f3f3;
}

#editor-more-popup li img {
  float: left;
  width: 20px;
  height: 20px;
  margin-right: 10px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  margin-top: -1px;
  filter: invert(1);
  opacity: 0.3;
}

#presentation-title {
  padding: 5px;
  padding-bottom: 10px;
  font-size: 18px;
  color: #999
}

#slide-controls {
  padding: 5px;
  padding-top: 10px;
  font-size: 18px;
  color: #999;
}

#slide-controls .button {
  display: inline-block;
  cursor: pointer;
}

#slide-controls input {
  border: 1px solid #999;
  border-radius: 5px;
  width: 40px;
  line-height: 20px;
  font-size: 18px;
  color: #999;
  text-align: center;
  -webkit-appearance: none;
  margin: 0;
}

#slide-controls input::-webkit-outer-spin-button,
#slide-controls input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0; 
}

.panel::-webkit-scrollbar,
.panel::-webkit-scrollbar-button,
.panel::-webkit-scrollbar-track,
.panel::-webkit-scrollbar-track-piece,
.panel::-webkit-scrollbar-thumb,
.panel::-webkit-scrollbar-corner,
.panel::-webkit-resizer {
  background: transparent;
}

.panel::-webkit-scrollbar {
  width:  12px;
  height: 12px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.panel::-webkit-scrollbar-track-piece {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.panel::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 5px;
  background-clip: content-box;
  border: 2px solid transparent;
}

.panel::-webkit-scrollbar-button {
  width:0;
  height:0;
}

.horizontal-resizer {
  width: 100%;
  background-image: url(../img/hdrag.svg);
  background-repeat: no-repeat;
  background-position: center center;
  background-size: auto 6px;
  cursor: n-resize;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  position: absolute;
}

.horizontal-resizer:after {
  content: '';
  border-bottom: 1px solid transparent;
  position: absolute;
  top: 4px;
  left: 0px;
  right: 0px;
  pointer-events: none;
}

.vertical-resizer {
  height: 100%;
  background-image: url(../img/vdrag.svg);
  background-repeat: no-repeat;
  background-position: center center;
  background-size: 6px auto;
  cursor: w-resize;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  position: absolute;
}

.vertical-resizer:after {
  content: '';
  border-right: 1px solid transparent;
  position: absolute;
  top: 0px;
  bottom: 0px;
  left: 4px;
  pointer-events: none;
}

.vertical-resizer:hover:after, .horizontal-resizer:hover:after  {
  border-right: 1px solid #f7df1e;
}

.horizontal-resizer:hover:after  {
  border-bottom: 1px solid #f7df1e;
}

.panel-container {
  height: 100%;  
}

.cell-padding { 
  padding: 5px;
  height: 100%;
  width: 100%;
  position: relative;
}

#left-panel {
  height: 100%;
  width: 60%;
  position: absolute;
  left: 0;
  top: 0;
}

#right-panel {
  height: 100%;
  width: 40%;
  position: absolute;
  left: 60%;
  top: 0;
}

.panel-title {
  margin: 5px 10px;
  margin-bottom: 0px;
  color: #666;
  padding-bottom: 3px;
  border-bottom: 1px solid #f7df1e;
  font-weight: 300;
  font-size: 14px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

#right-panel .panel-title {
  padding-right: 155px;
}

.panel-container {
  border: 1px solid #f1f3f4;
  -webkit-transition: border .2s linear;
  transition: border .2s linear;
  position: relative;
  border-radius: 3px;
}

.panel-container:hover {
  border: 1px solid #f7df1e;
}

.panel {
  overflow: auto;
  position: absolute;
  top: 23px;
  left: 0px;
  right: 0px;
  bottom: 0px;
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={presentation.css}]
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figurehtml,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}

html {
  overflow: hidden;
}

:focus {
  outline: 0;
}

div {
  z-index: 2;
  box-sizing: border-box;
}

.clear {
  clear: both;
}

.float-left {
  float: left;
}

.float-right {
  float: right;
}

body  {
  font-family: Arial;
  width: 100vw;
  height: 100vh;
  background: #333;
  font-size: 3vh; 
}

table {
  border-collapse: collapse;
  text-align: center;
  margin: 0 auto;
}

th,
td {
  border: 1px solid #ccc;
  padding: 0.5rem 0.75rem;
}

th {
  background: #f5f5f5;
  font-weight: bold;
  padding: 0.75rem 0.75rem;
}

tbody tr:nth-child(even) {
  background: #fafafa;
}

sup {
  vertical-align: super;
  font-size: smaller;
}

sub {
  vertical-align: sub;
  font-size: smaller;
}

b, strong {
  font-weight: bold;
}

i, em {
  font-style: italic;
}

u {
  text-decoration: underline;
}

b i,
strong em,
b em,
strong i {
  font-weight: bold;
  font-style: italic;
}

.bold      { 
  font-weight: bold; 
}

.italic    { 
  font-style: italic; 
}

.underline { 
  text-decoration: underline; 
}

.one_half {
	width: 48%;
}

.one_third {
	width: 30.66%;
}

.two_third {
  width: 65.33%;
}

.one_half_center {
	width: 48%;
	margin: 0 auto;
	position: relative;
}

.one-fourth {
  width: 22%;
  margin-right: 4%; 
  float: left;
}

.one_five {
	width: 20%;
	float: left;
	position: relative;
}

.one_half, .one_third, .two_third, .one_fourth, .three_fourth {
	float: left;
	margin-right: 4%;
	position: relative;
}

.last {
	margin-right: 0!important;
	clear: right;
}

img.center {
  display: block;
  margin: 0 auto;
}

#slides-cont {
  background: #fff;
  transform-origin: left top;
  position: absolute;
  top: 50%;
  left: 50%;
}

slide {
  display: none;
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #fff;
  position: absolute;
  top: 0; 
  left: 0;
}

slide.active {
  display: block;
}

#slide-controls {
  position: fixed;
  top: 10px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 18px;
  color: #999;
  padding: 5px 10px;
  border-radius: 5px;
  z-index:9999;
  background: rgba(0,0,0,.65);
  box-shadow: 0 0 10px 0 #0000000d;
}

#slide-controls[hidden]{ 
  display:none; 
}

#slide-controls .button {
  display: inline-block;
  cursor: pointer;
}

#slide-controls input {
  border: 1px solid #999;
  border-radius: 5px;
  width: 40px;
  line-height: 20px;
  font-size: 18px;
  color: #999;
  text-align: center;
  -webkit-appearance: none;
  margin: 0;
  background: transparent;
}

#slide-controls input::-webkit-outer-spin-button,
#slide-controls input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0; 
}

plot-json {
  width: max-content;
  display: block;
  margin: 0 auto;
}

plot-json .js-plotly-plot, plot-json .plot-container, plot-json .svg-container {
  width: max-content;
}

@media print {
  html  { 
    overflow: auto;
  }
  
  body  { 
    margin: 0; 
  }
  
  #slides-cont  { 
    transform: none !important;
    position: relative;
    top: 0;
    left: 0;
  }
  
  slide {
    display: block !important;
    -webkit-print-color-adjust: exact;
    position: relative;
  }

  slide:not(:last-child) {
    page-break-after: always;
    break-after: page;
  }
}

.slide-in,
.slide-out {
  animation-duration: 0.50s;
  animation-fill-mode: both;
  animation-timing-function: ease;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }

  to {
    opacity: 1;
  }
}

@keyframes fadeOut {
  from {
    opacity: 1;
  }

  to {
    opacity: 0;
  }
}

.fade-in {
  animation-name: fadeIn;
}

.fade-out {
  animation-name: fadeOut;
}

@keyframes slideLeftIn {
  from {
    transform: translateX(100%);
  }

  to {
    transform: none;
  }
}

@keyframes slideLeftOut {
  from {
    transform: none;
  }

  to {
    transform: translateX(-100%);
  }
}

@keyframes slideRightIn {
  from {
    transform: translateX(-100%);
  }

  to {
    transform: none;
  }
}

@keyframes slideRightOut {
  from {
    transform: none;
  }

  to {
    transform: translateX(100%);
  }
}

@keyframes slideUpIn {
  from {
    transform: translateY(100%);
  }

  to {
    transform: none;
  }
}

@keyframes slideUpOut {
  from {
    transform: none;
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes slideDownIn {
  from {
    transform: translateY(-100%);
  }

  to {
    transform: none;
  }
}

@keyframes slideDownOut {
  from {
    transform: none;
  }

  to {
    transform: translateY(100%);
  }
}

.slide-left-in {
  animation-name: slideLeftIn;
}

.slide-left-out {
  animation-name: slideLeftOut;
}

.slide-right-in {
  animation-name: slideRightIn;
}

.slide-right-out {
  animation-name: slideRightOut;
}

.slide-up-in {
  animation-name: slideUpIn;
}

.slide-up-out {
  animation-name: slideUpOut;
}

.slide-down-in {
  animation-name: slideDownIn;
}

.slide-down-out {
  animation-name: slideDownOut;
}

@keyframes zoomIn {
  from {
    transform: scale(.85);
    opacity: 0;
  }

  to {
    transform: none;
    opacity: 1;
  }
}

@keyframes zoomOut {
  from {
    transform: none;
    opacity: 1;
  }

  to {
    transform: scale(1.1);
    opacity: 0;
  }
}

.zoom-in {
  animation-name: zoomIn;
}

.zoom-out {
  animation-name: zoomOut;
}

@keyframes flipYIn {
  from {
    transform: rotateY(-90deg);
    opacity: 0;
  }

  to {
    transform: none;
    opacity: 1;
  }
}

@keyframes flipYOut {
  from {
    transform: none;
    opacity: 1;
  }

  to {
    transform: rotateY(90deg);
    opacity: 0;
  }
}

.flip-y-in {
  animation-name: flipYIn;
  transform-origin: center left;
  backface-visibility: hidden;
}

.flip-y-out {
  animation-name: flipYOut;
  transform-origin: center right;
  backface-visibility: hidden;
}

@keyframes flipXIn {
  from {
    transform: rotateX(90deg);
    opacity: 0;
  }

  to {
    transform: none;
    opacity: 1;
  }
}

@keyframes flipXOut {
  from {
    transform: none;
    opacity: 1;
  }

  to {
    transform: rotateX(-90deg);
    opacity: 0;
  }
}

.flip-x-in {
  animation-name: flipXIn;
  transform-origin: bottom center;
  backface-visibility: hidden;
}

.flip-x-out {
  animation-name: flipXOut;
  transform-origin: top center;
  backface-visibility: hidden;
}

.cube-common {
  perspective: 1200px;
}

@keyframes cubeLeftIn {
  from {
    transform: rotateY(90deg);
  }

  to {
    transform: none;
  }
}

@keyframes cubeLeftOut {
  from {
    transform: none;
  }

  to {
    transform: rotateY(-90deg);
  }
}

@keyframes cubeRightIn {
  from {
    transform: rotateY(-90deg);
  }

  to {
    transform: none;
  }
}

@keyframes cubeRightOut {
  from {
    transform: none;
  }

  to {
    transform: rotateY(90deg);
  }
}

@keyframes cubeUpIn {
  from {
    transform: rotateX(-90deg);
  }

  to {
    transform: none;
  }
}

@keyframes cubeUpOut {
  from {
    transform: none;
  }

  to {
    transform: rotateX(90deg);
  }
}

@keyframes cubeDownIn {
  from {
    transform: rotateX(90deg);
  }

  to {
    transform: none;
  }
}

@keyframes cubeDownOut {
  from {
    transform: none;
  }

  to {
    transform: rotateX(-90deg);
  }
}

.cube-left-in {
  animation-name: cubeLeftIn;
  transform-origin: center right;
}

.cube-left-out {
  animation-name: cubeLeftOut;
  transform-origin: center left;
}

.cube-right-in {
  animation-name: cubeRightIn;
  transform-origin: center left;
}

.cube-right-out {
  animation-name: cubeRightOut;
  transform-origin: center right;
}

.cube-up-in {
  animation-name: cubeUpIn;
  transform-origin: bottom center;
}

.cube-up-out {
  animation-name: cubeUpOut;
  transform-origin: top center;
}

.cube-down-in {
  animation-name: cubeDownIn;
  transform-origin: top center;
}

.cube-down-out {
  animation-name: cubeDownOut;
  transform-origin: bottom center;
}

.cube-left-in,
.cube-left-out,
.cube-right-in,
.cube-right-out,
.cube-up-in,
.cube-up-out,
.cube-down-in,
.cube-down-out {
  perspective: 1200px;
}

@keyframes coverIn {
  from {
    transform: translateX(100%);
  }

  to {
    transform: none;
  }
}

@keyframes coverOut {
  from {
    opacity: 1;
  }

  to {
    opacity: 1;
  }
}

@keyframes uncoverIn {
  from {
    opacity: 1;
  }

  to {
    opacity: 1;
  }
}

@keyframes uncoverOut {
  from {
    transform: none;
  }

  to {
    transform: translateX(-100%);
  }
}

.cover-in {
  animation-name: coverIn;
  z-index: 3;
}

.cover-out {
  animation-name: coverOut;
  z-index: 1;
}

.uncover-in {
  animation-name: uncoverIn;
  z-index: 1;
}

.uncover-out {
  animation-name: uncoverOut;
  z-index: 3;
}

.cover-left-in   { 
  animation-name: coverIn;  
  z-index: 3; 
}
.cover-left-out  { 
  animation-name: coverOut; 
  z-index: 1; 
}

.uncover-left-in  { 
  animation-name: uncoverIn;  
  z-index: 1; 
}
.uncover-left-out { 
  animation-name: uncoverOut; 
  z-index: 3; 
}

@keyframes coverRightIn {
  from {
    transform: translateX(-100%)
  }

  to {
    transform: none
  }
}

@keyframes coverUpIn {
  from {
    transform: translateY(100%)
  }

  to {
    transform: none
  }
}

@keyframes coverDownIn {
  from {
    transform: translateY(-100%)
  }

  to {
    transform: none
  }
}

@keyframes uncoverRightOut {
  from {
    transform: none
  }

  to {
    transform: translateX(100%)
  }
}

@keyframes uncoverUpOut {
  from {
    transform: none
  }

  to {
    transform: translateY(-100%)
  }
}

@keyframes uncoverDownOut {
  from {
    transform: none
  }

  to {
    transform: translateY(100%)
  }
}

.cover-right-in {
  animation-name: coverRightIn;
  z-index: 3;
}

.cover-right-out {
  animation-name: coverOut;
  z-index: 1;
}

.cover-up-in {
  animation-name: coverUpIn;
  z-index: 3;
}

.cover-up-out {
  animation-name: coverOut;
  z-index: 1;
}

.cover-down-in {
  animation-name: coverDownIn;
  z-index: 3;
}

.cover-down-out {
  animation-name: coverOut;
  z-index: 1;
}

.uncover-right-in {
  animation-name: uncoverIn;
  z-index: 1;
}

.uncover-right-out {
  animation-name: uncoverRightOut;
  z-index: 3;
}

.uncover-up-in {
  animation-name: uncoverIn;
  z-index: 1;
}

.uncover-up-out {
  animation-name: uncoverUpOut;
  z-index: 3;
}

.uncover-down-in {
  animation-name: uncoverIn;
  z-index: 1;
}

.uncover-down-out {
  animation-name: uncoverDownOut;
  z-index: 3;
}

@keyframes pushLeftIn {
  from {
    transform: translateX(100%);
  }

  to {
    transform: none;
  }
}

@keyframes pushLeftOut {
  from {
    transform: none;
  }

  to {
    transform: translateX(-100%);
  }
}

@keyframes pushRightIn {
  from {
    transform: translateX(-100%);
  }

  to {
    transform: none;
  }
}

@keyframes pushRightOut {
  from {
    transform: none;
  }

  to {
    transform: translateX(100%);
  }
}

@keyframes pushUpIn {
  from {
    transform: translateY(100%);
  }

  to {
    transform: none;
  }
}

@keyframes pushUpOut {
  from {
    transform: none;
  }

  to {
    transform: translateY(-100%);
  }
}

@keyframes pushDownIn {
  from {
    transform: translateY(-100%);
  }

  to {
    transform: none;
  }
}

@keyframes pushDownOut {
  from {
    transform: none;
  }

  to {
    transform: translateY(100%);
  }
}

.push-left-in {
  animation-name: pushLeftIn;
}

.push-left-out {
  animation-name: pushLeftOut;
}

.push-right-in {
  animation-name: pushRightIn;
}

.push-right-out {
  animation-name: pushRightOut;
}

.push-up-in {
  animation-name: pushUpIn;
}

.push-up-out {
  animation-name: pushUpOut;
}

.push-down-in {
  animation-name: pushDownIn;
}

.push-down-out {
  animation-name: pushDownOut;
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={svg-viewer.css}]
.prdc-svg-viewer {
  width: 100%;
  height: auto;
  border-top: 1px solid #ddd;
  overflow: hidden;
  position: relative;
}

.data-card .prdc-svg-viewer {
  background: #fff;
}

.prdc-svg-viewer iframe {
  width: 100%;
  height: 100%;
}

.prdc-svg-viewer.autoheight iframe {
  height: auto;
}

.prdc-svg-viewer .prdc-svg-viewer-controls {
  position: absolute;
  top: 5px;
  right: 20px;
  user-select: none;
}

body:not(.touchscreen) .prdc-svg-viewer .prdc-svg-viewer-controls > div:hover {
  border: 1px solid #2e85c7;
}

.prdc-svg-viewer .prdc-svg-viewer-controls > div:active {
  opacity: 0.5;
}

.prdc-svg-viewer .prdc-svg-viewer-controls > div {
  display: inline-block;
  height: 36px;
  padding: 5px 10px;
  margin: 5px 2px;
  border-radius: 3px;
  color: #ccc;
  vertical-align: top;
  cursor: pointer;
  border: 1px solid #ddd;
  transition: border .2s linear;
  width: 36px;
  background-color: rgba(255,255,255,0.9);
  background-position: center;
  background-repeat: no-repeat;
  background-size: contain;
}

.prdc-svg-viewer .prdc-svg-viewer-controls .prdc-svg-viewer-control-zoom-plus {
  background-image: url('../img/zoom-plus.svg');
}

.prdc-svg-viewer .prdc-svg-viewer-controls .prdc-svg-viewer-control-zoom-minus {
  background-image: url('../img/zoom-minus.svg');
}
      
.prdc-svg-viewer .prdc-svg-viewer-controls .prdc-svg-viewer-control-autoscale {
  background-image: url('../img/autoscale.svg');
}

.prdc-svg-viewer .prdc-svg-viewer-controls .prdc-svg-viewer-control-reset {
  background-image: url('../img/reset2.svg');
}

.prdc-svg-viewer .prdc-svg-viewer-controls .prdc-svg-viewer-control-layers {
  background-image: url('../img/layers.svg');
}

.prdc-svg-viewer.no-layers .prdc-svg-viewer-controls .prdc-svg-viewer-control-layers {
  display: none;
}

.prdc-svg-viewer-layers-popup {
  position: absolute;
  display: none;
  border-radius: 5px;
  width: 400px;
  top: 56px;
  right: 20px;
  background: #fffffff5;
  border: 1px solid #ddd;
  color: #fff;
  pointer-events: all;
  cursor: pointer;
  min-height: 100px;
}

.prdc-svg-viewer-layers-popup .popup-triangle {
  position: absolute;
  width: 0;
  height: 0;
  border-style: solid;
  border-width: 0 10px 10px 10px;
  border-color: transparent transparent #ccc transparent;
  margin-right: 5px;
  top: -11px;
  right: 3px;
}

.prdc-svg-viewer-layers-popup-cont {
  overflow-y: auto;
  max-height: 400px;
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={tabs.css}]
.tabs {
  box-sizing: border-box;
  position: relative;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  font-size: 12px;
  height: 46px;
  padding: 8px 3px 4px 3px;
  background: #dee1e6;
  border-radius: 5px 5px 0 0;
  overflow: hidden;
}
.tabs * {
  box-sizing: inherit;
  font: inherit;
}
.tabs .tabs-content {
  position: relative;
  width: 100%;
  height: 100%;
}
.tabs .tab {
  position: absolute;
  left: 0;
  height: 36px;
  width: 240px;
  border: 0;
  margin: 0;
  z-index: 1;
  pointer-events: none;
}
.tabs .tab,
.tabs .tab * {
  user-select: none;
  cursor: pointer;
}
.tabs .tab .tab-dividers {
  position: absolute;
  top: 7px;
  bottom: 7px;
  left: var(--tab-content-margin);
  right: var(--tab-content-margin);
}
.tabs .tab .tab-dividers,
.tabs .tab .tab-dividers::before,
.tabs .tab .tab-dividers::after {
  pointer-events: none;
}
.tabs .tab .tab-dividers::before,
.tabs .tab .tab-dividers::after {
  content: "";
  display: block;
  position: absolute;
  top: 0;
  bottom: 0;
  width: 1px;
  background: #a9adb0;
  opacity: 1;
  transition: opacity 0.2s ease;
}
.tabs .tab .tab-dividers::before {
  left: 0;
}
.tabs .tab .tab-dividers::after {
  right: 0;
}
.tabs .tab:first-child .tab-dividers::before,
.tabs .tab:last-child .tab-dividers::after {
  opacity: 0;
}
.tabs .tab .tab-background {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  pointer-events: none;
}
.tabs .tab .tab-background > svg {
  width: 100%;
  height: 100%;
}
.tabs .tab .tab-background > svg .tab-geometry {
  fill: #f4f5f6;
}
.tabs .tab[active] {
  z-index: 5;
}
.tabs .tab[active] .tab-background > svg .tab-geometry {
  fill: #fff;
}
.tabs .tab:not([active]) .tab-background {
  transition: opacity 0.2s ease;
  opacity: 0;
}
@media (hover: hover) {
  .tabs .tab:not([active]):hover {
    z-index: 2;
  }
  .tabs .tab:not([active]):hover .tab-background {
    opacity: 1;
  }
}
.tabs .tab.tab-was-just-added {
  top: 10px;
  animation: tab-was-just-added 120ms forwards ease-in-out;
}
.tabs .tab .tab-content {
  position: absolute;
  display: flex;
  top: 0;
  bottom: 0;
  left: var(--tab-content-margin);
  right: var(--tab-content-margin);
  padding: 9px 8px;
  border-top-left-radius: 8px;
  border-top-right-radius: 8px;
  overflow: hidden;
  pointer-events: all;
}
.tabs .tab[is-mini] .tab-content {
  padding-left: 2px;
  padding-right: 2px;
}
.tabs .tab .tab-favicon {
  position: relative;
  flex-shrink: 0;
  flex-grow: 0;
  height: 16px;
  width: 16px;
  background-size: 16px;
  margin-left: 4px;
}
.tabs .tab[is-small] .tab-favicon {
  margin-left: 0;
}
.tabs .tab[is-mini]:not([active]) .tab-favicon {
  margin-left: auto;
  margin-right: auto;
}
.tabs .tab[is-mini][active] .tab-favicon {
  display: none;
}
.tabs .tab .tab-title {
  flex: 1;
  vertical-align: top;
  overflow: hidden;
  white-space: nowrap;
  margin-left: 4px;
  color: #5f6368;
  -webkit-mask-image: linear-gradient(90deg, #000 0%, #000 calc(100% - 24px), transparent);
  mask-image: linear-gradient(90deg, #000 0%, #000 calc(100% - 24px), transparent);
}
.tabs .tab[is-small] .tab-title {
  margin-left: 0;
}
.tabs .tab .tab-favicon + .tab-title,
.tabs .tab[is-small] .tab-favicon + .tab-title {
  margin-left: 8px;
}
.tabs .tab[is-smaller] .tab-favicon + .tab-title,
.tabs .tab[is-mini] .tab-title {
  display: none;
}
.tabs .tab[active] .tab-title {
  color: #45474a;
}
.tabs .tab .tab-drag-handle {
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  left: 0;
  border-top-left-radius: 8px;
  border-top-right-radius: 8px;
}
.tabs .tab .tab-close {
  flex-grow: 0;
  flex-shrink: 0;
  position: relative;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8'><path stroke='rgba(0, 0, 0, .65)' stroke-linecap='square' stroke-width='1.5' d='M0 0 L8 8 M8 0 L0 8'></path></svg>");
  background-position: center center;
  background-repeat: no-repeat;
  background-size: 8px 8px;
}
@media (hover: hover) {
  .tabs .tab .tab-close:hover {
    background-color: #e8eaed;
  }
  .tabs .tab .tab-close:hover:active {
    background-color: #dadce0;
  }
}
@media not all and (hover: hover) {
  .tabs .tab .tab-close:active {
    background-color: #dadce0;
  }
}
@media (hover: hover) {
  .tabs .tab:not([active]) .tab-close:not(:hover):not(:active) {
    opacity: 0.8;
  }
}
.tabs .tab[is-smaller] .tab-close {
  margin-left: auto;
}
.tabs .tab[is-mini]:not([active]) .tab-close {
  display: none;
}
.tabs .tab[is-mini][active] .tab-close {
  margin-left: auto;
  margin-right: auto;
}
@-moz-keyframes tab-was-just-added {
  to {
    top: 0;
  }
}
@-webkit-keyframes tab-was-just-added {
  to {
    top: 0;
  }
}
@-o-keyframes tab-was-just-added {
  to {
    top: 0;
  }
}
@keyframes tab-was-just-added {
  to {
    top: 0;
  }
}
.tabs.tabs-is-sorting .tab:not(.tab-is-dragging),
.tabs:not(.tabs-is-sorting) .tab.tab-was-just-dragged {
  transition: transform 120ms ease-in-out;
}
.tabs .tabs-bottom-bar {
  position: absolute;
  bottom: 0;
  height: 4px;
  left: 0;
  width: 100%;
  background: #fff;
  z-index: 10;
}
.tabs-optional-shadow-below-bottom-bar {
  position: relative;
  height: 1px;
  width: 100%;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='1' height='1' viewBox='0 0 1 1'><rect x='0' y='0' width='1' height='1' fill='rgba(0, 0, 0, .17)'></rect></svg>");
  background-size: 1px 1px;
  background-repeat: repeat-x;
  background-position: 0% 0%;
}
@media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx) {
  .tabs-optional-shadow-below-bottom-bar {
    background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='2' height='2' viewBox='0 0 2 2'><rect x='0' y='0' width='2' height='1' fill='rgba(0, 0, 0, .27)'></rect></svg>");
  }
}

\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={terminal.css}]
#command-window-options {
  position: absolute;
  top: -1px;
  right: 8px;
}

#command-window-options.options .options-right {
  float: right;
}

#command-window-options.options i.settings {
  background: url(../img/settings.svg) no-repeat center;
}

#command-window-options.options i.timestamp {
  background: url(../img/timestamp.svg) no-repeat center;
}

#command-window-options.options i.autoscroll {
  background: url(../img/autoscroll.svg) no-repeat center;
}

#command-window-options.options i.clear {
  background: url(../img/clear.svg) no-repeat center;
}

#command-window-options.options i.log {
  background: url(../img/save-log.svg) no-repeat center;
}

#command-window-options.options i.to-bottom {
  background: url(../img/to-bottom.svg) no-repeat center;
}

#command-window-options.options i {
  width: 16px;
  height: 18px;
  display: block;
  background-size: 16px!important;
  float: left;
  clear: none;
  padding: 3px 5px;
  opacity: 0.3;
  user-select: none;
  -webkit-user-drag: none;
}

#command-window-options.options i:hover {
  opacity: 1;
  cursor: pointer;
}

#command-window-options.options i.active {
  opacity: 0.8;
}

#command-window-input-container {
  padding: 10px;
  padding-left: 25px;
  position: relative;
  background-image: url(../img/input.svg);
  background-position: left 12px top 12px;
  background-size: 15px;
  background-repeat: no-repeat;
  padding-right: 45px;
}

#command-window-input {
  border: 0;
  color: #333;
  font-family: 'Roboto', Arial;
  font-size: 16px;
  font-weight: 300;
  padding: 0;
  width: 100%;
  background: transparent;
  resize: none;
  overflow: hidden;
  min-height: 34px;
}

#command-window-messages {
  padding-top: 10px;
}

#command-window-messages .welcome-message .app-logo {
  float: left;
  height: 200px;
  padding: 20px;
  padding-left: 0px;
  display: block;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

#command-window-messages .welcome-message .company-logo {
  float: left;
  height: 136px;
  padding: 52px 10px;
  padding-right: 10px;
  opacity: 0.1;
  display: block;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

#command-window-messages .welcome-message p {
  display: block;
  line-height: 22px;
  padding: 10px 0px;
  color: #333;
  font-weight: 300;
  opacity: 0.8;
  max-width: 800px;
}

#command-window-messages .welcome-message span:not(.timestamp) {
  font-weight: 500;
}

#command-window-messages .welcome-message, #command-window-messages .welcome-message * {
  white-space: normal!important;
}

#command-window-messages a {
  font-weight: 500;
  color: #000;
}

#command-window-messages.messages > div {
  padding-bottom: 5px;
  padding-top: 5px;
  line-height: 22px;
  padding-left: 130px;
  padding-right: 10px;
  position: relative;
  white-space: pre-wrap;
  min-height: 32px;
}

#command-window-messages.messages.no-timestamp > div {
  padding-left: 25px;
}

#command-window-messages.messages div.system-in {
  background: url(../img/system-in.svg) no-repeat 4px 8px;
  background-size: 14px;
}

#command-window-messages.messages div.data-in {
  background: url(../img/console-in.svg) no-repeat 4px 8px;
  background-size: 14px;
}

#command-window-messages.messages div.data-out {
  background: url(../img/console-out.svg) no-repeat 4px 8px;
  background-size: 14px;
}

#command-window-messages.messages div:hover {
  background-color: #f9f9f9;
}

#command-window-messages.messages.no-timestamp div span.timestamp {
  display: none;
}

#command-window-messages.messages div:hover span.timestamp {
  color: #2e85c7
}

#command-window-messages.messages div span.timestamp {
  color: #999;
  display: block;
  position: absolute;
  left: 25px;
}

#command-window-messages.messages div span.log {
  color: #666;
}

#command-window-messages.messages div span.msg {
  color: #12568a;
}

#command-window-messages.messages div span.data {
  color: #17d838;
}

#command-window-messages.messages div span.error {
  color: #cf000f;
}

#command-window-messages.messages div span.warn {
  color: #dd8f00;
}
#command-window-messages.messages:hover div:hover {
  filter: none;
}

#command-window-input-submit-cont {
  position: absolute;
  right: 10px;
  z-index: 3;
  background: #f7df1e;
  border-radius: 100%;
  width: 30px;
  height: 30px;
  cursor: pointer;
}

#command-window-input-submit-cont:hover {
  opacity: 0.6;
}

#command-window-input-submit-cont img {
  width: 18px;
  padding: 6px;
}

/* #command-window-messages.messages:hover div {
  filter: grayscale(100%);
} */

.save-log, .change-settings {
  margin-bottom: 0px;
}

.history-cont {
  display: none;
  left: 0px;
  position: absolute;
  bottom: 0px;
  top: 23px;
  right: 0px;
  -webkit-backdrop-filter: blur(5px);
  backdrop-filter: blur(5px);
  background-color: rgba(255, 255, 255, 0.7);
  padding: 20px;
}

.history-panel {
  top: 55px!important;
  left: 20px!important;
  right: 20px!important;
  bottom: 0px!important;
  padding-top: 10px;
  padding-bottom: 10px;
}

.history-panel li {
  padding-bottom: 5px;
  padding-top: 5px;
  line-height: 22px;
  padding-left: 10px;
  padding-right: 10px;
  margin: 0 10px;
  position: relative;
  white-space: pre-wrap;
  border-bottom: 1px solid #f7df1e;
  min-height: 22px;
  cursor: pointer;
  transition: all linear 0.3s;
}

.history-panel li:after {
  transition: all linear 0.3s;
}

.history-panel li:after {
  content: '';
  position: absolute;
  top: 3px;
  left: 0px;
  right: 0px;
  bottom: 3px;
  border: 1px solid transparent;
  border-radius: 3px;
  background: #ffffff69;
  z-index: -1;
}

.history-panel li.active:after {
  border: 1px solid #999;
}

.history-panel li:not(.active):hover:after {
  border: 1px solid #999;
}

.history-panel li:last-child {
  border-bottom: 1px solid transparent;
}

.history-panel .history-empty {
  padding-bottom: 5px;
  padding-top: 5px;
  line-height: 22px;
  padding-left: 10px;
  padding-right: 10px;
  margin: 0 10px;
  position: relative;
  text-align: center;
}

.options-panel {
  display: none;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  position: absolute;
  -webkit-backdrop-filter: blur(5px);
  backdrop-filter: blur(5px);
  background-color: rgba(255, 255, 255, 0.7);
  overflow-y: auto;
}

.options-cont {
  margin: 0 auto;
  width: 460px;
  position: relative;
  background: #ffffff6b;
  box-shadow: 0 0 10px #00000026;
  border-radius: 10px;
  padding: 20px;
  padding-bottom: 20px;
  color: #777;
  margin-bottom: 20px;
  margin-top: 20px;
}

.options-header, .page-header, .history-header {
  position: relative;
  border-bottom: 1px solid #666;
  margin-bottom: 25px;
  padding-bottom: 10px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

.page-header {
  margin-bottom: 0px;
}

.options-header span, .page-header span, .history-header span {
  color: #666;
  display: block;
  font-weight: bold;
  font-size: 24px;
  border-radius: 3px;
}

.options-close, .page-close, .history-close {
  opacity: 0.7;
  position: absolute;
  display: block;
  top: 0px;
  right: 0px;
  cursor: pointer;
}

.options-close:hover, .page-close:hover, .history-close:hover {
  opacity: 0.3;
}

@media only screen and (max-width: 900px) {
  .page-cont {
    width: 460px;
  }
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={three.css}]
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}

html {
  overflow: hidden;
}

:focus {
  outline: 0;
}

div {
  z-index: 2;
  box-sizing: border-box;
}

section {
  position: relative;
  z-index: 2;
}

body  {
  font-family: 'Roboto', Arial;
  width: 100%;
  background: #fff;
}

.clear {
  clear: both;
}

.float-left {
  float: left;
}

.float-right {
  float: right;
}
\end{lstlisting}

\begin{lstlisting}[style=CSSStyle, caption={ui.css}]
html {
  overflow: auto;
  height: 100%;
}

body {
  border-top: 1px solid #ccc;
  padding-top: 5px;
}

sup {
  vertical-align: super;
  font-size: smaller;
}

sub {
  vertical-align: sub;
  font-size: smaller;
}

button.ui {
  text-align: center;
  text-transform: uppercase;
  padding: 10px;
  cursor: pointer;
  background: #fff;
  transition: background 0.2s linear, color 0.2s linear;
  -webkit-transition: background 0.2s linear, color 0.2s linear;
}

button.ui:hover {
  background: #eee;
}

button.ui.blue {
  background: #2e85c7;
  border-color: #2e85c7;
  color: #fff;
}

button.ui.blue:hover {
  background: #fff;
  color: #2e85c7;
}

button.ui.red {
  background: #cf000f;
  border-color: #cf000f;
  color: #fff;
}

button.ui.red:hover {
  background: #fff;
  color: #cf000f;
}

button.ui.green {
  background: #26a65b;
  border-color: #26a65b;
  color: #fff;
}

button.ui.green:hover {
  background: #fff;
  color: #26a65b;
}

label.ui {
  display: block;
  font-size: 14px;
  margin-bottom: 3px;
  margin-left: 5px;
}

input.ui.warning {
  border-color: #fff800!important;
}

input.ui.error {
  border-color: #f00!important;
}

select.ui, input.ui, button.ui, div.result.ui {
  display: block;
  margin: 5px;
  margin-bottom: 5px;
  width: calc(100% - 10px);
  padding: 8px;
  border: 1px solid #ccc;
  border-radius: 5px;
  font-size: 16px;
  box-sizing: border-box;
}

li.ui {
  text-align: center;
  padding: 10px;
  margin: 5px;
  border: 1px solid #ccc;
  border-radius: 5px;
  cursor: pointer;
  transition: background 0.2s linear, color 0.2s linear;
  -webkit-transition: background 0.2s linear, color 0.2s linear;
}

li.ui:hover {
  background: #eee;
}

.ui.grid-cont {
  margin: 5px;
}

.ui.one_half, .ui.one_third, .ui.two_third, .ui.one_fourth, .ui.one_fifth {
	float: left;
	margin-right: 4%;
	position: relative;
  margin-left: 0;
}

.ui.one_half {
	width: 48%;
}

.ui.one_third {
	width: 30.66%;
}

.ui.one_fourth {
	width: 22%;
}

.ui.one_fifth {
	width: 16.8%;
}

.ui.last {
	margin-right: 0!important;
	clear: right;
}

.ui.options-panel {
  display: none;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  position: absolute;
  -webkit-backdrop-filter: blur(5px);
  backdrop-filter: blur(5px);
  background-color: rgba(255, 255, 255, 0.7);
  overflow-y: auto;
}

.ui.options-cont {
  margin: 0 auto;
  width: 460px;
  position: relative;
  background: #ffffff6b;
  box-shadow: 0 0 10px #00000026;
  border-radius: 10px;
  padding: 20px;
  padding-bottom: 20px;
  color: #777;
  margin-bottom: 20px;
  margin-top: 20px;
}

.ui.options-header {
  position: relative;
  border-bottom: 1px solid #666;
  margin-bottom: 25px;
  padding-bottom: 10px;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

.ui.options-header span {
  color: #666;
  display: block;
  font-weight: bold;
  font-size: 24px;
  border-radius: 3px;
}

.ui.options-close {
  opacity: 0.7;
  position: absolute;
  display: block;
  top: 0px;
  right: 0px;
  cursor: pointer;
}

.ui.options-close:hover {
  opacity: 0.3;
}

.ui.float-input {
  display: flex;
  flex-flow: column-reverse;
  position: relative;
  margin-top: 6px;
}

.ui.float-select {
  display: flex;
  flex-flow: column-reverse;
  position: relative;
  margin-top: 5px;
}

.ui.no-float-input {
  position: relative;
  margin-top: 5px;
}

.ui label.float-label {
  pointer-events: none;
  position: absolute;
  top: -11px;
  margin-left: 12px!important;
  padding: 1px 8px;
  border-radius: 3px;
  background: #fff;
}

.ui.options-cont .ui label.float-label {
  color: #777!important;
  font-weight: bold;
  background: #eee;
}

.ui.options-cont .ui.float-select label.float-label {
  color: #777;
  font-weight: bold;
  background: #eee;
}

.ui label.float-label, 
.ui.float-input input, 
.ui.float-input textarea {
  transition: all 0.2s;
  touch-action: manipulation;
}

.ui.float-input input:placeholder-shown + label.float-label, 
.ui.float-input textarea:placeholder-shown + label.float-label {
  cursor: text;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  transform-origin: left bottom;
  transform: translate(0, 1.7rem) scale(1.2);
  background: none;
}

.ui.float-input input::-webkit-input-placeholder, 
.ui.float-input input::placeholder, 
.ui.float-input textarea::-webkit-input-placeholder, 
.ui.float-input textarea::placeholder {
  opacity: 0;
  transition: inherit;
}

.ui.float-input input:focus::-webkit-input-placeholder, 
.ui.float-input textarea:focus::-webkit-input-placeholder {
  opacity: 1;
}

.ui.float-input input:not(:placeholder-shown) + label.float-label,
.ui.float-input input:focus + label.float-label,
.ui.float-input textarea:not(:placeholder-shown) + label.float-label,
.ui.float-input textarea:focus + label.float-label,
.ui.float-input input:-webkit-autofill + label.float-label
.ui.float-input textarea:-webkit-autofill + label.float-label {
  transform: translate(0, 0) scale(1);
  cursor: pointer;
}

.ui.options-cont .ui.float-input input:not(:placeholder-shown) + label.float-label,
.ui.options-cont .ui.float-input input:focus + label.float-label,
.ui.options-cont .ui.float-input textarea:not(:placeholder-shown) + label.float-label,
.ui.options-cont .ui.float-input textarea:focus + label.float-label,
.ui.options-cont .ui.float-input input:-webkit-autofill + label.float-label
.ui.options-cont .ui.float-input textarea:-webkit-autofill + label.float-label {
  background: #eee;
}

.ui.float-input input:not(:placeholder-shown) + label.float-label,
.ui.float-input input:focus + label.float-label,
.ui.float-input textarea:not(:placeholder-shown) + label.float-label,
.ui.float-input textarea:focus + label.float-label,
.ui.float-input input:-webkit-autofill + label.float-label,
.ui.float-input textarea:-webkit-autofill + label.float-label{
  display: inline-block;
}

.ui.options-cont .ui.float-input input:not(:placeholder-shown) + label.float-label,
.ui.options-cont .ui.float-input input:focus + label.float-label,
.ui.options-cont .ui.float-input textarea:not(:placeholder-shown) + label.float-label,
.ui.options-cont .ui.float-input textarea:focus + label.float-label,
.ui.options-cont .ui.float-input input:-webkit-autofill + label.float-label,
.ui.options-cont .ui.float-input textarea:-webkit-autofill + label.float-label{
  color: #777!important;
  font-weight: bold;
  background: #eee;
}

.ui.options-cont ::placeholder, 
.ui.options-cont ::-webkit-input-placeholder {
  color: #ccc;
  font-weight: normal;
  text-transform: none;
}

.ui.options-cont input:disabled, 
.ui.options-cont textarea:disabled, 
.ui.options-cont select:disabled {
  opacity: 0.5;
  pointer-events: none;
}

.ui.options-cont label {
  color: #12568a;
  margin-bottom: 2px;
  display: block;
  margin-left: 3px;
}

.ui.options-cont label span {
  color: #555;
}

.ui.options-cont label.checkcont {
  margin: 15px 0;
  font-size: 18px;
  padding-top: 3px;
  padding-bottom: 3px;
}

.ui.options-cont label.checkcont {
  padding-top: 6px;
  color: #333;
}

.ui.checkcont {
  display: block;
  position: relative;
  padding-left: 35px;
  margin-bottom: 12px;
  cursor: pointer;
  font-size: 22px;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  -webkit-user-drag: none;
  user-drag: none;
}

.ui.checkcont input {
  position: absolute;
  opacity: 0;
  cursor: pointer;
  height: 0;
  width: 0;
}

.ui.checkcont .checkmark {
  position: absolute;
  top: 0;
  left: 0;
  height: 25px;
  width: 25px;
  background-color: #fff;
  border: 2px solid #ccc;
  border-radius: 3px;
}

.ui.checkcont:hover input ~ .checkmark {
  background-color: #ccc;
}

.ui.checkcont input:checked ~ .checkmark {
  background-color: #2e85c7;
}

.ui.checkcont .checkmark:after {
  content: "";
  position: absolute;
  display: none;
}

.ui.checkcont input:checked ~ .checkmark:after {
  display: block;
}

.ui.checkcont .checkmark:after {
  left: 9px;
  top: 5px;
  width: 5px;
  height: 10px;
  border: solid white;
  border-width: 0 3px 3px 0;
  -webkit-transform: rotate(45deg);
  -ms-transform: rotate(45deg);
  transform: rotate(45deg);
}

.ui.float-input input[type="text"], 
.ui.float-input input[type="number"], 
.ui.float-input input[type="submit"], 
.ui.float-input input[type="password"], 
.ui.float-input textarea, 
.ui.float-input select, 
.ui.float-input button {
  font-family: 'Roboto';
  border: 1px solid #ccc;
  color: #333;
  font-size: 16px;
  padding-left: 10px;
  padding-right: 10px;
  padding-top: 8px;
  padding-bottom: 8px;
  width: calc(100% - 24px);
  transition: all 0.2s linear;
  -webkit-transition: all 0.2s linear;
  border-radius: 3px;
  -webkit-appearance: none;
  background: #fff;
  font-family: 'Roboto';
  -webkit-box-sizing:content-box;
  box-sizing:content-box;
  cursor: pointer;
  line-height: 18px;
}

.ui.options-cont input[type="text"], 
.ui.options-cont input[type="number"], 
.ui.options-cont input[type="submit"], 
.ui.options-cont input[type="password"], 
.ui.options-cont textarea, 
.ui.options-cont select, 
.ui.options-cont button {
  font-family: 'Roboto';
  border: 2px solid #ccc;
  color: #333;
  font-size: 18px;
  padding-left: 10px;
  padding-right: 10px;
  padding-top: 8px;
  padding-bottom: 8px;
  width: calc(100% - 24px);
  margin-bottom: 10px;
  transition: all 0.2s linear;
  -webkit-transition: all 0.2s linear;
  font-weight: bold;
  border-radius: 3px;
  -webkit-appearance: none;
  background: #fff;
  font-family: 'Roboto';
  -webkit-box-sizing:content-box;
  box-sizing:content-box;
  cursor: pointer;
  line-height: 22px;
}

.ui.options-cont textarea {
  resize: vertical;
}

.ui.options-cont input[type="submit"] {
  color: #fff;
  background: #2e85c7;
  background-size: 30px 30px;
  border: 0;
  margin-left: 2px;
  margin-bottom: 10px;
  cursor: pointer;
  text-transform: uppercase;
  border: 2px solid  #2e85c7;
}

.ui.options-cont input[type="text"]:focus, 
.ui.options-cont input[type="number"]:focus, 
.ui.options-cont textarea:focus, 
.ui.options-cont select:focus {
  border: 2px solid  #2e85c7;
}

.ui.options-cont input[type="text"]:read-only:focus, 
.ui.options-cont input[type="number"]:read-only:focus {
  border: 2px solid  #ccc;
}

.ui.options-cont input[type="text"]:read-only:hover, 
.ui.options-cont input[type="number"]:read-only:hover {
  cursor: auto;
}

.ui.options-cont input[type="submit"]:hover {
  color: #2e85c7;
  background: #fff;
}

.ui.options-cont input[type="submit"]:disabled {
  background-image: linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
    transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
    transparent 75%, transparent);
  background-size: 30px 30px;
  animation: animate-stripes 1s linear infinite;
  -webkit-animation: animate-stripes 1s linear infinite;
}

.ui.options-cont button:not([disabled]):hover {
  color: #2e85c7;
  background: #fff;
}

.ui.options-cont button {
  color: #fff;
  background: #2e85c7;
  background-size: 30px 30px;
  border: 0;
  cursor: pointer;
  text-transform: uppercase;
  border: 2px solid #2e85c7;
  margin-top: 15px;
}

.ui.options-cont button:disabled {
  background-image: linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
    transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
    transparent 75%, transparent);
  background-size: 30px 30px;
}

.ui.panel::-webkit-scrollbar,
.ui.panel::-webkit-scrollbar-button,
.ui.panel::-webkit-scrollbar-track,
.ui.panel::-webkit-scrollbar-track-piece,
.ui.panel::-webkit-scrollbar-thumb,
.ui.panel::-webkit-scrollbar-corner,
.ui.panel::-webkit-resizer {
  background: transparent;
}

.ui.panel::-webkit-scrollbar {
  width:  12px;
  height: 12px;
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.ui.panel::-webkit-scrollbar-track-piece {
  -webkit-border-radius: 5px;
  border-radius: 5px;
}

.ui.panel::-webkit-scrollbar-thumb {
  background: #ddd;
  border-radius: 5px;
  background-clip: content-box;
  border: 2px solid transparent;
}

.ui.panel::-webkit-scrollbar-button {
  width:0;
  height:0;
}

.ui.tab-names {
  display: flex;
  gap: 5px;
  margin-bottom: -1px;
  padding-left: 10px;
  padding-right: 10px;
}

.ui.tab-name {
  padding: 5px 10px;
  border: 1px solid #ccc;
  border-bottom: 1px solid #ccc;
  border-radius: 5px 5px 0 0;
  background: #f5f5f5;
  cursor: pointer;
  user-select: none;
}

.ui.tab-name.active {
  border-bottom: none;
  background: #fff;
}

.ui.tab {
  display: none;
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 5px;
  background: #fff;
  margin: 0 5px 5px 5px;
}

.ui.divider {
  border-bottom: 1px solid #ccc;
  margin: 5px;
}

.ui.group {
  border: 1px solid #ccc;
  border-radius: 5px;
  padding: 5px;
  background: #fff;
  margin: 5px;
  margin-top: 10px;
}

.ui.group-title {
  width: max-content;
  padding: 5px 10px;
  margin-top: -18px;
  background: #fff;
  margin-left: 5px;
}

.ui.columns-container {
  display: flex;
}

.ui.columns-container .column {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.ui.columns-container .row {
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0 5px;
}

.ui.text-center {
  text-align: center;
}

.ui.float-input.text-center input {
  text-align: center;
}

.ui.slider {
  -webkit-appearance: none;
  appearance: none;
  height: 20px;
  width: 300px;
  outline: none;
  background: #ddd;
  border-radius: 5px;
  z-index: 2;
  position: relative;
}

.ui.slider.vertical {
  writing-mode: vertical-lr;
  height: 300px;
  width: 20px;
  display: inline-block;
  transform: rotate(180deg);
}

.ui.slider::-webkit-slider-runnable-track {
  cursor: pointer;
}

.ui.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 30px;
  height: 60px;
  background-color: #2e85c7;
  cursor: pointer;
  border-radius: 3px;
  transition: all 0.4s;
  border: 2px solid #fff;
  background-image: linear-gradient(to right, transparent 0 2px, #ffffff75 2px 4px, transparent 4px 6px, #ffffff75 6px 8px, transparent 8px 10px, #ffffff75 10px 12px, transparent 12px 14px);
  background-repeat: no-repeat;
  background-size: 14px 90% ;
  background-position: center;
}

.ui.slider.vertical::-webkit-slider-thumb {
  width: 60px;
  height: 30px;
  background-image: linear-gradient(to bottom, transparent 0 2px, #ffffff75 2px 4px, transparent 4px 6px, #ffffff75 6px 8px, transparent 8px 10px, #ffffff75 10px 12px, transparent 12px 14px);
  background-size: 90% 14px;
}

.ui.slider:disabled::-webkit-slider-thumb {
  background-image: linear-gradient(135deg, rgba(255, 255, 255, .15) 25%, transparent 25%,
    transparent 50%, rgba(255, 255, 255, .15) 50%, rgba(255, 255, 255, .15) 75%,
    transparent 75%, transparent);
  background-size: 30px 30px;
  background-repeat: repeat;
}

.ui.slider-wrapper {
  position: relative;
  text-align: center;
}

.ui.slider-wrapper .slider-midpoint.vertical {
  background: #999;
  height: 4px;
  width: 100%;
  top: 50%;
  left: 50%;
  position: absolute;
  transform: translateY(-50%) translatex(-50%);
  z-index: 0;
  border-radius: 2px;
}
\end{lstlisting}

% ----------------------------------------
\section{html}


\begin{lstlisting}[style=HTMLStyle, caption={blank.html}]
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Window - JSLAB | PR-DC</title>
  <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
  <link rel="stylesheet" type="text/css" href="../css/basic.css" />
  <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
  <style id="custom-style"></style>
</head>
<body>
</body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={cesium.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Cesium Plot - JSLAB | PR-DC</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'unsafe-inline' 'unsafe-eval' blob:;" />
		<link rel="stylesheet" type="text/css" href="../css/basic.css" />
    <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
    <link rel="stylesheet" type="text/css" href="../font/LatinModern.css" />
    <link rel="stylesheet" type="text/css" href="../lib/Cesium-1.124/Widgets/widgets.css">
    <style>
    .cesium-viewer-bottom, .cesium-viewer-toolbar, .cesium-viewer-animationContainer, .cesium-viewer-fullscreenContainer {
      display: none!important;
    }
    </style>
    <style id="dynamic-style-rules"></style>
  </head>
  <body>
    <div id="map-3d-cont"></div>
    
    <script type="text/javascript" src="../lib/Cesium-1.124/Cesium.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={d3.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>D3 Canvas - JSLAB | PR-DC</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
		<link rel="stylesheet" type="text/css" href="../css/basic.css" />
    <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
    <link rel="stylesheet" type="text/css" href="../font/LatinModern.css" />
    
    <style id="dynamic-style-rules"></style>
  </head>
  <body>
    <svg id="d3-svg"></svg>
    <canvas id="d3-canvas"></canvas>
    
    <script type="text/javascript" src="../lib/d3-7.8.5/d3-7.8.5.min.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={editor.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Editor - JSLAB | PR-DC</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
    <link rel="stylesheet" type="text/css" href="../css/tabs.css">
    <link rel="stylesheet" type="text/css" href="../css/codemirror-notepadpp-theme.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/addon/fold/foldgutter.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/addon/lint/lint.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/addon/hint/show-hint.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/lib/codemirror.css">
    <link rel="stylesheet" type="text/css" href="../css/codemirror-editor-custom.css">
		<link rel="stylesheet" type="text/css" href="../css/editor.css" />
    <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
    
    <style id="dynamic-style-rules"></style>
  </head>
  <body>
    <div id="editor-menu-container">
      <div>
        <img id="app-logo" src="../img/JSLAB.svg"/>
        <ul id="editor-menu">
          <li id="new-script" title-str="26"><img src="../img/new-script.svg"/><str sid="10"></str></li>
          <li id="open-menu" title-str="27"><img src="../img/open.svg"/><str sid="11"></str></li>
          <li id="save-menu" title-str="28"><img src="../img/save.svg"/><str sid="12"></str></li>
          <li id="save-as-menu" title-str="29"><img src="../img/save-as.svg"/><str sid="13"></str></li>
          <li id="run-menu" title-str="30"><img src="../img/run.svg"/><str sid="14"></str></li>
        </ul>
        <ul id="window-controls">
          <li id="win-minimize"><img src="../img/win-minimize.svg"></li>
          <li id="win-restore"><img src="../img/win-restore.svg"></li>
          <li id="win-close"><img src="../img/win-close.svg"></li>
        </ul>
        <div id="app-title">JSLAB / EDITOR</div>
        <div class="clear"></div>
      </div>
    </div>
    <div class="tabs" style="--tab-content-margin: 9px">
      <div class="tabs-content"></div>
      <img id="new-tab" src="../img/new-tab.svg" />
      <img id="editor-more-icon" src="../img/more.svg" />
      <div class="tabs-bottom-bar"></div>
    </div>
    <div id="code"></div>
    <div id="close-dialog-cont">
      <div id="close-dialog">
        <div id="close-dialog-header">
          <span><str sid="47"></str></span>
        </div>
        <div id="close-dialog-msg">
          <str sid="48"></str> <span id="close-file"></span> <str sid="49"></str>
        </div>
        <div id="close-dialog-buttons">
          <button id="close-dialog-save"><str sid="50"></str></button>
          <button id="close-dialog-discard"><str sid="51"></str></button>
          <button id="close-dialog-cancel"><str sid="52"></str></button>
        </div>
        <br class="clear">
      </div>
    </div>

    <div id="editor-more-popup" style="display: none;">
      <ul>
        <li id="search-dialog-menu" title-str="169"><img src="../img/search-dialog.svg"/><str sid="168"></str></li>
        <li id="compile-dialog-menu" class="arduino" title-str="227"><img src="../img/compile-dialog.svg"/><str sid="227"></str></li>
        <li id="upload-dialog-menu" class="arduino" title-str="228"><img src="../img/upload-dialog.svg"/><str sid="228"></str></li>
      </ul>
      <div class="popup-triangle"></div>
    </div>
    
    <script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
    
    <script type="text/javascript" src="../lib/draggabilly-2.3.0/draggabilly-2.3.0.min.js"></script>
    <script type="text/javascript" src="../lib/PRDC_TABS/PRDC_TABS.js"></script>
    <script type="text/javascript" src="../lib/jshint-2.13.0/jshint-2.13.0.js"></script>
    
    <script type="text/javascript" src="../lib/codemirror-5.49.2/lib/codemirror.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/selection/active-line.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/foldcode.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/foldgutter.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/brace-fold.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/indent-fold.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/comment-fold.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/display/rulers.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/edit/matchbrackets.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/lint/lint.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/hint/show-hint.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/searchcursor.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/scroll/annotatescrollbar.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/matchesonscrollbar.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/jump-to-line.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/match-highlighter.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/comment/comment.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/mode/javascript/javascript.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/mode/clike/clike.js"></script>
    
    <script type="text/javascript" src="../js/code/custom-javascript-hint.js"></script>
    <script type="text/javascript" src="../js/code/dialog-search.js"></script>
    
    <script type="text/javascript" src="../lib/jquery-3.7.0/jquery-3.7.0.min.js"></script>
    
    <script type="text/javascript" src="../js/editor/init-editor.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={figure.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Figure - JSLAB | PR-DC</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
		<link rel="stylesheet" type="text/css" href="../css/figure.css" />
    <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
    <link rel="stylesheet" type="text/css" href="../font/LatinModern.css" />
    
    <style id="dynamic-style-rules"></style>
  </head>
  <body>
    <div id="figure-menu-button"><img src="../img/collapse.svg"/></div>
    <div id="figure-menu-container">
      <div id="figure-menu">
        <ul>
          <li id="save-as-menu" title-str="152"><img src="../img/save-as.svg"/><str sid="159"></str></li>
          <li id="zoom-menu" class="specific-2d" title-str="153"><img src="../img/zoom.svg"/><str sid="160"></str></li>
          <li id="pan-menu" class="specific-2d" title-str="154"><img src="../img/pan.svg"/><str sid="161"></str></li>
          <li id="rotate-menu" class="specific-2d" title-str="155"><img src="../img/rotate.svg"/><str sid="162"></str></li>
          <li id="zoom-in-menu" class="specific-2d" title-str="156"><img src="../img/zoom-in.svg"/><str sid="163"></str></li>
          <li id="zoom-out-menu" class="specific-2d" title-str="157"><img src="../img/zoom-out.svg"/><str sid="164"></str></li>
          <li id="fit-menu" class="specific-2d" title-str="158"><img src="../img/fit.svg"/><str sid="165"></str></li>
          <li id="reset-menu" class="specific-2d" title-str="158"><img src="../img/reset.svg"/><str sid="221"></str></li>
          <li id="pan-menu-3d" class="specific-3d" title-str="154"><img src="../img/pan.svg"/><str sid="161"></str></li>
          <li id="rotate-menu-3d" class="specific-3d" title-str="155"><img src="../img/rotate.svg"/><str sid="162"></str></li>
          <li id="fit-menu-3d" class="specific-3d" title-str="158"><img src="../img/fit.svg"/><str sid="165"></str></li>
          <li id="reset-menu-3d" class="specific-3d" title-str="158"><img src="../img/reset.svg"/><str sid="221"></str></li>
        </ul>
        <div class="clear"></div>
      </div>
    </div>
    <div id="figure-content">
    </div>
    
    <script type="text/javascript" src="../lib/plotly-2.24.2/plotly-2.24.2.min.js"></script>
    <script type="text/javascript" src="../js/windows/plot.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={html\_figure.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>%title%</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
    <style>
    html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}
    
    #figure-content {
      margin: 30px auto;
      position: relative;
      border: 1px solid #6f6f6f;
      box-shadow: 0px 0px 20px #c1c1c1;
    }
    
    #figure-header {
      background: #12568a;
      background: linear-gradient(to left, #2e85c7, #12568a);
      color: #fff;
      user-select: none;
      -webkit-user-drag: none;
      user-drag: none;
      max-height: 40px;
      overflow: hidden;
      transition: all .2s linear;
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
    }
    
    #jslab-logo svg {
      height: 30px;
      float: left;
      padding: 5px 10px;
      user-select: none;
      -webkit-user-drag: none;
      user-drag: none;
      width: 23px;
      background: #00000047;
    }
    
    #company-logo svg {
      filter: invert(1);
      height: 30px;
      float: left;
      padding: 5px;
      padding-left: 10px;
      user-select: none;
      -webkit-user-drag: none;
      user-drag: none;
      width: 54px;
    }
    
    #title {
      font-family: 'Helvetica';
      font-size: 20px;
      padding: 3px 10px;
      margin: 7px 0;
      float: left;
      font-weight: 400;
      opacity: 0.8;
      color: #ffffff;
      border-left: 2px solid #fff;
      margin-left: 5px;
    }
    
    #plot-cont {
      padding-top: 40px;
    }
    </style>
  </head>
  <body>
    <div id="figure-content">
      <div id="figure-header">
        <a href="https://pr-dc.com/jslab" title="JSLAB">
          <div id="jslab-logo">
            <svg
               version="1.1"
               viewBox="0 0 630 630"
               xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
               xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
               xmlns="http://www.w3.org/2000/svg"
               xmlns:svg="http://www.w3.org/2000/svg"
               xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
               xmlns:cc="http://creativecommons.org/ns#"
               xmlns:dc="http://purl.org/dc/elements/1.1/">
              <metadata
                 id="metadata12">
                <rdf:RDF>
                  <cc:Work
                     rdf:about="">
                    <dc:format>image/svg+xml</dc:format>
                    <dc:type
                       rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
                  </cc:Work>
                </rdf:RDF>
              </metadata>
              <defs
                 id="defs10" />
              <rect
                 id="background"
                 x="0"
                 y="0"
                 width="630"
                 height="630"
                 fill="#f7df1e"
                 rx="50"
                 ry="50" />
              <path
                 d="m 132.3099,593 c 42.69727,0 71.96556,-22.72597 71.96556,-72.65424 v -164.5911 h -48.2066 v 163.90243 c 0,24.1033 -9.98565,30.30129 -25.82496,30.30129 -16.52798,0 -23.41463,-11.36298 -30.989963,-24.79196 L 60,548.92539 C 71.362984,573.0287 93.744617,593 132.3099,593 Z"
                 style="font-size:341.94px;line-height:1.05;font-family:'Neutra Text';-inkscape-font-specification:'Neutra Text';word-spacing:0px;fill:#000000;fill-opacity:1;stroke-width:8.60834"
                 id="path850" />
              <path
                 d="m 318.24908,593 c 45.79626,0 79.88522,-23.75897 79.88522,-67.14491 0,-40.28695 -23.0703,-58.19225 -64.04591,-75.75323 l -12.05165,-5.16499 c -20.65997,-8.95266 -29.61263,-14.80631 -29.61263,-29.26829 0,-11.70732 8.95266,-20.65997 23.0703,-20.65997 13.77332,0 22.72597,5.85365 30.98996,20.65997 l 37.53228,-24.1033 C 368.17734,363.67432 346.14004,353 315.49441,353 c -43.0416,0 -70.58823,27.54663 -70.58823,63.70158 0,39.25394 23.0703,57.84791 57.84792,72.65422 l 12.05165,5.165 c 22.0373,9.64132 35.12195,15.49498 35.12195,32.02295 0,13.77332 -12.74032,23.75897 -32.71162,23.75897 -23.75897,0 -37.18795,-12.39598 -47.51793,-29.26829 L 230.4442,543.76039 C 244.56185,571.65136 273.48581,593 318.24908,593 Z"
                 style="font-size:341.94px;line-height:1.05;font-family:'Neutra Text';-inkscape-font-specification:'Neutra Text';word-spacing:0px;fill:#000000;fill-opacity:1;stroke-width:8.60834"
                 id="path852" />
              <path
                 d="M 435.66613,589.901 H 589.92724 V 547.54805 H 483.87273 V 355.75466 h -48.2066 z"
                 style="font-size:341.94px;line-height:1.05;font-family:'Neutra Text';-inkscape-font-specification:'Neutra Text';word-spacing:0px;fill:#000000;fill-opacity:1;stroke-width:8.60834"
                 id="path854" />
            </svg>
          </div>
        </a>
        <a href="https://pr-dc.com/" title="PR-DC Company">
          <div id="company-logo">
            <svg
               width="160mm"
               height="90mm"
               viewBox="0 0 160 90"
               version="1.1"
               id="svg869"
               xmlns="http://www.w3.org/2000/svg"
               xmlns:svg="http://www.w3.org/2000/svg"
               xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
               xmlns:cc="http://creativecommons.org/ns#"
               xmlns:dc="http://purl.org/dc/elements/1.1/">
              <defs
                 id="defs863" />
              <metadata
                 id="metadata866">
                <rdf:RDF>
                  <cc:Work
                     rdf:about="">
                    <dc:format>image/svg+xml</dc:format>
                    <dc:type
                       rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
                  </cc:Work>
                </rdf:RDF>
              </metadata>
              <g
                 id="layer1">
                <path
                   id="path847"
                   style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.999999px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
                   d="M 483.13281 17.101562 C 483.13281 17.101562 455.74781 17.701959 428.36328 17.615234 C 425.51072 17.606164 422.57229 17.604649 419.5625 17.613281 C 374.41441 17.745451 313.17548 18.456471 280.00586 28.585938 C 219.34388 47.111121 185.96586 73.091557 158.50391 103.79688 C 153.5363 109.42942 147.05989 117.97425 139.72266 128.92188 C 143.64779 137.54078 145.61523 147.65489 145.61523 159.27539 C 145.61523 172.166 143.27648 183.00438 138.59766 191.78906 C 133.91885 200.57382 127.9503 207.49589 120.69336 212.55664 C 113.5319 217.52192 106.22722 220.81618 98.779297 222.43945 C 95.807549 223.02819 92.396307 223.51965 88.642578 223.93555 C 75.710747 253.86377 63.915338 287.36997 55.78125 322.60352 L 449.07422 322.89844 C 452.91989 288.9274 456.14589 259.97604 459.13281 232.99414 C 454.31399 221.25319 451.90039 207.64528 451.90039 192.16211 C 451.90039 165.94179 458.11321 145.11257 470.5293 129.66602 C 474.28218 95.661149 478.18692 60.495264 483.13281 17.101562 z M 539.49609 115.06445 C 519.44401 115.06445 503.26564 121.67252 490.96094 134.88867 C 478.65626 148.03972 472.50391 166.52928 472.50391 190.35742 C 472.50391 212.88348 478.62368 230.65689 490.86328 243.67773 C 503.10285 256.63347 518.72784 263.11133 537.73828 263.11133 C 553.10287 263.11133 565.76562 259.33529 575.72656 251.7832 C 585.75262 244.16601 592.91407 232.54493 597.21094 216.91992 L 569.18359 208.0332 C 566.77472 218.51498 562.80339 226.19726 557.26953 231.08008 C 551.73567 235.96289 545.12761 238.4043 537.44531 238.4043 C 527.02866 238.4043 518.56513 234.56315 512.05469 226.88086 C 505.54427 219.19856 502.28906 206.30796 502.28906 188.20898 C 502.28906 171.15168 505.57682 158.81446 512.15234 151.19727 C 518.79297 143.58007 527.41927 139.77148 538.03125 139.77148 C 545.71354 139.77148 552.22394 141.91992 557.5625 146.2168 C 562.96614 150.51367 566.51431 156.37304 568.20703 163.79492 L 596.82031 156.95898 C 593.56511 145.50064 588.68231 136.71159 582.17188 130.5918 C 571.23438 120.24023 557.00914 115.06445 539.49609 115.06445 z M 14.216797 117.50586 L 14.216797 260.66992 L 43.123047 260.66992 L 43.123047 206.66602 L 61.970703 206.66602 C 75.05665 206.66602 85.050127 205.98242 91.951172 204.61523 C 97.0293 203.50846 102.00976 201.26237 106.89258 197.87695 C 111.8405 194.42643 115.9095 189.70638 119.09961 183.7168 C 122.28971 177.72721 123.88477 170.3379 123.88477 161.54883 C 123.88477 150.15559 121.11784 140.87826 115.58398 133.7168 C 110.05013 126.49023 103.18165 121.80273 94.978516 119.6543 C 89.639971 118.222 78.181651 117.50586 60.603516 117.50586 L 14.216797 117.50586 z M 157.9082 117.50586 L 218.74805 117.50586 C 234.04754 117.50586 245.14779 118.80794 252.04883 121.41211 C 259.01499 123.95116 264.58138 128.50844 268.74805 135.08398 C 272.91471 141.65949 274.99805 149.17908 274.99805 157.64258 C 274.99805 168.38479 271.84049 177.27149 265.52539 184.30273 C 259.21025 191.26886 249.77016 195.66342 237.20508 197.48633 C 243.45506 201.1321 248.59831 205.13606 252.63477 209.49805 C 256.73635 213.86 262.23763 221.60745 269.13867 232.74023 L 286.61914 260.66992 L 252.04883 260.66992 L 231.15039 229.51758 C 223.72849 218.38483 218.65039 211.38606 215.91602 208.52148 C 213.18164 205.59178 210.2845 203.60613 207.22461 202.56445 C 204.16471 201.45769 199.31446 200.9043 192.67383 200.9043 L 186.81445 200.9043 L 186.81445 260.66992 L 157.9082 260.66992 L 157.9082 117.50586 z M 322.95312 117.50586 L 375.78516 117.50586 C 387.69921 117.50586 396.78123 118.41729 403.03125 120.24023 C 411.4297 122.7142 418.62367 127.10873 424.61328 133.42383 C 430.60285 139.73889 435.16017 147.48634 438.28516 156.66602 C 441.41018 165.78061 442.97266 177.04361 442.97266 190.45508 C 442.97266 202.23893 441.50783 212.39517 438.57812 220.92383 C 434.99745 231.34047 429.88672 239.77153 423.24609 246.2168 C 418.23308 251.09964 411.46225 254.9082 402.93359 257.64258 C 396.55341 259.66081 388.02475 260.66992 377.34766 260.66992 L 322.95312 260.66992 L 322.95312 117.50586 z M 43.123047 141.72461 L 57.087891 141.72461 C 67.504562 141.72461 74.43815 142.05013 77.888672 142.70117 C 82.576175 143.54753 86.449868 145.66341 89.509766 149.04883 C 92.569664 152.43425 94.099609 156.73112 94.099609 161.93945 C 94.099609 166.17123 92.99284 169.88216 90.779297 173.07227 C 88.630857 176.26237 85.636071 178.60612 81.794922 180.10352 C 77.953775 181.60091 70.336597 182.34961 58.943359 182.34961 L 43.123047 182.34961 L 43.123047 141.72461 z M 186.81445 141.72461 L 186.81445 178.05273 L 208.20117 178.05273 C 222.06836 178.05273 230.72721 177.4668 234.17773 176.29492 C 237.62825 175.12304 240.33009 173.10485 242.2832 170.24023 C 244.23635 167.37565 245.21289 163.79492 245.21289 159.49805 C 245.21289 154.68032 243.91081 150.80665 241.30664 147.87695 C 238.76755 144.88217 235.15428 142.99412 230.4668 142.21289 C 228.12304 141.88747 221.0918 141.72461 209.37305 141.72461 L 186.81445 141.72461 z M 351.85938 141.72461 L 351.85938 236.54883 L 373.44141 236.54883 C 381.51433 236.54883 387.34115 236.09311 390.92188 235.18164 C 395.60935 234.00976 399.48306 232.02411 402.54297 229.22461 C 405.66796 226.42511 408.20709 221.8353 410.16016 215.45508 C 412.1133 209.00977 413.08984 200.25325 413.08984 189.18555 C 413.08984 178.11784 412.1133 169.62179 410.16016 163.69727 C 408.20709 157.77282 405.47267 153.15039 401.95703 149.83008 C 398.44139 146.50976 393.98179 144.26368 388.57812 143.0918 C 384.54168 142.18033 376.63151 141.72461 364.84766 141.72461 L 351.85938 141.72461 z M 275.35742 187.93945 L 311.72266 187.93945 L 311.72266 206.12305 L 275.35742 206.12305 L 275.35742 187.93945 z "
                   transform="scale(0.26458333)" />
                <g
                   aria-label="PR DC"
                   id="text865"
                   style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:52.9167px;line-height:1.25;font-family:arial;-inkscape-font-specification:arial;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.264583"
                   transform="translate(-26.307505,-2.9264341)" />
              </g>
            </svg>
          </div>
        </a>
        <div id="title">
          %title%
        </div>
      </div>
      <div id="plot-cont">
        <img id="figure" src="%image_source%">
      </div>
    </div>
    
    <script>
      window.onload = function () {
        var figure = document.getElementById('figure');
        document.getElementById('figure-content').style.width = figure.width + 'px';
      };
    </script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={i\_html\_figure.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>%title%</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
    <style>
    html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,hgroup,menu,nav,output,ruby,section,summary,time,mark,audio,video{border:0;font-size:100%;font:inherit;vertical-align:baseline;margin:0;padding:0}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:none}table{border-collapse:collapse;border-spacing:0}
    
    #figure-content {
      margin: 30px auto;
      position: relative;
      border: 1px solid #6f6f6f;
      box-shadow: 0px 0px 20px #c1c1c1;
      width: max-content;
    }
    
    #figure-header {
      background: #12568a;
      background: linear-gradient(to left, #2e85c7, #12568a);
      color: #fff;
      user-select: none;
      -webkit-user-drag: none;
      user-drag: none;
      max-height: 40px;
      overflow: hidden;
      transition: all .2s linear;
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
    }
    
    #jslab-logo svg {
      height: 30px;
      float: left;
      padding: 5px 10px;
      user-select: none;
      -webkit-user-drag: none;
      user-drag: none;
      width: 23px;
      background: #00000047;
    }
    
    #company-logo svg {
      filter: invert(1);
      height: 30px;
      float: left;
      padding: 5px;
      padding-left: 10px;
      user-select: none;
      -webkit-user-drag: none;
      user-drag: none;
      width: 54px;
    }
    
    #title {
      font-family: 'Helvetica';
      font-size: 20px;
      padding: 3px 10px;
      margin: 7px 0;
      float: left;
      font-weight: 400;
      opacity: 0.8;
      color: #ffffff;
      border-left: 2px solid #fff;
      margin-left: 5px;
    }
    
    #plot-cont {
      padding-top: 40px;
    }
    </style>
  </head>
  <body>
    <div id="figure-content">
      <div id="figure-header">
        <a href="https://pr-dc.com/jslab" title="JSLAB">
          <div id="jslab-logo">
            <svg
               version="1.1"
               viewBox="0 0 630 630"
               xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"
               xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd"
               xmlns="http://www.w3.org/2000/svg"
               xmlns:svg="http://www.w3.org/2000/svg"
               xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
               xmlns:cc="http://creativecommons.org/ns#"
               xmlns:dc="http://purl.org/dc/elements/1.1/">
              <metadata
                 id="metadata12">
                <rdf:RDF>
                  <cc:Work
                     rdf:about="">
                    <dc:format>image/svg+xml</dc:format>
                    <dc:type
                       rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
                  </cc:Work>
                </rdf:RDF>
              </metadata>
              <defs
                 id="defs10" />
              <rect
                 id="background"
                 x="0"
                 y="0"
                 width="630"
                 height="630"
                 fill="#f7df1e"
                 rx="50"
                 ry="50" />
              <path
                 d="m 132.3099,593 c 42.69727,0 71.96556,-22.72597 71.96556,-72.65424 v -164.5911 h -48.2066 v 163.90243 c 0,24.1033 -9.98565,30.30129 -25.82496,30.30129 -16.52798,0 -23.41463,-11.36298 -30.989963,-24.79196 L 60,548.92539 C 71.362984,573.0287 93.744617,593 132.3099,593 Z"
                 style="font-size:341.94px;line-height:1.05;font-family:'Neutra Text';-inkscape-font-specification:'Neutra Text';word-spacing:0px;fill:#000000;fill-opacity:1;stroke-width:8.60834"
                 id="path850" />
              <path
                 d="m 318.24908,593 c 45.79626,0 79.88522,-23.75897 79.88522,-67.14491 0,-40.28695 -23.0703,-58.19225 -64.04591,-75.75323 l -12.05165,-5.16499 c -20.65997,-8.95266 -29.61263,-14.80631 -29.61263,-29.26829 0,-11.70732 8.95266,-20.65997 23.0703,-20.65997 13.77332,0 22.72597,5.85365 30.98996,20.65997 l 37.53228,-24.1033 C 368.17734,363.67432 346.14004,353 315.49441,353 c -43.0416,0 -70.58823,27.54663 -70.58823,63.70158 0,39.25394 23.0703,57.84791 57.84792,72.65422 l 12.05165,5.165 c 22.0373,9.64132 35.12195,15.49498 35.12195,32.02295 0,13.77332 -12.74032,23.75897 -32.71162,23.75897 -23.75897,0 -37.18795,-12.39598 -47.51793,-29.26829 L 230.4442,543.76039 C 244.56185,571.65136 273.48581,593 318.24908,593 Z"
                 style="font-size:341.94px;line-height:1.05;font-family:'Neutra Text';-inkscape-font-specification:'Neutra Text';word-spacing:0px;fill:#000000;fill-opacity:1;stroke-width:8.60834"
                 id="path852" />
              <path
                 d="M 435.66613,589.901 H 589.92724 V 547.54805 H 483.87273 V 355.75466 h -48.2066 z"
                 style="font-size:341.94px;line-height:1.05;font-family:'Neutra Text';-inkscape-font-specification:'Neutra Text';word-spacing:0px;fill:#000000;fill-opacity:1;stroke-width:8.60834"
                 id="path854" />
            </svg>
          </div>
        </a>
        <a href="https://pr-dc.com/" title="PR-DC Company">
          <div id="company-logo">
            <svg
               width="160mm"
               height="90mm"
               viewBox="0 0 160 90"
               version="1.1"
               id="svg869"
               xmlns="http://www.w3.org/2000/svg"
               xmlns:svg="http://www.w3.org/2000/svg"
               xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
               xmlns:cc="http://creativecommons.org/ns#"
               xmlns:dc="http://purl.org/dc/elements/1.1/">
              <defs
                 id="defs863" />
              <metadata
                 id="metadata866">
                <rdf:RDF>
                  <cc:Work
                     rdf:about="">
                    <dc:format>image/svg+xml</dc:format>
                    <dc:type
                       rdf:resource="http://purl.org/dc/dcmitype/StillImage" />
                  </cc:Work>
                </rdf:RDF>
              </metadata>
              <g
                 id="layer1">
                <path
                   id="path847"
                   style="fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.999999px;stroke-linecap:butt;stroke-linejoin:miter;stroke-opacity:1"
                   d="M 483.13281 17.101562 C 483.13281 17.101562 455.74781 17.701959 428.36328 17.615234 C 425.51072 17.606164 422.57229 17.604649 419.5625 17.613281 C 374.41441 17.745451 313.17548 18.456471 280.00586 28.585938 C 219.34388 47.111121 185.96586 73.091557 158.50391 103.79688 C 153.5363 109.42942 147.05989 117.97425 139.72266 128.92188 C 143.64779 137.54078 145.61523 147.65489 145.61523 159.27539 C 145.61523 172.166 143.27648 183.00438 138.59766 191.78906 C 133.91885 200.57382 127.9503 207.49589 120.69336 212.55664 C 113.5319 217.52192 106.22722 220.81618 98.779297 222.43945 C 95.807549 223.02819 92.396307 223.51965 88.642578 223.93555 C 75.710747 253.86377 63.915338 287.36997 55.78125 322.60352 L 449.07422 322.89844 C 452.91989 288.9274 456.14589 259.97604 459.13281 232.99414 C 454.31399 221.25319 451.90039 207.64528 451.90039 192.16211 C 451.90039 165.94179 458.11321 145.11257 470.5293 129.66602 C 474.28218 95.661149 478.18692 60.495264 483.13281 17.101562 z M 539.49609 115.06445 C 519.44401 115.06445 503.26564 121.67252 490.96094 134.88867 C 478.65626 148.03972 472.50391 166.52928 472.50391 190.35742 C 472.50391 212.88348 478.62368 230.65689 490.86328 243.67773 C 503.10285 256.63347 518.72784 263.11133 537.73828 263.11133 C 553.10287 263.11133 565.76562 259.33529 575.72656 251.7832 C 585.75262 244.16601 592.91407 232.54493 597.21094 216.91992 L 569.18359 208.0332 C 566.77472 218.51498 562.80339 226.19726 557.26953 231.08008 C 551.73567 235.96289 545.12761 238.4043 537.44531 238.4043 C 527.02866 238.4043 518.56513 234.56315 512.05469 226.88086 C 505.54427 219.19856 502.28906 206.30796 502.28906 188.20898 C 502.28906 171.15168 505.57682 158.81446 512.15234 151.19727 C 518.79297 143.58007 527.41927 139.77148 538.03125 139.77148 C 545.71354 139.77148 552.22394 141.91992 557.5625 146.2168 C 562.96614 150.51367 566.51431 156.37304 568.20703 163.79492 L 596.82031 156.95898 C 593.56511 145.50064 588.68231 136.71159 582.17188 130.5918 C 571.23438 120.24023 557.00914 115.06445 539.49609 115.06445 z M 14.216797 117.50586 L 14.216797 260.66992 L 43.123047 260.66992 L 43.123047 206.66602 L 61.970703 206.66602 C 75.05665 206.66602 85.050127 205.98242 91.951172 204.61523 C 97.0293 203.50846 102.00976 201.26237 106.89258 197.87695 C 111.8405 194.42643 115.9095 189.70638 119.09961 183.7168 C 122.28971 177.72721 123.88477 170.3379 123.88477 161.54883 C 123.88477 150.15559 121.11784 140.87826 115.58398 133.7168 C 110.05013 126.49023 103.18165 121.80273 94.978516 119.6543 C 89.639971 118.222 78.181651 117.50586 60.603516 117.50586 L 14.216797 117.50586 z M 157.9082 117.50586 L 218.74805 117.50586 C 234.04754 117.50586 245.14779 118.80794 252.04883 121.41211 C 259.01499 123.95116 264.58138 128.50844 268.74805 135.08398 C 272.91471 141.65949 274.99805 149.17908 274.99805 157.64258 C 274.99805 168.38479 271.84049 177.27149 265.52539 184.30273 C 259.21025 191.26886 249.77016 195.66342 237.20508 197.48633 C 243.45506 201.1321 248.59831 205.13606 252.63477 209.49805 C 256.73635 213.86 262.23763 221.60745 269.13867 232.74023 L 286.61914 260.66992 L 252.04883 260.66992 L 231.15039 229.51758 C 223.72849 218.38483 218.65039 211.38606 215.91602 208.52148 C 213.18164 205.59178 210.2845 203.60613 207.22461 202.56445 C 204.16471 201.45769 199.31446 200.9043 192.67383 200.9043 L 186.81445 200.9043 L 186.81445 260.66992 L 157.9082 260.66992 L 157.9082 117.50586 z M 322.95312 117.50586 L 375.78516 117.50586 C 387.69921 117.50586 396.78123 118.41729 403.03125 120.24023 C 411.4297 122.7142 418.62367 127.10873 424.61328 133.42383 C 430.60285 139.73889 435.16017 147.48634 438.28516 156.66602 C 441.41018 165.78061 442.97266 177.04361 442.97266 190.45508 C 442.97266 202.23893 441.50783 212.39517 438.57812 220.92383 C 434.99745 231.34047 429.88672 239.77153 423.24609 246.2168 C 418.23308 251.09964 411.46225 254.9082 402.93359 257.64258 C 396.55341 259.66081 388.02475 260.66992 377.34766 260.66992 L 322.95312 260.66992 L 322.95312 117.50586 z M 43.123047 141.72461 L 57.087891 141.72461 C 67.504562 141.72461 74.43815 142.05013 77.888672 142.70117 C 82.576175 143.54753 86.449868 145.66341 89.509766 149.04883 C 92.569664 152.43425 94.099609 156.73112 94.099609 161.93945 C 94.099609 166.17123 92.99284 169.88216 90.779297 173.07227 C 88.630857 176.26237 85.636071 178.60612 81.794922 180.10352 C 77.953775 181.60091 70.336597 182.34961 58.943359 182.34961 L 43.123047 182.34961 L 43.123047 141.72461 z M 186.81445 141.72461 L 186.81445 178.05273 L 208.20117 178.05273 C 222.06836 178.05273 230.72721 177.4668 234.17773 176.29492 C 237.62825 175.12304 240.33009 173.10485 242.2832 170.24023 C 244.23635 167.37565 245.21289 163.79492 245.21289 159.49805 C 245.21289 154.68032 243.91081 150.80665 241.30664 147.87695 C 238.76755 144.88217 235.15428 142.99412 230.4668 142.21289 C 228.12304 141.88747 221.0918 141.72461 209.37305 141.72461 L 186.81445 141.72461 z M 351.85938 141.72461 L 351.85938 236.54883 L 373.44141 236.54883 C 381.51433 236.54883 387.34115 236.09311 390.92188 235.18164 C 395.60935 234.00976 399.48306 232.02411 402.54297 229.22461 C 405.66796 226.42511 408.20709 221.8353 410.16016 215.45508 C 412.1133 209.00977 413.08984 200.25325 413.08984 189.18555 C 413.08984 178.11784 412.1133 169.62179 410.16016 163.69727 C 408.20709 157.77282 405.47267 153.15039 401.95703 149.83008 C 398.44139 146.50976 393.98179 144.26368 388.57812 143.0918 C 384.54168 142.18033 376.63151 141.72461 364.84766 141.72461 L 351.85938 141.72461 z M 275.35742 187.93945 L 311.72266 187.93945 L 311.72266 206.12305 L 275.35742 206.12305 L 275.35742 187.93945 z "
                   transform="scale(0.26458333)" />
                <g
                   aria-label="PR DC"
                   id="text865"
                   style="font-style:normal;font-variant:normal;font-weight:normal;font-stretch:normal;font-size:52.9167px;line-height:1.25;font-family:arial;-inkscape-font-specification:arial;letter-spacing:0px;word-spacing:0px;fill:#000000;fill-opacity:1;stroke:none;stroke-width:0.264583"
                   transform="translate(-26.307505,-2.9264341)" />
              </g>
            </svg>
          </div>
        </a>
        <div id="title">
          %title%
        </div>
      </div>
      <div id="plot-cont"></div>
    </div>
    <script src="https://cdn.plot.ly/plotly-2.24.2.min.js"></script>
    <script>
      var figure = %figure_data%;
      Plotly.newPlot('plot-cont', figure);
    </script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={leaflet.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Leaflet Plot - JSLAB | PR-DC</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
		<link rel="stylesheet" type="text/css" href="../css/basic.css" />
    <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
    <link rel="stylesheet" type="text/css" href="../font/LatinModern.css" />
    <link rel="stylesheet" type="text/css" href="../lib/leaflet-1.9.4/leaflet.css" />
    
    <style id="dynamic-style-rules"></style>
  </head>
  <body>
    <div id="map-cont"></div>
    
    <script type="text/javascript" src="../lib/leaflet-1.9.4/leaflet.js"></script>
    <script type="text/javascript" src="../lib/leaflet.rotatedMarker-0.2.0/leaflet.rotatedMarker.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={main.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>JSLAB | PR-DC</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
    <link rel="stylesheet" type="text/css" href="../css/codemirror-notepadpp-theme.css">
    <link rel="stylesheet" type="text/css" href="../css/highlight-notepadpp-theme.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/addon/lint/lint.css">
    <link rel="stylesheet" type="text/css" href="../css/big-json-viewer-notepadpp-theme.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/addon/hint/show-hint.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/lib/codemirror.css">
    <link rel="stylesheet" type="text/css" href="../css/codemirror-main-custom.css">
		<link type="text/css" rel="stylesheet" href="../css/main.css" />
    <link type="text/css" rel="stylesheet" href="../css/terminal.css" />
    <link type="text/css" rel="stylesheet" href="../font/roboto.css" />
    <link type="text/css" rel="stylesheet" href="../font/RobotoMono.css" />
    
    <style id="dynamic-style-rules"></style>
  </head>
  <body>
    <div id="main-menu-container">
      <div>
        <img id="app-logo" src="../img/JSLAB.svg"/>
        <img id="company-logo" src="../img/PR-DC_icon.svg"/>
        <ul id="main-menu">
          <li id="editor-menu"><img src="../img/editor.svg"/><str sid="1"></str></li>
          <li id="help-menu"><img src="../img/help.svg"/><str sid="2"></str></li>
          <li id="info-menu"><img src="../img/info.svg"/><str sid="3"></str></li>
          <li id="settings-menu"><img src="../img/settings-menu.svg"/><str sid="9"></str></li>
        </ul>
        <ul id="window-controls">
          <li id="win-minimize"><img src="../img/win-minimize.svg"></li>
          <li id="win-restore"><img src="../img/win-restore.svg"></li>
          <li id="win-close"><img src="../img/win-close.svg"></li>
        </ul>
        <div id="app-title">JSLAB / MAIN</div>
        <div class="clear"></div>
      </div>
    </div>

    <div id="folder-navigation-container">
      <div class="button float-left previous-folder disabled"><img src="../img/arrow.svg" title-str="31"/></div>
      <div class="button float-left next-folder disabled"><img src="../img/arrow.svg" title-str="32"/></div>
      <div class="button float-left up-folder disabled"><img src="../img/arrow.svg" title-str="33"/></div>
      <div class="button float-left open-folder"><img src="../img/open-folder.svg" title-str="34"/></div>
      <div class="address-line-container">
        <div class="folder-icon"><img src="../img/folder.svg"/></div>
        <div class="folder-address">
        <input class="address-line float-left" value="C:/Electron/JSLAB">
        <div class="current-address-cont">
          <div class="current-address-wrap">
            <div class="current-address">
              <span class="folder">Local Disk (C:)</span>
              <i class="i-next-folder"></i>
              <span class="folder">Electron</span>
              <i class="i-next-folder"></i>
              <span class="folder">JSLAB</span>
            </div>
          </div>
        </div>
        <div id="save-path"><i title-str="35"/></i></div>
        </div>
      </div>
      <div class="button float-right" id="paths-menu"><img src="../img/more.svg" title-str="36"/></div>
      <div class="clear"></div>
    </div>

    <div id="panels-container">
      <div id="left-panel">
        <div id="left-top-panel">
          <div class="cell-padding">
            <div class="panel-container">
              <div class="panel-title"><str sid="4"></str></div>
              
              <div id="file-browser-options" class="options">
                <div class="options-right">
                  <i class="refresh" title-str="37"></i>
                </div>
              </div>
              
              <div id="file-browser" class="panel">
                <div id="file-browser-cont"></div>
              </div>
            </div>
          </div>
        </div>

        <div id="left-middle-panel" >
          <div class="cell-padding">
            <div class="panel-container">
              <div class="panel-title"><str sid="5"></str></div>
              
              <div id="workspace-options" class="options">
                <div class="options-right">
                  <i class="clear" title-str="38"></i>
                </div>
              </div>
              
              <div id="workspace-table-head">
                <div class="row">
                  <div class="col col-1"><str sid="53"></str></div>
                  <div class="col col-2"><str sid="54"></str></div>
                  <div class="col col-3"><str sid="55"></str></div>
                </div>
              </div>
              
              <div id="workspace" class="panel">
                <div class="table"></div>
              </div>
            </div>
          </div>
        </div>

        <div id="left-bottom-panel">
          <div class="cell-padding">
            <div class="panel-container">
              <div class="panel-title"><str sid="6"></str></div>
              
              <div id="command-history-options" class="options">
                <div class="options-right">
                  <i class="clear" title-str="39"></i>
                </div>
              </div>
            
              <div id="command-history" class="panel">
          
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="right-panel">
        <div class="cell-padding">
          <div class="panel-container">
            <div class="panel-title"><str sid="7"></str></div>

            <div id="command-window-options" class="options">
              <div class="options-right">
                <i class="settings" title-str="40"></i>
                <i class="timestamp" title-str="41"></i>
                <i class="autoscroll active" title-str="42"></i>
                <i class="clear" title-str="43"></i>
                <i class="log" title-str="44"></i>
                <i class="to-bottom" title-str="45"></i>
              </div>
            </div>

            <div id="command-window" class="terminal-panel panel">
              <div id="command-window-messages" class="messages no-timestamp"></div>

              <div id="command-window-input-container">
                <div id="command-window-input-submit-cont">
                  <img src="../img/enter.svg" title-str="226">
                </div>
                <textarea id="command-window-input">cmd_help;</textarea>
              </div>
            </div>

            <div id="command-window-settings" class="terminal-dialog terminal-settings options-panel panel" tabindex="0">
              <div class="options-cont">
                <div class="options-header"><span><str sid="56"></str></span>
                <img class="options-close" src="../img/close.svg" title-str="46">
               </div>
               <div class="float-input" title-str="17">
                <input autocomplete="off" type="text" name="N-messages-max" class="N-messages-max" placeholder="Infinity" value="">
                <label class="float-label" for="N-messages-max"><str sid="17"></str></label>
               </div>
               <button class="change-settings"><str sid="57"></str></button>
              </div>
            </div>

            <div id="command-window-log" class="terminal-dialog terminal-log options-panel panel" tabindex="0">
              <div class="options-cont">
                <div class="options-header">
                  <span><str sid="58"></str></span>
                  <img class="options-close" src="../img/close.svg" title-str="18">
                </div>
                <label class="checkcont"><str sid="59"></str><input class="write-timestamps" type="checkbox" name="write-timestamps" value="1" checked><span class="checkmark"></span></label>
                <button class="save-log"><str sid="60"></str></button>
              </div>
            </div>

            <div id="command-window-history" class="terminal-dialog history-cont" tabindex="0">
            <div class="history-header">
              <span><str sid="61"></str></span>
              <img class="history-close" src="../img/close.svg" title-str="19">
            </div>
            <ul class="history-panel panel" tabindex="0">
            </ul>
         </div>
          </div>
        </div>
      </div>
    </div>

    <div id="script-path-container" class="main-dialog" tabindex="0">
      <div class="page-cont">
        <div class="page-header">
          <img id="script-path-close" class="page-close" src="../img/close.svg" title-str="20">
          <span><str sid="62"></str></span>
        </div>
        <div class="page-panel panel">
          <div id="script-path-dialog-msg">
            <str sid="63"></str> <span id="script-path"></span> <str sid="64"></str>
          </div>
          <div id="script-path-dialog-buttons">
            <button id="script-path-dialog-change-dir"><str sid="65"></str></button>
            <button id="script-path-dialog-save"><str sid="66"></str></button>
            <button id="script-path-dialog-run"><str sid="67"></str></button>
          </div>
          <br class="clear">
        </div>
      </div>
    </div>
    
    <div id="paths-container" class="main-dialog" tabindex="0">
      <div class="page-cont wide">
        <div class="page-header">
          <span><str sid="68"></str></span>
          <img id="paths-close" class="page-close" src="../img/close.svg" title-str="21">
        </div>
        <div class="page-panel panel">
          <ul></ul>
        </div>
      </div>
    </div>
    
    <div id="help-container" class="main-dialog" tabindex="0">
      <div class="page-cont wide">
        <div class="page-header">
          <span><str sid="2"></str></span>
          <img id="help-close" class="page-close" src="../img/close.svg" title-str="22">
        </div>
        <div class="page-panel panel">
            <h1><str sid="69"></str></h1>
            <table style="width:100%">
              <tr>
                <th><str sid="70"></str></th>
                <th><str sid="71"></str></th>
              </tr>
              <tr>
                <td>ESC</td>
                <td><str sid="72"></str></td>
              </tr>
              <tr>
                <td>Arrow Up</td>
                <td><str sid="73"></str></td>
              </tr>
              <tr>
                <td>Arrow Down</td>
                <td><str sid="74"></str></td>
              </tr>
              <tr>
                <td>Page Up</td>
                <td><str sid="75"></str></td>
              </tr>
              <tr>
                <td>Page Down</td>
                <td><str sid="76"></str></td>
              </tr>
              <tr>
                <td>Shift + Enter</td>
                <td><str sid="77"></str></td>
              </tr>
              <tr>
                <td>F3</td>
                <td><str sid="78"></str></td>
              </tr>
              <tr>
                <td>F7</td>
                <td><str sid="79"></str></td>
              </tr>
              <tr>
                <td>Alt + F7</td>
                <td><str sid="80"></str></td>
              </tr>
              <tr>
                <td>F8</td>
                <td><str sid="81"></str></td>
              </tr>
              <tr>
                <td>Ctrl + F</td>
                <td><str sid="82"></str></td>
              </tr>
              <tr>
                <td>Ctrl + H</td>
                <td><str sid="83"></str></td>
              </tr>
              <tr>
                <td>Ctrl + D</td>
                <td><str sid="219"></str></td>
              </tr>
              <tr>
                <td>Ctrl + S</td>
                <td><str sid="84"></str></td>
              </tr>
              <tr>
                <td>Ctrl + L</td>
                <td><str sid="85"></str></td>
              </tr>
            </table>
        </div>
      </div>
    </div>

    <div id="info-container" class="main-dialog" tabindex="0">
      <div class="page-cont panel">
        <div class="page-header">
          <span><str sid="3"></str></span>
          <img id="info-close" class="page-close" src="../img/close.svg" title-str="23">
        </div>
        <div class="page-panel panel">
          <img class="app-logo" src="../img/JSLAB.svg">
          <div class='app-name'>JavaScript LABoratory</div>
          <div class='app-version'></div>
          <div class='app-company'>by PR-DC company</div>
          <img class="company-logo" src="../img/PR-DC_icon.svg">

          <p><str sid="86"></str></p>
          <ul>
            <li><a href="https://www.electronjs.org/">Electron</a></li>
            <li><a href="https://codemirror.net/">CodeMirror</a></li>
            <li><a href="https://jquery.com/">JQuery</a></li>
            <li><a href="https://github.com/adamschwartz/chrome-tabs">chrome-tabs</a></li>
            <li><a href="https://plotly.com/javascript/">Plotly.js</a></li>
            <li><a href="https://mathjs.org/">Math.js</a></li>
            <li><a href="https://www.mathjax.org/">MathJax</a></li>
            <li><a href="https://highlightjs.org/">highlight.js</a></li>
            <li><a href="https://github.com/dhcode/big-json-viewer/">big-json-viewer</a></li>
            <li><a href="https://threejs.org/">Three.js</a></li>
            <li><a href="https://pyodide.org/en/stable/">pyodide</a></li>
            <li><a href="https://www.sympy.org/en/index.html">SymPy</a></li>
            <li><a href="https://www.cgal.org/">CGAL</a></li>
            <li><a href="https://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen</a></li>
            <li><a href="https://github.com/benfred/fmin">fmin</a></li>
            <li><a href="https://github.com/mozilla/pdf.js">PDF.js</a></li>
            <li><a href="https://html2canvas.hertzen.com/">html2canvas</a></li>
          </ul>  
        </div>
      </div>
    </div>

    <div id="settings-container" class="main-dialog" tabindex="0">
      <div class="page-cont options-cont panel">
        <div class="page-header">
          <span><str sid="9"></str></span>
          <img id="settings-close" class="page-close" src="../img/close.svg" title-str="24">
        </div>
        <div class="page-panel panel">
          <div class="float-select" title-str="25">
            <select name="set-langauge" class="set-langauge">
              <option value="en">English</option>
              <option value="rs">Srpski</option>
              <option value="rsc">Српски</option>
            </select>
            <label class="float-label" for="set-langauge"><str sid="16"></str></label>
          </div>
          <div class="float-input" title-str="223">
            <input autocomplete="off" type="text" name="N-history-max" class="N-history-max" placeholder="20" value="20">
            <label class="float-label" for="N-history-max"><str sid="223"></str></label>
          </div>
          <button class="change-settings"><str sid="57"></str></button>
        </div>
      </div>
    </div>
    
    <div id="sandbox-stats-popup" style="display: none;">
      <div id="sandbox-stats-header">
        <str sid="91"></str>
      </div>
      <div class="sandbox-stats-cont">
        Required modules
        <div class="sandbox-stats-val" id="sandbox-required-modules-num">0</div>
      </div>
      <div class="sandbox-stats-cont">
        Promises
        <div class="sandbox-stats-val" id="sandbox-promises-num">0</div>
      </div>
      <div class="sandbox-stats-cont">
        Timeouts
        <div class="sandbox-stats-val" id="sandbox-timeouts-num">0</div>
      </div>
      <div class="sandbox-stats-cont">
        Immediates
        <div class="sandbox-stats-val" id="sandbox-immediates-num">0</div>
      </div>
      <div class="sandbox-stats-cont">
        Intervals
        <div class="sandbox-stats-val" id="sandbox-intervals-num">0</div>
      </div>
      <div class="sandbox-stats-cont">
        Animation frames
        <div class="sandbox-stats-val" id="sandbox-animation-frames-num">0</div>
      </div>
      <div class="sandbox-stats-cont">
        Idle callbacks
        <div class="sandbox-stats-val" id="sandbox-idle-callbacks-num">0</div>
      </div>
      <div class="popup-triangle"></div>
    </div>
    
    <div id="status-container">
      <div id="sandbox-stats-icon" class="ready"></div>
      
      <div id="status">
        <str sid="87"></str>
      </div>
      <div id="status-icons">

      </div>
    </div>
    <script>if(typeof module === 'object') {window.module = module; module = undefined;}</script>
    
    <script type="text/javascript" src="../lib/jquery-3.7.0/jquery-3.7.0.min.js"></script>
    <script type="text/javascript" src="../lib/jshint-2.13.0/jshint-2.13.0.js"></script>
    <script type="text/javascript" src="../lib/highlight-11.0.1/highlight-11.0.1.min.js"></script>
    <script type="text/javascript" src="../lib/tex-mml-chtml-3.2.0/tex-mml-chtml-3.2.0.js"></script>
    
    <script type="text/javascript" src="../lib/codemirror-5.49.2/lib/codemirror.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/edit/matchbrackets.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/lint/lint.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/hint/show-hint.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/searchcursor.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/match-highlighter.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/mode/javascript/javascript.js"></script>
    
    <script type="text/javascript" src="../js/code/custom-javascript-hint.js"></script>
    
    <script type="text/javascript" src="../js/main/init-main.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={mermaid\_graph.html}]
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Graph - JSLAB | PR-DC</title>
  <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
  <link rel="stylesheet" type="text/css" href="../css/basic.css" />
  <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
  <link rel="stylesheet" type="text/css" href="../font/LatinModern.css" />
  <link rel="stylesheet" type="text/css" href="../css/svg-viewer.css" />
  <link rel="stylesheet" type="text/css" href="../css/mermaid-graph.css" />
  <style id="custom-style"></style>
</head>
<body>
  <div id="graph" class="graph mermaid prdc-svg-viewer no-layers"></div>
  
  <script>if(typeof module === 'object') {window.module = module; module = undefined;}</script>
  <script type="text/javascript" src="../lib/jquery-3.7.0/jquery-3.7.0.min.js"></script>
  <script type="text/javascript" src="../lib/jstree-3.3.17/jstree-3.3.17.min.js"></script>
  <script type="text/javascript" src="../lib/d3-7.8.5/d3-7.8.5.min.js"></script>
  <script type="text/javascript" src="../lib/PRDC_SVG_VIEWER/PRDC_SVG_VIEWER.js"></script>
  <script type="text/javascript" src="../lib/mermaid-11.4.1/mermaid-11.4.1.min.js"></script>
  
  <script type="module">
    mermaid.initialize({ 
      flowchart: {
        useMaxWidth: false,
        rankSpacing: 300
      },
      startOnLoad: false,
      securityLevel: 'loose'
    });
  </script>
</body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={plotlyjs.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Plotlyjs Plot - JSLAB | PR-DC</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
		<link rel="stylesheet" type="text/css" href="../css/basic.css" />
    <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
    <link rel="stylesheet" type="text/css" href="../font/LatinModern.css" />
    
    <style id="dynamic-style-rules"></style>
  </head>
  <body>
    <div id="plot-cont"></div>
    
    <script type="text/javascript" src="../lib/plotly-2.24.2/plotly-2.24.2.min.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={presentation-editor.html}]
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <title>Presentation editor - JSLAB | PR-DC</title>
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
    <link rel="stylesheet" type="text/css" href="../css/tabs.css">
    <link rel="stylesheet" type="text/css" href="../css/codemirror-notepadpp-theme.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/addon/fold/foldgutter.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/addon/lint/lint.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/addon/hint/show-hint.css">
    <link rel="stylesheet" type="text/css" href="../lib/codemirror-5.49.2/lib/codemirror.css">
    <link rel="stylesheet" type="text/css" href="../css/codemirror-presentation-editor-custom.css">
		<link rel="stylesheet" type="text/css" href="../css/presentation-editor.css" />
    <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
    
    <style id="dynamic-style-rules"></style>
  </head>
  <body>
    <div id="left-panel">
      <div class="cell-padding">
        <div class="panel-container">
          <div class="panel-title"><str sid="242"></str></div>
          
          <div id="left-panel-cont">
            <div id="presentation-title"></div>
            <div id="webview-wrap">
              <webview id="preview" useragent="presentation-editor-preview" nodeintegration webpreferences="backgroundThrottling=no, contextIsolation=no"></webview>
            </div>
            <div id="slide-controls">
              <div id="first-slide" class="button" title="First slide">⏮</div>
              <div id="prev-slide" class="button" title="Previous">⏴</div>
              <input id="set-slide" type="number" min="1" step="1">
              <span id="total-slides">/ 0</span>
              <div id="next-slide" class="button" title="Next">⏵</div>
              <div id="last-slide" class="button" title="Last slide">⏭</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="right-panel">
      <div class="cell-padding">
        <div class="panel-container">
          <div class="panel-title"><str sid="243"></str></div>
          
          <div id="right-panel-cont">
            <div class="tabs" style="--tab-content-margin: 9px">
              <div class="tabs-content"></div>
              <img id="tab-save" src="../img/tab-save.svg" />
              <img id="editor-more-icon" src="../img/more.svg" />
              <div class="tabs-bottom-bar"></div>
            </div>
            <div id="code"></div>
            
            <div id="editor-more-popup" style="display: none;">
              <ul>
                <li id="search-dialog-menu" title-str="169"><img src="../img/search-dialog.svg"/><str sid="168"></str></li>
                <li id="fold-slides"><img src="../img/fold-code.svg"/><str sid="245"></str></li>
                <li id="unfold-slides"><img src="../img/unfold-code.svg"/><str sid="246"></str></li>
              </ul>
              <div class="popup-triangle"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <script>if (typeof module === 'object') {window.module = module; module = undefined;}</script>
    
    <script type="text/javascript" src="../lib/draggabilly-2.3.0/draggabilly-2.3.0.min.js"></script>
    <script type="text/javascript" src="../lib/PRDC_TABS/PRDC_TABS.js"></script>
    <script type="text/javascript" src="../lib/jshint-2.13.0/jshint-2.13.0.js"></script>
    
    <script type="text/javascript" src="../lib/codemirror-5.49.2/lib/codemirror.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/selection/active-line.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/foldcode.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/foldgutter.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/xml-fold.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/brace-fold.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/indent-fold.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/fold/comment-fold.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/display/rulers.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/edit/matchbrackets.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/lint/lint.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/hint/show-hint.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/searchcursor.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/scroll/annotatescrollbar.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/matchesonscrollbar.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/jump-to-line.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/search/match-highlighter.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/comment/comment.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/mode/xml/xml.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/mode/css/css.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/mode/javascript/javascript.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/mode/htmlmixed/htmlmixed.js"></script>
    
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/hint/xml-hint.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/hint/javascript-hint.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/hint/css-hint.js"></script>
    <script type="text/javascript" src="../lib/codemirror-5.49.2/addon/hint/html-hint.js"></script>
    <script type="text/javascript" src="../js/code/dialog-search.js"></script>
    
    <script type="text/javascript" src="../lib/jquery-3.7.0/jquery-3.7.0.min.js"></script>
    <script type="text/javascript" src="../js/windows/presentation-editor.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={presentation.html}]
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Presentation - JSLAB | PR-DC</title>
  <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
  
<!-- CSS files begin -->
  %presentation_stylesheets%
  <link rel="stylesheet" type="text/css" href="./res/internal/presentation.css" />
  <link rel="stylesheet" type="text/css" href="./main.css" />
<!-- CSS files end -->
  
  <style id="dynamic-style-rules"></style>
</head>
<body>
<div id="slides-cont">
<!-- Slides begin -->
  <slide>
    Slide <span class="slide-number">${presentation.slideNumber()} / ${presentation.slideCount()}</span>
  </slide>
  
  <slide>
    Slide <span class="slide-number">${presentation.slideNumber()} / ${presentation.slideCount()}</span>
  </slide>
  
  <slide>
    Slide <span class="slide-number">${presentation.slideNumber()} / ${presentation.slideCount()}</span>
  </slide>
<!-- Slides end -->
</div>
  
<!-- JS files begin -->
  %presentation_scripts%
  <script type="text/javascript" src="./res/internal/presentation.js"></script>
  <script type="text/javascript" src="./main.js"></script>
<!-- JS files end -->
</body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={sandbox-worker.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
  </head>
  <body>
    <script type="text/javascript" src="../lib/luxon-3.4.4/luxon-3.4.4.min.js"></script>
    <script type="text/javascript" src="../lib/math-11.8.2/math-11.8.2.min.js"></script>
    <script type="text/javascript" src="../lib/sprintf-1.1.3/sprintf-1.1.3.min.js"></script>
    <script type="text/javascript" src="../lib/Cesium-1.124/Cesium.js"></script>
    
    <script>window.process.browser = 'Electron';</script>
    <script type="text/javascript" src="../lib/sympy-0.26.2/pyodide.js"></script>
    <script type="text/javascript" src="../node_modules/fmin/build/fmin.min.js"></script>
    <script type="text/javascript" src="../js/sandbox/init-sandbox-worker.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={sandbox.html}]
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
  </head>
  <body>
    <script type="text/javascript" src="../lib/luxon-3.4.4/luxon-3.4.4.min.js"></script>
    <script type="text/javascript" src="../lib/math-11.8.2/math-11.8.2.min.js"></script>
    <script type="text/javascript" src="../lib/sprintf-1.1.3/sprintf-1.1.3.min.js"></script>
    <script type="text/javascript" src="../lib/Cesium-1.124/Cesium.js"></script>
    
    <script>window.process.browser = 'Electron';</script>
    <script type="text/javascript" src="../lib/sympy-0.26.2/pyodide.js"></script>
    <script type="text/javascript" src="../node_modules/fmin/build/fmin.min.js"></script>
    <script type="text/javascript" src="../js/sandbox/init-sandbox.js"></script>
  </body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={serial\_terminal.html}]
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Serial Terminal - JSLAB | PR-DC</title>
  <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
  <link rel="stylesheet" type="text/css" href="../css/basic.css" />
  <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    
    body {
      height: calc(100% - 6px);
    }
    
    .clear {
      clear: both;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    #messages-container {
      flex: 1;
      overflow-y: auto;
      padding: 10px;
      border-bottom: 1px solid #ccc;
    }

    #input-container {
      display: flex;
      align-items: center;
      padding: 10px;
      background: #eee;
    }

    #input-container textarea {
      flex: 1;
      margin-right: 40px;
      padding: 5px;
      font-family: inherit;
      font-size: 14px;
      resize: none;
      border-radius: 5px;
      padding-bottom: 0px;
    }

    #send-button {
      position: absolute;
      right: 10px;
      z-index: 3;
      background: #f7df1e;
      border-radius: 100%;
      width: 30px;
      height: 30px;
      cursor: pointer;
      bottom: 20px;
    }

    #send-button:hover {
      opacity: 0.6;
    }

    #send-button img {
      width: 18px;
      padding: 6px;
    }

    .options .options-right {
      float: right;
    }

    .options i#settings {
      background: url(../img/settings.svg) no-repeat center;
    }

    .options i#timestamp {
      background: url(../img/timestamp.svg) no-repeat center;
    }

    .options i#autoscroll {
      background: url(../img/autoscroll.svg) no-repeat center;
    }

    .options i#clear {
      background: url(../img/clear.svg) no-repeat center;
    }

    .options i#log {
      background: url(../img/save-log.svg) no-repeat center;
    }

    .options i#to-bottom {
      background: url(../img/to-bottom.svg) no-repeat center;
    }

    .options i {
      width: 16px;
      height: 18px;
      display: block;
      background-size: 16px!important;
      float: left;
      clear: none;
      padding: 3px 5px;
      opacity: 0.3;
      user-select: none;
      -webkit-user-drag: none;
    }

    .options i:hover {
      opacity: 1;
      cursor: pointer;
    }

    .options i.active {
      opacity: 0.8;
    }
    
    #save-log, #change-settings {
      margin-bottom: 0px;
    }
    
    #terminal-options {
      margin: 5px 10px;
      margin-bottom: 0px;
      color: #666;
      padding-bottom: 3px;
      border-bottom: 1px solid #f7df1e;
      font-weight: 300;
      font-size: 14px;
      user-select: none;
      -webkit-user-drag: none;
      user-drag: none;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: calc(100% - 20px);
      right: 0;
    }

    #messages-container > div {
      padding-bottom: 5px;
      padding-top: 5px;
      line-height: 22px;
      padding-left: 105px;
      padding-right: 10px;
      position: relative;
      white-space: pre-wrap;
      min-height: 32px;
    }

    #messages-container.no-timestamp > div {
      padding-left: 5px;
    }

    #messages-container div:hover {
      background-color: #f9f9f9;
    }

    #messages-container.no-timestamp div span.timestamp {
      display: none;
    }

    #messages-container div:hover span.timestamp {
      color: #2e85c7
    }

    #messages-container div span.timestamp {
      color: #999;
      display: block;
      position: absolute;
      left: 0px;
    }
    
    #terminal-title {
      float: left;
      padding-top: 5px;
    }
    
  </style>
</head>
<body>
  <div class="container">
    <div id="terminal-options" class="options ui">
      <div id="terminal-title"></div>
      <div class="options-right">
        <i id="settings" title-str="40"></i>
        <i id="timestamp" class="active" title-str="41"></i>
        <i id="autoscroll" class="active" title-str="42"></i>
        <i id="clear" title-str="43"></i>
        <i id="log" title-str="44"></i>
        <i id="to-bottom" title-str="45"></i>
        <br class="clear">
      </div>
    </div>
    
    <div id="messages-container" class="panel ui"></div>
    
    <div id="input-container">
      <textarea id="message-input" str="234" placeholder=""></textarea>
      <div id="send-button">
        <img src="../img/enter.svg" title-str="226">
      </div>
    </div>
    
    <div id="settings-dialog" class="terminal-dialog options-panel panel ui" tabindex="0">
      <div class="options-cont ui">
        <div class="options-header ui"><span><str sid="56"></str></span>
        <img class="options-close ui" src="../img/close.svg" title-str="46">
       </div>
       <div class="float-input ui" title-str="17">
        <input autocomplete="off" type="text" name="N-messages-max" id="N-messages-max" placeholder="Infinity" value="">
        <label class="float-label" for="N-messages-max"><str sid="17"></str></label>
       </div>
       <button class="change-settings ui blue"><str sid="57"></str></button>
      </div>
    </div>

    <div id="log-dialog" class="terminal-dialog options-panel panel ui" tabindex="0">
      <div class="options-cont ui">
        <div class="options-header ui">
          <span><str sid="58"></str></span>
          <img class="options-close ui" src="../img/close.svg" title-str="18">
        </div>
        <label class="checkcont ui"><str sid="59"></str><input id="write-timestamps" type="checkbox" name="write-timestamps" value="1" checked><span class="checkmark"></span></label>
        <button id="save-log" class="ui blue"><str sid="60"></str></button>
      </div>
    </div>
  </div>
</body>
</html>


\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={three.html}]
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>THREE - JSLAB | PR-DC</title>
  <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
  <link rel="stylesheet" type="text/css" href="../css/three.css" />
  <link rel="stylesheet" type="text/css" href="../font/roboto.css" />
</head>
<body>
  
  <div id="scene-cont"></div>
  
  <script type="text/javascript" src="../lib/hammer-2.0.8/hammer.min.js"></script>
  <script type="text/javascript" src="../lib/anime-3.2.1/anime-3.2.1.min.js"></script>
  <script type="text/javascript" src="../lib/tween.js-23.1.1/tween-23.1.1.js"></script>
  <script type="text/javascript" src="../lib/inflate-0.3.1/inflate-0.3.1.min.js"></script>
  
  <script>if(typeof module === 'object') { window.module = module; module = undefined; }</script>

  <script type="importmap">
    {
      "imports": {
        "three": "../lib/three.js-r162/build/three.module.js",
        "three/addons/": "../lib/three.js-r162/examples/jsm/"
      }
    }
  </script>
</body>
</html>
\end{lstlisting}

\begin{lstlisting}[style=HTMLStyle, caption={url.html}]
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>URL - JSLAB | PR-DC</title>
  <meta http-equiv="Content-Security-Policy" content="script-src * 'self' 'unsafe-inline' 'unsafe-eval'; worker-src 'self' blob:;" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
    }

    webview {
      position: fixed;
      inset: 0;
    }
  </style>
</head>
<body>
  <webview id="webview" nodeintegration webpreferences="backgroundThrottling=no, contextIsolation=no"></webview>
</body>
</html>
\end{lstlisting}

% ----------------------------------------
\section{js}


\begin{lstlisting}[style=JavaScriptStyle, caption={helper.js}]
/**
 * @file Javascript helper functions
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

var { shell } = require('electron');

/**
 * Call function when document is ready
 * @param {function} fn - function which is called when document is ready.
 */
global.ready = function(fn) {
  if(document.readyState != 'loading') {
    fn();
  } else {
    document.addEventListener('DOMContentLoaded', fn);
  }
};
  
/**
 * Prevents redirect
 */
global.preventRedirect = function() {
  var links = $('a');
  links.each(function() {
    if(!$(this).hasClass('external-link')) {
      $(this).addClass('external-link');
      $(this).click(function(e) {
        e.preventDefault();
        shell.openExternal(e.target.href);
        return false;
      });
    }
  });
};

/**
 * Get process arguments
 */
if(process.type == 'browser' || global.is_worker) {
  global.process_arguments = process.argv;
} else {
  var { ipcRenderer } = require('electron');
  global.process_arguments = 
    ipcRenderer.sendSync("sync-message", "get-process-arguments");
}
  
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={init-config.js}]
/**
 * @file Init config
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */
"use strict";

const { PRDC_APP_CONFIG } = require("../config/config.js");

// Global variables
global.config = new PRDC_APP_CONFIG();

// Conditional variables
if(typeof global.process_arguments != 'undefined' && Array.isArray(global.process_arguments)) {
  var args = global.process_arguments.map(function(e) { return e.toLowerCase(); });
  if(args.includes("--debug-app")) {
    global.config.DEBUG = true;
  }
  if(args.includes("--test-app")) {
    global.config.TEST = true;
  }
  if(args.includes("--sign-build")) {
    global.config.SIGN_BUILD = true;
  }
}
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={init.js}]
/**
 * @file JSLAB init app
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
"use strict";

const { app } = require('electron');
global.app_path = app.getAppPath().replace(/\\js\\?$/, '');

const helper = require("./helper.js");
require("./init-config.js");

const { PRDC_JSLAB_MAIN } = require("./main");

// Start main
const main = new PRDC_JSLAB_MAIN();
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={language.js}]
/**
 * @file JSLAB language module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
const fs = require('fs');
const Store = require('electron-store');

const store = new Store();

/**
 * Class for JSLAB language.
 */
class PRDC_JSLAB_LANGUAGE {

  /**
   * Create JSLAB language object.
   */
  constructor() {
    // Variables
    var obj = this;
    
    this.lang_index = store.get('lang_index');
    if(!this.lang_index) {
      this.lang_index = 0;
    }
    
    this.onLanguageChange = function() {};
    
    var style = document.createElement('style');
    document.head.appendChild(style);
    this.lang_styles = style.sheet;
    
    // Get language strings
    this.s = JSON.parse(fs.readFileSync(app_path + '/config/lang.json'));
    
    document.querySelectorAll('str').forEach(function(el) {
      var id = el.getAttribute('sid');
      el.innerHTML = obj.string(id);
    });
    
    this.lang = config.langs[this.lang_index];
    this.set(this.lang);
  }

  /**
   * Sets the application's current language and updates the UI accordingly.
   * Saves the new language preference for future sessions.
   * @param {string} lang The language code to set as the current language.
   */
  set(lang) {
    var idx = config.langs.findIndex(function(e) { 
      return e == lang;
    });
    if(idx >= 0) {
      this.lang = lang;
      this.lang_index = idx;
      if(this.lang_styles.cssRules.length) {
        this.lang_styles.deleteRule(0);
      }
      this.lang_styles.insertRule("lang."+lang+" { display: initial }", 0);
      this.update('html', false);
      
      // Save langugae
      store.set('lang_index', this.lang_index);
      this.onLanguageChange(lang);
    }
  }
  
  /**
   * Dynamically updates text strings within the specified HTML container to the current language.
   * Can optionally update placeholders and titles for input and option elements.
   * @param {String} cont The selector for the container whose text strings will be updated. Defaults to 'html'.
   * @param {boolean} flag If true, updates the container and child elements with dynamic language strings.
   */
  update(cont = 'html', flag = true) {
    var obj = this;

    if(flag) {
      document.querySelectorAll(cont + ' str').forEach(function(el) {
        var id = el.getAttribute('sid');
        el.innerHTML = obj.string(id);
      });
    }

    document.querySelectorAll(cont + ' textarea[str]').forEach(function(el) {
      var id = el.getAttribute('str');
      if(id in obj.s) {
        el.setAttribute('placeholder', obj.s[id][obj.lang]);
      }
    });
    
    document.querySelectorAll(cont + ' input[str]').forEach(function(el) {
      var id = el.getAttribute('str');
      if(id in obj.s) {
        el.setAttribute('placeholder', obj.s[id][obj.lang]);
      }
    });

    document.querySelectorAll(cont + ' option[str]').forEach(function(el) {
      var id = el.getAttribute('str');
      if(id in obj.s) {
        el.textContent = obj.s[id][obj.lang];
      }
    });

    document.querySelectorAll(cont + ' [title-str]').forEach(function(el) {
      var id = el.getAttribute('title-str');
      if(id in obj.s) {
        el.setAttribute('title', obj.s[id][obj.lang]);
      }
    });
  }
  
  /**
   * Retrieves the specified language string in all available languages, wrapped in language-specific <lang> tags.
   * @param {number} id The identifier of the string to retrieve.
   * @returns {HTML} HTML string containing the text in all available languages.
   */
  string(id) {
   var obj = this;
   var msg = '';
   if(id in this.s) {
     config.langs.forEach(function(lang) {
       msg += '<lang class="'+lang+'">'+obj.s[id][lang]+'</lang>';
     });
   } else {
     config.langs.forEach(function(lang) {
       msg += '<lang class="'+lang+'"></lang>';
     });
   }
   return msg;
  }

  /**
   * Retrieves the current language string for the specified identifier.
   * @param {number} id The identifier of the string to retrieve.
   * @returns {String} The string corresponding to the current language.
   */
  currentString(id) {
    if(id in this.s) {
      return this.s[id][this.lang];
    } else {
      return '';
    }
  }

  /**
   * Sets a callback function to be executed when the language is changed.
   * @param {Function} callback The callback function to be executed on language change.
   */
  setOnLanguageChange(callback) {
    if(typeof callback == 'function') {
      this.onLanguageChange = callback;
    }
  }
}

exports.PRDC_JSLAB_LANGUAGE = PRDC_JSLAB_LANGUAGE;

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={main.js}]
/**
 * @file JSLAB main script
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const { app, BrowserWindow, ipcMain, dialog, powerSaveBlocker, shell, 
  MenuItem , desktopCapturer, screen, webContents } = require('electron');

const contextMenu = require('electron-context-menu');
const fs = require('fs');
const os = require('os');
const Store = require('electron-store');

const { PRDC_APP_LOGGER } = require('./../lib/PRDC_APP_LOGGER/PRDC_APP_LOGGER');

var app_version = process.env.npm_package_version;

app.commandLine.appendSwitch('max-active-webgl-contexts', config.MAX_ACTIVE_WEBGL_CONTEXTS);

/**
 * Class for flight control app.
 */
class PRDC_JSLAB_MAIN {

  /**
   * Create app.
   */
  constructor() {
    var obj = this;

    this.store = new Store();
    this.debounce_save_win_time = config.WIN_SAVE_DEBOUNCE_TIME;
    this.debounce_save_win_bounds = [];

    this.heartbeat_interval;
    this.win_main;
    this.win_editor;
    this.win_sandbox;
    this.win_opacity = 0;
    this.editor_close_ready = false;
    this.stop_loop_in = false;
    
    this.app_icon = app_path + '/icons/icon.ico'; // png to ico https://icoconvert.com/
    this.is_app_quitting = false;
    this.known_paths = ['home', 'appData', 'userDat', 'sessionData', 
      'temp', 'exe', 'module', 'desktop', 'documents', 'downloads', 
      'music', 'pictures', 'videos', 'recent', 'logs', 'crashDumps'];
                
    if(os.platform() == 'linux') {
      this.app_icon = app_path + '/icons/icon.png';
    }

    // Create folder for app
    this.app_folder = app.getPath('documents')+'\\'+app.getName();
    if(!fs.existsSync(this.app_folder)) {
      fs.mkdirSync(this.app_folder);
    }
    
    // Start log
    this.log_file = this.app_folder+'\\'+app.getName()+'.log';
    this.app_logger = new PRDC_APP_LOGGER(this.log_file);

    if(config.REPORT_CRASH) {
      const Bugsnag = require('@bugsnag/electron');
      Bugsnag.start({ apiKey: config.BUGSNAG_API_KEY });
    }
    
    // Context menu
    contextMenu({
      append: function(default_actions, p, win) {
        return [
          new MenuItem({
            label: 'Toggle Comment',
            click: function() {
              obj.win_editor.send('EditorWindow', 'toggle-comment');
            },
            visible: p.formControlType == 'text-area' &&
              p.pageURL.endsWith('/editor.html')
          }),
          new MenuItem({
            label: 'Go To Code',
            click: function() {
              win.webContents.send('PresentationEditorWindow', 'go-to-code');
            },
            visible: p.pageURL.endsWith('/presentation-editor.html') && 
              p.frameURL != p.pageURL
          }),
          new MenuItem({
            label: 'Go To Slide',
            click: function() {
              win.webContents.send('PresentationEditorWindow', 'go-to-slide');
            },
            visible: p.formControlType == 'text-area' &&
              p.titleText == 'html' &&
              p.pageURL.endsWith('/presentation-editor.html')
          }),
          new MenuItem({
            role: 'selectAll',
            label: 'Select All',
            visible: p.editFlags.canSelectAll
          }),
          new MenuItem({
            role: 'delete',
            label: 'Delete',
            visible: p.editFlags.canDelete
          })
        ];
      },
      showLookUpSelection: false,
      showSearchWithGoogle: false,
      showCopyImage: false,
      showInspectElement: false
    });
  
    // Disable renderer backgrounding
    app.commandLine.appendSwitch('disable-renderer-backgrounding');
    app.commandLine.appendSwitch('disable-background-timer-throttling');
    app.commandLine.appendSwitch('disable-backgrounding-occluded-windows');
    app.commandLine.appendSwitch("disable-http-cache");

    // Prevent sleep
    powerSaveBlocker.start('prevent-app-suspension');
  
    // This method will be called when Electron has finished
    // initialization and is ready to create browser windows.
    // Some APIs can only be used after this event occurs.
    app.whenReady().then(function(){
      obj.createWindows();

      app.on('activate', function() {
        // On macOS it's common to re-create a window in the app when the
        // dock icon is clicked and there are no other windows open.
        if(BrowserWindow.getAllWindows().length === 0) obj.createWindows();
      });
    });

    // Quit when all windows are closed, except on macOS. There, it's common
    // for applications and their menu bar to stay active until the user quits
    // explicitly with Cmd + Q.
    app.on('window-all-closed', function () {
      if(process.platform !== 'darwin') app.quit();
    });
    app.allowRendererProcessReuse = false;
  }

  /**
   * Create all windows
   */
  createWindows() { 
    // Create the main  window
    this.creatMainWindow();

    // Create the sandbox window
    this.createSandboxWindow();
    
    // Create the editor window
    this.createEditorWindow();

    // Set handlers
    this.setHandlers();
    
    // Handle IPC messages
    this.handleMessages();
  }

  /**
   * Create main window
   */
  creatMainWindow() {
    var obj = this;
    var options = {
      title: 'JSLAB',
      minWidth: 720,
      minHeight: 500,
      icon: this.app_icon, // png to ico https://icoconvert.com/
      show: false,
      frame: false,
      backgroundColor: '#ffffff',
      opacity: this.win_opacity,
      webPreferences: {
        nodeIntegration: true,
        nodeIntegrationInWorker: true,
        contextIsolation: false,
        backgroundThrottling: false
      }
    };
    options = this.getWindowBounds('mainWinBounds', options);
    this.win_main = new BrowserWindow(options);
    
    // Hide menu
    this.win_main.setMenu(null);

    // Maximize
    if(options.maximize) {
      this.win_main.maximize();
    }

    // and load the main.html of the app
    this.win_main.loadFile(app_path + '/html/main.html');

    // Events
    this.win_main.on("resize", function() { obj.saveWindowBounds(obj.win_main, 'mainWinBounds'); });
    this.win_main.on("move", function() { obj.saveWindowBounds(obj.win_main, 'mainWinBounds'); });
    this.win_main.on("maximize", function() { obj.saveWindowBounds(obj.win_main, 'mainWinBounds'); });
    this.win_main.on("unmaximize", function() { obj.saveWindowBounds(obj.win_main, 'mainWinBounds'); });
    
    // Show window when ready
    this.win_main.once('ready-to-show', function() {
      obj.win_main.show();
      if(config.DEBUG) {
        obj.openDevTools(obj.win_main);
      }
    });

    this.win_main.webContents.on('render-process-gone', function(event , details) {
      obj.app_logger.logMessage(config.DEBUG_RENDER_GONE_ERROR, config.LOG_RENDER_GONE_ERROR, config.LOG_CODES['render-gone-error'], 'Render gone error', 'Main window render gone error:' + JSON.stringify(event) + ' ' + JSON.stringify(details));
      app.exit();
      app.relaunch();
    });
    
    // Close all windows
    this.win_main.on('close', function(e) {
      e.preventDefault();
      obj.win_main.webContents.executeJavaScript('win_main.close();');
    });
  }

  /**
   * Create sandbox window
   */
  createSandboxWindow() {
    var obj = this;
    this.win_sandbox = new BrowserWindow({
      title: 'Sandbox | JSLAB',
      minWidth: 720,
      minHeight: 500,
      icon: this.app_icon, // png to ico https://icoconvert.com/
      show: false,
      backgroundColor: '#ffffff',
      opacity: this.win_opacity,
      webPreferences: {
        nodeIntegration: true,
        nodeIntegrationInWorker: true,
        contextIsolation: false,
        backgroundThrottling: false
      }
    });

    // Hide menu
    this.win_sandbox.setMenu(null);

    // and load the index.html of the app
    this.win_sandbox.loadFile(app_path + '/html/sandbox.html');
    
    if(config.DEBUG) {
      // Show dev tools
      this.openDevTools(this.win_sandbox);
    }
    
    // Sub windows
    this.win_sandbox.webContents.setWindowOpenHandler(function(handler) {
      return {
        action: 'allow',
        overrideBrowserWindowOptions: {
          minWidth: 250,
          minHeight: 50,
          icon: obj.app_icon, // png to ico https://icoconvert.com/
          show: false,
          backgroundColor: '#ffffff',
          opacity: obj.win_opacity,
          webPreferences: {
            nodeIntegration: true,
            nodeIntegrationInWorker: true,
            contextIsolation: false,
            backgroundThrottling: false,
            webviewTag: true
          }
        }
      };
    }); 
    
    this.sandbox_sub_wins = {};
    this.win_sandbox.webContents.on('did-create-window', function(sub_win, details) {
      var wid = details.frameName;
      obj.sandbox_sub_wins[wid] = sub_win;
      
      // Hide menu
      sub_win.setMenu(null);
      
      // Show window
      sub_win.once('ready-to-show', function() {
        sub_win.show();
        sub_win.focus();
        obj.fadeWindowIn(sub_win, 0.1, 10);

        if(config.DEBUG) {
          obj.openDevTools(sub_win);
        }
      });
     
      sub_win.webContents.on('did-attach-webview', (_e, wc) => {
        if(wc.getUserAgent() == 'presentation-editor-preview') {
          contextMenu({ 
            window: wc,
            append: function(default_actions, p, win) {
              return [
                new MenuItem({
                  label: 'Go To Slide',
                  click: function() {
                    sub_win.webContents.send('PresentationEditorWindow', 'go-to-code');
                  },
                  visible: true
                })
              ]
            }
          });
        }
      });
  
      // Close all windows
      sub_win.on('close', function(e) {
        e.preventDefault();
        obj.win_sandbox.webContents.executeJavaScript('jsl.windows._closedWindow('+wid+');');
        sub_win.hide();
        sub_win.forClose = true;
      });
      
    });
    
    this.win_sandbox.webContents.on('render-process-gone', function(event, details) {
      obj.app_logger.logMessage(config.DEBUG_RENDER_GONE_ERROR, config.LOG_RENDER_GONE_ERROR, config.LOG_CODES['render-gone-error'], 'Render gone error', 'Sandbox window render gone error:' + JSON.stringify(event) + ' ' + JSON.stringify(details));
      app.exit();
      app.relaunch();
    });
    
    this.win_sandbox.webContents.on('did-finish-load', function() {
      if(!obj.store.get('shown-getting-started')) {
        obj.store.set('shown-getting-started', 1);
        obj.win_sandbox.webContents.executeJavaScript('openDocumentation("about");');
      }
      if(obj.sandbox_reload_active) {
        obj.win_main.webContents.executeJavaScript('win_main.onSandboxReset();');
        obj.sandbox_reload_active = false;
      }
    });
  }

  /**
   * Create editor window
   */
  createEditorWindow() {
    var obj = this;
    var options = {
      title: 'Editor | JSLAB',
      minWidth: 720,
      minHeight: 500,
      icon: this.app_icon, // png to ico https://icoconvert.com/
      show: false,
      frame: false,
      backgroundColor: '#ffffff',
      opacity: this.win_opacity,
      webPreferences: {
        nodeIntegration: true,
        nodeIntegrationInWorker: true,
        contextIsolation: false,
        backgroundThrottling: false
      }
    };
    options = this.getWindowBounds('editorWinBounds', options);
    this.win_editor = new BrowserWindow(options);
    
    // Hide menu
    this.win_editor.setMenu(null);

    // Maximize
    if(options.maximize) {
      this.win_editor.maximize();
    }
    
    // Hide menu
    this.win_editor.setMenu(null);

    // and load the index.html of the app
    this.win_editor.loadFile(app_path + '/html/editor.html');

    // Maximize
    if(options.maximize) {
      this.win_editor.maximize();
    }

    // Events
    this.win_editor.on("resize", function() { obj.saveWindowBounds(obj.win_editor, 'editorWinBounds'); });
    this.win_editor.on("move", function() { obj.saveWindowBounds(obj.win_editor, 'editorWinBounds'); });
    this.win_editor.on("maximize", function() { obj.saveWindowBounds(obj.win_editor, 'editorWinBounds'); });
    this.win_editor.on("unmaximize", function() { obj.saveWindowBounds(obj.win_editor, 'editorWinBounds'); });

    // Hide window when ready
    this.win_editor.hide();
   
    this.win_editor.on('close', function(e) {
      if(!obj.is_app_quitting) {
        e.preventDefault();
        obj.fadeWindowOut(obj.win_editor, 0.1, 10);
        setTimeout(function() {
          obj.win_editor.hide();
        }, 100);
      } else if(!obj.editor_close_ready) {
        e.preventDefault();
      }
    });
    
    this.win_editor.webContents.on('render-process-gone', function(event , details) {
      obj.app_logger.logMessage(config.DEBUG_RENDER_GONE_ERROR, config.LOG_RENDER_GONE_ERROR, config.LOG_CODES['render-gone-error'], 'Render gone error', 'Editor window render gone error:' + JSON.stringify(event) + ' ' + JSON.stringify(details));
    });
  }

  /**
   * Handle IPC messages
   */
  handleMessages() {
    var obj = this;
    
    // For MainProcess 
    ipcMain.handle('get-completions', function(e, data) {
      obj.win_sandbox.send('SandboxWindow', 'get-completions', data);
      return new Promise(function(resolve) {
        ipcMain.once('completions-'+data[0], function(e, data) {
          resolve(data);
        });
      });
    });
    
    ipcMain.handle('dialog', function(e, method, params) {       
      if(!params || params && !params.hasOwnProperty('icon')) {
        if(!params) {
          params = {};
        }
        params.icon = obj.app_icon;
      }
      return dialog[method](params);
    });

    ipcMain.on('get-desktop-sources', async function(e) {
      e.returnValue = await desktopCapturer.getSources({ types: ['screen', 'window'] });
    });

    ipcMain.handle('print-to-pdf', async function(e, options) {
      return await e.sender.printToPDF(options);
    });
    
    ipcMain.handle('print-sub-win-to-pdf', async function(e, wid, options) {
      return await obj.sandbox_sub_wins[wid].webContents.printToPDF(options);
    });
    
    ipcMain.on('dialog', function(e, method, params) {
      if(!params || params && !params.hasOwnProperty('icon')) {
        if(!params) {
          params = {};
        }
        params.icon = obj.app_icon;
      }
      e.returnValue = dialog[method](params);
    });
    
    ipcMain.on('sync-message', function(e, action, data) {
      var retval;
      switch(action) {
        case 'get-app':
          retval = {'name': app.getName(), 'version': app_version, 'path': app_path, 'exe_path': app.getPath('exe')};
          break;
        case 'get-app-name':
          retval = app.getName();
          break;
        case 'get-app-path':
          retval = app_path;
          break;
        case 'get-app-version':
          retval = app_version;
          break;
        case 'get-platform':
          retval = os.platform();
          break;
        case 'get-debug-flag':
          retval = config.DEBUG;
          break;
        case 'get-path':
          if(obj.known_paths.includes(data)) {
            retval = app.getPath(data);
          } else if(data == 'root') {
            retval = app_path;
          } else if(data == 'includes') {
            retval = app_path + '\\includes';
          } else {
            retval = true;
          }
          break;
        case 'get-log-file':
          retval = obj.log_file;
          break;
        case 'is-maximized-win':
          retval = BrowserWindow.fromWebContents(e.sender).isMaximized();
          break;
        case 'check-stop-loop':
          retval = obj.stop_loop_in;
          break;
        case 'reset-stop-loop':
          obj.stop_loop_in = false;
          retval = true;
          break;
        case 'get-process-arguments':
          retval = process.argv;
          break;
        case 'call-sub-win-method':
          var [id, method, ...args] = data;
          if(obj.sandbox_sub_wins.hasOwnProperty(id)) {
            retval = obj.sandbox_sub_wins[id][method](...args);
          } else {
            retval = false;
          }
          break;
        case 'open-sub-win-devtools':
          if(obj.sandbox_sub_wins.hasOwnProperty(data)) {
            obj.openDevTools(obj.sandbox_sub_wins[data]);
            retval = true;
          } else {
            retval = false;
          }
          break;
        case 'get-sub-win-source-id':
          if(obj.sandbox_sub_wins.hasOwnProperty(data)) {
            retval = obj.sandbox_sub_wins[data].getMediaSourceId();
          } else {
            retval = false;
          }
          break;
        case 'reset-app':
          app.exit();
          app.relaunch();
          break;
        case 'reset-sandbox':
          obj.sandbox_reload_active = true;
          obj.win_sandbox.destroy();
          Object.keys(obj.sandbox_sub_wins).forEach(function(wid) {
            obj.sandbox_sub_wins[wid].destroy();
            delete obj.sandbox_sub_wins[wid];
          });
          obj.createSandboxWindow();
          break;
        default:
          retval = true;
          break;
      }
      e.returnValue = retval;
    });
    
    ipcMain.on('MainProcess', function(e, action, data) {
      switch(action) {
        case 'show-dev-tools':
          // Show DevTools
          obj.openDevTools(BrowserWindow.fromWebContents(e.sender));
          break;
        case 'show-sandbox-dev-tools':
          // Show Sandbox DevTools
          obj.openDevTools(obj.win_sandbox);
          break;
        case 'open-dir':
        case 'open-folder':
        case 'show-dir':
        case 'show-folder':
          shell.openPath(data);
          break;
        case 'show-file-in-folder':
        case 'show-file-in-dir':
          shell.showItemInFolder(data);
          break;
        case 'focus-win':
          e.sender.focus();
          break;
        case 'fade-in-win':
          obj.fadeWindowIn(BrowserWindow.fromWebContents(e.sender), 0.1, 10);
          break;
        case 'fade-out-win':
          obj.fadeWindowIn(BrowserWindow.fromWebContents(e.sender), 0.1, 10);
          break;
        case 'close-win':
          BrowserWindow.fromWebContents(e.sender).close();
          e.sender.destroy();
          break;
        case 'close-app':
          if(obj.win_main !== undefined && !obj.win_main.isDestroyed()) {
            obj.win_main.destroy();
          }
          if(obj.win_editor !== undefined && !obj.win_editor.isDestroyed()) {
            obj.is_app_quitting = true;
            obj.win_editor.send('EditorWindow','close-all');
          }
          if(obj.win_sandbox !== undefined && !obj.win_sandbox.isDestroyed()) {
            obj.win_sandbox.destroy();
          }
          break;
        case 'set-fullscreen':
          BrowserWindow.fromWebContents(e.sender).setFullScreen(data);
          BrowserWindow.fromWebContents(e.sender).maximize();
          break;
        case 'maximize-win':
          BrowserWindow.fromWebContents(e.sender).maximize();
          break;
        case 'restore-win':
          BrowserWindow.fromWebContents(e.sender).restore();
          break;
        case 'minimize-win':
          BrowserWindow.fromWebContents(e.sender).minimize();
          break;
        case 'show-editor':
          // Show editor
          obj.showEditor();
          break;
        case 'close-editor':
          // Close editor
          obj.editor_close_ready = true;
          obj.win_editor.close();
          break;  
        case 'capture-page':
          obj.win_main.webContents.capturePage(undefined, {
            stayHidden: true, 
            stayAwake: true
          }).then(function(img) {
            var size = img.getSize();
            obj.win_main.webContents.send('streamer', 'captured-page', {buffer: img.toBitmap().buffer, width: size.width, height: size.height});
          });
          break;
        case 'take-screenshot':
          obj.win_main.webContents.capturePage(undefined, {
            stayHidden: true, 
            stayAwake: true
          }).then(function(img) {
            if(data) {
              img = img.crop(data);
            }
            obj.win_main.webContents.send('gui', 'screenshot', {buffer: img.toPNG()});
          });
          break;
        case 'close-log':
          obj.app_logger.closeLog();
          break;
        case 'code-evaluated':
          Object.keys(obj.sandbox_sub_wins).forEach(function(wid) {
            var win = obj.sandbox_sub_wins[wid];
            if(win.forClose) {
              setTimeout(function() {
                win.destroy();
                delete obj.sandbox_sub_wins[wid];
              }, 500);
            }
          });
          break;
        case 'set-win-size':
          obj.win_main.setSize(data[0], data[1]);
          break;
        case 'app-relaunch':
          app.exit();
          app.relaunch();
          break;
      }
    });
    
    // For MainWindow
    ipcMain.on('MainWindow', function(e, action, data) {
      if(!obj.win_main.isDestroyed()) {
        switch(action) {
          default:
            obj.win_main.send('MainWindow', action, data);
            break;
        }
      }
    });
    
    // For EditorWindow
    ipcMain.on('EditorWindow', function(e, action, data) {
      switch(action) {
        case 'open-script':
          // Open file in editor
          obj.showEditor();
          obj.win_editor.send('EditorWindow', 'open-script', data);
          break;
        default:
          // Other actions
          obj.win_editor.send('EditorWindow', action, data);
          break;
      }
    });
    
    // For SandboxWindow
    ipcMain.on('SandboxWindow', function(e, action, data) {
      if(action == 'stop-loop') {
        obj.stop_loop_in = data;
      }
      switch(action) {
        default:
          obj.win_sandbox.send('SandboxWindow', action, data);
          break;
      }
    });
  }

  /**
   * Show editor window
   */
  showEditor() {
    this.win_editor.show();
    this.win_editor.focus();
    this.fadeWindowIn(this.win_editor, 0.1, 10);
   
    if(config.DEBUG) {
      if(!this.win_editor.devtools_win || !this.win_editor.devtools_win.isVisible()) {
        this.openDevTools(this.win_editor);
      }
    }
  }

  /**
   * Get window bounds
   * @param {string} store_key - key used for storage.
   * @param {object} options - options for window.
   * @returns {object} window bounds.
   */
  getWindowBounds(store_key, options) {
    var stored_options = this.store.get(store_key);
    if(stored_options) {
      var bounds = stored_options.bounds;
      var area = screen.getDisplayMatching(bounds).workArea;
      options.maximize = stored_options.maximize;
      if(
        bounds.x >= area.x &&
        bounds.y >= area.y &&
        bounds.x + bounds.width <= area.x + area.width &&
        bounds.y + bounds.height <= area.y + area.height
      ) {
        options.x = bounds.x;
        options.y = bounds.y;
      }
      if(bounds.width <= area.width || bounds.height <= area.height) {
        options.width = bounds.width;
        options.height = bounds.height;
      }
    }
    
    return options;
  }

  /**
   * Save window bounds
   * @param {BrowserWindow} win - broweser window.
   * @param {string} store_key - key used for storage.
   */
  saveWindowBounds(win, store_key) {
    var obj = this;
    if(this.debounce_save_win_bounds[store_key]) {
      clearTimeout(this.debounce_save_win_bounds[store_key]);
    }
    this.debounce_save_win_bounds[store_key] = setTimeout(function() {
      obj.debounce_save_win_bounds[store_key] = undefined;
      var options = {};
      options.bounds = win.getNormalBounds();
      options.maximize = win.isMaximized();
      obj.store.set(store_key, options);
    }, this.debounce_save_win_time);
  }

  /**
   * Configures session-wide handlers for certificate verification, permission checks,
   * device permission handling, and USB protected classes handling. These handlers ensure
   * the application's security and user privacy.
   */
  setHandlers() {
    this.win_main.webContents.session.setCertificateVerifyProc(function(request, callback) {
      callback(0);
    });
    
    this.win_main.webContents.session.setPermissionCheckHandler(function() {
      return true;
    });

    this.win_main.webContents.session.setDevicePermissionHandler(function() {
      return true;
    });

    this.win_main.webContents.session.setUSBProtectedClassesHandler(function() {
      return [];
    });
  }
  
  /**
   * Opens the Developer Tools for the specified Electron BrowserWindow in a detached window.
   * @param {BrowserWindow} win - The Electron `BrowserWindow` instance for which to open the Developer Tools.
   */
  openDevTools(win) {
    if(win.webContents.isDevToolsOpened()) {
      win.webContents.closeDevTools();
    }
    win.webContents.openDevTools({mode: 'undocked'});
    win.webContents.once('devtools-opened', function() {
      win.devToolsWebContents.focus();
    });
  }
  
  /**
   * Gradually increases the opacity of a given window until it is fully opaque.
   * @param {BrowserWindow} win - The browser window to fade in.
   * @param {number} step - The incremental step of opacity change. Default is 0.1.
   * @param {number} dt - The time interval in milliseconds between opacity changes. Default is 10.
   * @returns {number} The interval identifier for the fade-in operation.
   */
  fadeWindowIn(win, step = 0.1, dt = 10) {
    if(win) {
      // Get the opacity of the window.
      var opacity = win.getOpacity();
      var interval = [];

      if(opacity != 1) {
        // Increase the opacity of the window by `step` every `dt` ms
        interval = setInterval(function() {
          // Stop fading if window's opacity is 1 or greater.
          if(opacity >= 1) { 
            clearInterval(interval);
            opacity = 1;
          }
          win.setOpacity(opacity);
          opacity += step;
        }, dt);
      }

      // Return the interval. Useful if we want to stop fading at will.
      return interval;
    }
    return false;
  }

  /**
   * Gradually decreases the opacity of a given window until it is fully transparent.
   * @param {BrowserWindow} win - The browser window to fade out.
   * @param {number} step - The decremental step of opacity change. Default is 0.1.
   * @param {number} dt - The time interval in milliseconds between opacity changes. Default is 10.
   * @returns {number} The interval identifier for the fade-out operation.
   */
  fadeWindowOut(win, step = 0.1, dt = 10) {
    if(win) {
      // Get the opacity of the window.
      var opacity = win.getOpacity();
      var interval = [];

      if(opacity != 0) {
        // Reduce the opacity of the window by `step` every `dt` ms
        interval = setInterval(function() {
          // Stop fading if window's opacity is 0 or lesser.
          if(opacity <= 0) {
            clearInterval(interval);
            opacity = 0;
          }
          win.setOpacity(opacity);
          opacity -= step;
        }, dt);
      }

      // Return the interval. Useful if we want to stop fading at will.
      return interval;
    }
    return false;
  }
}

exports.PRDC_JSLAB_MAIN = PRDC_JSLAB_MAIN;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={tester.js}]
/**
 * @file Javascript tester module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

if(jsl) {
  require = jsl._require;
}

const fs = require("fs");

/**
 * Class for application testing.
 */
class PRDC_JSLAB_TESTER {

  /**
   * Initializes the tester with the specified folder containing test modules.
   * Loads all test modules and prepares them for execution.
   * @param {string} folder The folder relative to the project directory where test modules are located.
   */
  constructor(folder) {
    var obj = this;
    this.path = app_path+'/js/'+folder;
    this.modules = [];
    this.tests = [];
    this.total_tests = 0;
    
    // Define function for data display
    if(jsl) {
      this.disp = jsl._console.log;
    } else {
      this.disp = console.log;
    }
    
    // Find all test modules
    try {
      var files = fs.readdirSync(this.path);
      files.forEach(function(file) {
        if(file.endsWith(".test.js")) {
          obj.modules.push(obj.path+'/'+file);
        }
      });
    } catch(err) {
      if(err) {
        this.disp(language.currentString(92) + ': ' + err);
      }
    }
    
    // Find all tests defined in test modules
    obj.modules.forEach(function(module) {
      var { MODULE_TESTS } = require(module);
      obj.total_tests += MODULE_TESTS.testsNumber();
      obj.tests.push(...MODULE_TESTS.get());
    });
  }
  
  /**
   * Executes all loaded tests, reports successes and failures, and logs the results.
   */
  runTests() {
    var obj = this;
    if(this.total_tests > 0) {
      this.disp(language.currentString(93)+' '+this.total_tests+' '+language.currentString(94)+'.');
      var i = 1;
      var passed = 0;
      var failed = 0;
      this.tests.forEach(function(test) {
        var name = test.name;
        var result = false;
        var error = '';
        try {
          result = test.run();
        } catch(e) {
          error = e;
        }
        if(!result) {
          failed += 1;
          if(error != '') {
            obj.disp(' ['+i+'/'+obj.total_tests+'] '+language.currentString(95)+' "'+name+'" - '+language.currentString(96)+': ' + error);
          } else {
            obj.disp(' ['+i+'/'+obj.total_tests+'] '+language.currentString(95)+' "'+name+'" - '+language.currentString(97)+'.');
          }
        } else {
          passed += 1;
          obj.disp(' ['+i+'/'+obj.total_tests+'] '+language.currentString(95)+' "'+name+'" - '+language.currentString(98)+'.');
        }
      });
      this.disp(language.currentString(99)+':');
      this.disp(' '+language.currentString(100)+': '+ passed);
      this.disp(' '+language.currentString(101)+': '+ failed);
    } else {
      this.disp(language.currentString(102));
    }
  }
}

exports.PRDC_JSLAB_TESTER = PRDC_JSLAB_TESTER;

/**
 * Represents a collection of tests for a specific module or functionality within the JSLAB application.
 */
class PRDC_JSLAB_TESTS {

  /**
   * Creates an instance to manage and store individual tests.
   */
  constructor() {
    this.tests = [];
  }
  
  /**
   * Adds a new test to the collection.
   * @param {string} name The name of the test.
   * @param {Function} fun The test function to execute.
   */
  add(name, fun) {
    this.tests.push(new PRDC_JSLAB_TEST(name, fun));
  }
  
  /**
   * Returns all tests added to this collection.
   * @returns {Array} An array of all tests within this collection.
   */
  get() {
    return this.tests;
  }
  
  /**
   * Returns the number of tests in the collection.
   * @returns {number} The total number of tests.
   */
  testsNumber() {
    return this.tests.length;
  }
}

exports.PRDC_JSLAB_TESTS = PRDC_JSLAB_TESTS;

/**
 * Represents an individual test within a test suite.
 */
class PRDC_JSLAB_TEST {

  /**
   * Initializes a new test with a name and a test function.
   * @param {string} name The name of the test.
   * @param {Function} fun The function to execute as the test.
   */
  constructor(name, fun) {
    this.name = name;
    this.fun = fun;
  }
  
  /**
   * Executes the test function and returns the result.
   * @returns {boolean} The result of the test function execution, true for pass and false for fail.
   */
  run() {
    return this.fun();
  }
}

exports.PRDC_JSLAB_TEST = PRDC_JSLAB_TEST;

\end{lstlisting}

% ------------------------------
\subsection{code}


\begin{lstlisting}[style=JavaScriptStyle, caption={custom-javascript-hint.js}]
/**
 * @file Edited CodeMirror javascript-hints.js
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 *
 * CodeMirror, copyright (c) by Marijn Haverbeke and others
 * Distributed under an MIT license: https://codemirror.net/LICENSE
 *
 */

(function(mod) {
  if(typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"));
  else if(typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  var Pos = CodeMirror.Pos;

  function scriptHint(editor, keywords, getToken, options) {

    // Find the token at the cursor
    var cur = editor.getCursor(), token = getToken(editor, cur);
    if(/\b(?:string|comment)\b/.test(token.type)) return;
    var innerMode = CodeMirror.innerMode(editor.getMode(), token.state);
    if(innerMode.mode.helperType === "json") return;
    token.state = innerMode.state;

    // If it's not a 'word-style' token, ignore the token.
    if(!/^[\w$_]*$/.test(token.string)) {
      token = {start: cur.ch, end: cur.ch, string: "", state: token.state,
               type: token.string == "." ? "property" : null};
    } else if(token.end > cur.ch) {
      token.end = cur.ch;
      token.string = token.string.slice(0, cur.ch - token.start);
    }

    var tprop = token;
    // If it is a property, find out what it is a property of.
    while(tprop.type == "property") {
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if(tprop.string != ".") return;
      tprop = getToken(editor, Pos(cur.line, tprop.start));
      if(!context) var context = [];
      context.push(tprop);
    }
    return getCompletions(token, context, keywords, options, cur);
  }

  function javascriptHint(editor,callback, options) {
    return scriptHint(editor, javascriptKeywords,
                      function(e, cur) { return e.getTokenAt(cur);},
                      options);
  }
  CodeMirror.registerHelper("hint", "javascript", javascriptHint);


  var javascriptKeywords = ("break case catch class const continue debugger default delete do else export extends false finally for function " +
                  "if in import instanceof new null return super switch this throw true try typeof var void while with yield").split(" ");

  function getCompletions(token, context, keywords, options, cur) {
    return new Promise(function(resolve) {
      ipcRenderer.invoke('get-completions', [token.string, JSON.stringify(context), keywords]).then(function(found) {
        resolve({list: found,
            from: Pos(cur.line, token.start),
            to: Pos(cur.line, token.end)});
      });
    });
  }
});

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={custom-search.js}]
/**
 * @file Edited CodeMirror search.js
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 *
 * CodeMirror, copyright (c) by Marijn Haverbeke and others
 * Distributed under an MIT license: https://codemirror.net/LICENSE
 *
 */
 
(function(mod) {
  if(typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("./searchcursor"));
  else if(typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./searchcursor"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  function searchOverlay(query, caseInsensitive) {
    if(typeof query == "string")
      query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$JSLAB_SOURCE_CODE_DATA$"), caseInsensitive ? "gi" : "g");
    else if(!query.global)
      query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");

    return {token: function(stream) {
      query.lastIndex = stream.pos;
      var match = query.exec(stream.string);
      if(match && match.index == stream.pos) {
        stream.pos += match[0].length || 1;
        return "searching";
      } else if(match) {
        stream.pos = match.index;
      } else {
        stream.skipToEnd();
      }
    }};
  }

  function SearchState() {
    this.posFrom = this.posTo = this.lastQuery = this.query = null;
    this.overlay = null;
  }

  function getSearchState(cm) {
    return cm.state.search || (cm.state.search = new SearchState());
  }

  function queryCaseInsensitive(query) {
    return typeof query == "string" && query == query.toLowerCase();
  }

  function getSearchCursor(cm, query, pos) {
    // Heuristic: if the query string is all lowercase, do a case insensitive search.
    return cm.getSearchCursor(query, pos, { caseFold: queryCaseInsensitive(query), multiline: true });
  }

  function persistentDialog(cm, text, deflt, onEnter, onKeyDown) {
    cm.openDialog(text, onEnter, {
      value: deflt,
      selectValueOnOpen: true,
      closeOnEnter: false,
      onClose: function() { clearSearch(cm); },
      onKeyDown: onKeyDown
    });
  }

  function dialog(cm, text, shortText, deflt, f) {
    if(cm.openDialog) cm.openDialog(text, f, { value: deflt, selectValueOnOpen: true });
    else f(prompt(shortText, deflt));
  }

  function confirmDialog(cm, text, shortText, fs) {
    if(cm.openConfirm) cm.openConfirm(text, fs);
    else if(confirm(shortText)) fs[0]();
  }

  function parseString(string) {
    return string.replace(/\\([nrt\\])/g, function(match, ch) {
      if(ch == "n") return "\n";
      if(ch == "r") return "\r";
      if(ch == "t") return "\t";
      if(ch == "\\") return "\\";
      return match;
    });
  }

  function parseQuery(query) {
    var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
    if(isRE) {
      try { query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i"); }
      catch(e) {}
    } else {
      query = parseString(query);
    }
    if(typeof query == "string" ? query == "" : query.test(""))
      query = /x^/;
    return query;
  }

  function startSearch(cm, state, query) {
    state.queryText = query;
    state.query = parseQuery(query);
    cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
    state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
    cm.addOverlay(state.overlay);
    if(cm.showMatchesOnScrollbar) {
      if(state.annotate) { state.annotate.clear(); state.annotate = null; }
      state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));
    }
  }

  function showSearchDialog(cm) {
    cm.display.wrapper.querySelector(".CodeMirror-search-dialog")
      .style.display = 'block';
    cm.display.wrapper.querySelector(".CodeMirror-search-find").focus();
  }
 
  function hideSearchDialog(cm) {
    cm.display.wrapper.querySelector(".CodeMirror-search-dialog")
      .style.display = 'none';
  }
 
  function doSearch(cm, rev, persistent, immediate) {
    var state = getSearchState(cm);
    if(state.query) return findNext(cm, rev);
    var q = cm.getSelection() || state.lastQuery;
    if(q instanceof RegExp && q.source == "x^") q = null;
    if(persistent && cm.openDialog) {
      var hiding = null;
      var searchNext = function(query, event) {
        CodeMirror.e_stop(event);
        if(!query) return;
        if(query != state.queryText) {
          startSearch(cm, state, query);
          state.posFrom = state.posTo = cm.getCursor();
        }
        if(hiding) hiding.style.opacity = 1;
        findNext(cm, event.shiftKey, function(_, to) {
          var dialog;
          if(to.line < 3 && document.querySelector &&
              (dialog = cm.display.wrapper.querySelector(".CodeMirror-dialog")) &&
              dialog.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top)
            (hiding = dialog).style.opacity = 0.4;
        });
      };
      persistentDialog(cm, getQueryDialog(cm), q, searchNext, function(event, query) {
        var keyName = CodeMirror.keyName(event);
        var extra = cm.getOption('extraKeys'), cmd = (extra && extra[keyName]) || CodeMirror.keyMap[cm.getOption("keyMap")][keyName];
        if(cmd == "findNext" || cmd == "findPrev" ||
          cmd == "findPersistentNext" || cmd == "findPersistentPrev") {
          CodeMirror.e_stop(event);
          startSearch(cm, getSearchState(cm), query);
          cm.execCommand(cmd);
        } else if(cmd == "find" || cmd == "findPersistent") {
          CodeMirror.e_stop(event);
          searchNext(query, event);
        }
      });
      if(immediate && q) {
        startSearch(cm, state, q);
        findNext(cm, rev);
      }
    } else {
      dialog(cm, getQueryDialog(cm), "Search for:", q, function(query) {
        if(query && !state.query) cm.operation(function() {
          startSearch(cm, state, query);
          state.posFrom = state.posTo = cm.getCursor();
          findNext(cm, rev);
        });
      });
    }
  }

  function findNext(cm, rev, callback) {cm.operation(function() {
    var state = getSearchState(cm);
    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
    if(!cursor.find(rev)) {
      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
      if(!cursor.find(rev)) return;
    }
    cm.setSelection(cursor.from(), cursor.to());
    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);
    state.posFrom = cursor.from(); state.posTo = cursor.to();
    if(callback) callback(cursor.from(), cursor.to());
  });}

  function clearSearch(cm) {cm.operation(function() {
    var state = getSearchState(cm);
    state.lastQuery = state.query;
    if(!state.query) return;
    state.query = state.queryText = null;
    cm.removeOverlay(state.overlay);
    if(state.annotate) { state.annotate.clear(); state.annotate = null; }
  });}


  function getQueryDialog(cm)  {
    return '<span class="CodeMirror-search-label">' + cm.phrase("Search:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use /re/ syntax for regexp search)") + '</span>';
  }
  function getReplaceQueryDialog(cm) {
    return ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use /re/ syntax for regexp search)") + '</span>';
  }
  function getReplacementQueryDialog(cm) {
    return '<span class="CodeMirror-search-label">' + cm.phrase("With:") + '</span> <input type="text" style="width: 10em" class="CodeMirror-search-field"/>';
  }
  function getDoReplaceConfirm(cm) {
    return '<span class="CodeMirror-search-label">' + cm.phrase("Replace?") + '</span> <button>' + cm.phrase("Yes") + '</button> <button>' + cm.phrase("No") + '</button> <button>' + cm.phrase("All") + '</button> <button>' + cm.phrase("Stop") + '</button> ';
  }

  function replaceAll(cm, query, text) {
    cm.operation(function() {
      for(var cursor = getSearchCursor(cm, query); cursor.findNext();) {
        if(typeof query != "string") {
          var match = cm.getRange(cursor.from(), cursor.to()).match(query);
          cursor.replace(text.replace(/\$(\d)/g, function(_, i) { return match[i]; }));
        } else cursor.replace(text);
      }
    });
  }

  function replace(cm, all) {
    if(cm.getOption("readOnly")) return;
    var query = cm.getSelection() || getSearchState(cm).lastQuery;
    var dialogText = '<span class="CodeMirror-search-label">' + (all ? cm.phrase("Replace all:") : cm.phrase("Replace:")) + '</span>';
    dialog(cm, dialogText + getReplaceQueryDialog(cm), dialogText, query, function(query) {
      if(!query) return;
      query = parseQuery(query);
      dialog(cm, getReplacementQueryDialog(cm), cm.phrase("Replace with:"), "", function(text) {
        text = parseString(text);
        if(all) {
          replaceAll(cm, query, text);
        } else {
          clearSearch(cm);
          var cursor = getSearchCursor(cm, query, cm.getCursor("from"));
          var advance = function() {
            var start = cursor.from(), match;
            if(!(match = cursor.findNext())) {
              cursor = getSearchCursor(cm, query);
              if(!(match = cursor.findNext()) ||
                  (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;
            }
            cm.setSelection(cursor.from(), cursor.to());
            cm.scrollIntoView({from: cursor.from(), to: cursor.to()});
            confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase("Replace?"),
                          [function() {doReplace(match);}, advance,
                           function() {replaceAll(cm, query, text);}]);
          };
          var doReplace = function(match) {
            cursor.replace(typeof query == "string" ? text :
                           text.replace(/\$(\d)/g, function(_, i) { return match[i]; }));
            advance();
          };
          advance();
        }
      });
    });
  }

  CodeMirror.commands.showSearchDialog = function(cm) { clearSearch(cm); showSearchDialog(cm); };
  CodeMirror.commands.hideSearchDialog = function(cm) { clearSearch(cm); hideSearchDialog(cm); };
  CodeMirror.commands.find = function(cm) { clearSearch(cm); doSearch(cm); };
  CodeMirror.commands.findPersistent = function(cm) { clearSearch(cm); doSearch(cm, false, true); };
  CodeMirror.commands.findPersistentNext = function(cm) { doSearch(cm, false, true, true); };
  CodeMirror.commands.findPersistentPrev = function(cm) { doSearch(cm, true, true, true); };
  CodeMirror.commands.findNext = doSearch;
  CodeMirror.commands.findPrev = function(cm) { doSearch(cm, true); };
  CodeMirror.commands.clearSearch = clearSearch;
  CodeMirror.commands.replace = replace;
  CodeMirror.commands.replaceAll = function(cm) { replace(cm, true); };
});

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={dialog-search.js}]
/**
 * @file Search dialog based on CodeMirror search.js
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 *
 * CodeMirror, copyright (c) by Marijn Haverbeke and others
 * Distributed under an MIT license: https://codemirror.net/LICENSE
 *
 */
 
(function(mod) {
  if(typeof exports == "object" && typeof module == "object") // CommonJS
    mod(require("../../lib/codemirror"), require("./searchcursor"));
  else if(typeof define == "function" && define.amd) // AMD
    define(["../../lib/codemirror", "./searchcursor"], mod);
  else // Plain browser env
    mod(CodeMirror);
})(function(CodeMirror) {
  "use strict";

  CodeMirror.defineOption('searchDialog', false, function(cm, val) {
    if(val) {
      var div = document.createElement('div');
      div.className = 'CodeMirror-search-dialog';
      div.innerHTML = '<input class="CodeMirror-search-find" value="" placeholder="Find" autocomplete="off" spellcheck="false" title="Find"><i class="CodeMirror-search-find-prev-btn" title="Previous match"></i><i class="CodeMirror-search-find-next-btn" title="Next match"></i><br class="clear"/><input class="CodeMirror-search-replace" value="" placeholder="Replace" autocomplete="off" spellcheck="false" title="Replace"><i class="CodeMirror-search-replace-btn" title="Replace"></i><i class="CodeMirror-search-replace-all-btn" title="Replace All"></i><br class="clear"/><i class="CodeMirror-search-case-btn" title="Match Case"></i><i class="CodeMirror-search-regex-btn" title="Use Regular Expression"></i><div class="CodeMirror-search-bottom-right"><span class="CodeMirror-search-current-match">0</span> of <span class="CodeMirror-search-total-matchs">0</span><i class="CodeMirror-search-close-btn" title="Close Search Dialog"></i></div><br class="clear"/>';
      div.setAttribute('tabindex', 0);
      
      var find_input = div.querySelector('.CodeMirror-search-find');
      var replace_input = div.querySelector('.CodeMirror-search-replace');
      var find_prev_btn = div.querySelector('.CodeMirror-search-find-prev-btn');
      var find_next_btn = div.querySelector('.CodeMirror-search-find-next-btn');
      var replace_btn = div.querySelector('.CodeMirror-search-replace-btn');
      var replace_all_btn = div.querySelector('.CodeMirror-search-replace-all-btn');
      var match_case_btn = div.querySelector('.CodeMirror-search-case-btn');
      var regex_btn = div.querySelector('.CodeMirror-search-regex-btn');
      var close = div.querySelector('.CodeMirror-search-close-btn');
      
      cm.search_match_case = false;
      cm.search_regex = false;
      
      div.addEventListener('keydown', function(e) {
        if(e.key == 'Escape') {
          // ESC
          if(window.jQuery) {
            $(div).slideUp(200);
          } else {
            div.style.display = 'none';
          }
          cm.focus();
        }
      });
      
      replace_input.addEventListener('keydown', function(e) {
        if(e.key == 'Enter') {
          // Replace
          replace(cm, replace_input.value, false);
        }
      });
      
      find_input.addEventListener('keyup', function() {
        // Find match
        clearSearch(cm); 
        var state = getSearchState(cm);
        state.query = this.value;
        doSearch(cm);
      });
      
      find_prev_btn.addEventListener('click', function() {
        // Show previous match
        doSearch(cm, true);
      });
      
      find_next_btn.addEventListener('click', function() {
        // Show next match
        doSearch(cm, false);
      });
      
      replace_btn.addEventListener('click', function() {
        // Replace
        replace(cm, replace_input.value, false)
      });
      
      replace_all_btn.addEventListener('click', function() {
        // Replace all
        replace(cm, replace_input.value, true)
      });
      
      match_case_btn.addEventListener('click', function() {
        if(this.classList.contains('active')) {
          cm.search_match_case = false;
          this.classList.remove('active');
        } else {
          cm.search_match_case = true;
          this.classList.add('active');
        }
      });
      
      regex_btn.addEventListener('click', function() {
        if(this.classList.contains('active')) {
          cm.search_regex = false;
          this.classList.remove('active');
        } else {
          cm.search_regex = true;
          this.classList.add('active');
        }
      });
      
      close.addEventListener('click', function() {
        if(window.jQuery) {
          $(div).slideUp(200);
        } else {
          div.style.display = 'none';
        }
        cm.focus();
      });
      
      cm.display.wrapper.appendChild(div);
    }
  });
  
  function searchOverlay(query, caseInsensitive) {
    if(typeof query == "string")
      query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$JSLAB_SOURCE_CODE_DATA$"), caseInsensitive ? "gi" : "g");
    else if(!query.global)
      query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");

    return {token: function(stream) {
      query.lastIndex = stream.pos;
      var match = query.exec(stream.string);
      if(match && match.index == stream.pos) {
        stream.pos += match[0].length || 1;
        return "searching";
      } else if(match) {
        stream.pos = match.index;
      } else {
        stream.skipToEnd();
      }
      return false;
    }};
  }

  function SearchState() {
    this.posFrom = this.posTo = this.lastQuery = this.query = null;
    this.overlay = null;
  }

  function getSearchState(cm) {
    return cm.state.search || (cm.state.search = new SearchState());
  }

  function queryCaseInsensitive(cm, query) {
    return !cm.search_match_case && typeof query == "string";
  }

  function getSearchCursor(cm, query, pos) {
    return cm.getSearchCursor(query, pos, {caseFold: queryCaseInsensitive(cm, query), multiline: true});
  }

  function parseString(string) {
    return string.replace(/\\([nrt\\])/g, function(match, ch) {
      if(ch == "n") return "\n";
      if(ch == "r") return "\r";
      if(ch == "t") return "\t";
      if(ch == "\\") return "\\";
      return match;
    });
  }

  function parseQuery(cm, query) {
    if(cm.search_regex) {
      var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
      if(isRE) {
        try { query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i"); }
        catch(e) {}
      }
    } else {
      query = parseString(query);
    }
    if(typeof query == "string" ? query == "" : query.test(""))
      query = /x^/;
    return query;
  }

  function startSearch(cm, state, query) {
    state.queryText = query;
    state.query = parseQuery(cm, query);
    cm.removeOverlay(state.overlay, queryCaseInsensitive(cm, state.query));
    state.overlay = searchOverlay(state.query, queryCaseInsensitive(cm, state.query));
    cm.addOverlay(state.overlay);
    if(state.annotate) { state.annotate.clear(); state.annotate = null; }
    state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(cm, state.query));
  }

  function showSearchDialog(cm) {
    var div = cm.display.wrapper.querySelector('.CodeMirror-search-dialog');
    if(window.jQuery) {
      $(div).slideDown(200);
    } else {
      div.style.display = 'block';
    }
    var query = cm.getSelection();
    var find_input = cm.display.wrapper.querySelector('.CodeMirror-search-find');
    if(query) {
      find_input.value = query;
      clearSearch(cm); 
      var state = getSearchState(cm);
      state.query = query;
      doSearch(cm);
    }
    find_input.focus();
  }
 
  function hideSearchDialog(cm) {
    var div = cm.display.wrapper.querySelector('.CodeMirror-search-dialog');
    if(window.jQuery) {
      $(div).slideUp(200);
    } else {
      div.style.display = 'none';
    }
  }
 
  function doSearch(cm, rev) {
    var state = getSearchState(cm);
    var q = state.query;
    if(q != state.queryText) {
      startSearch(cm, state, q);
      state.posFrom = state.posTo = cm.getCursor();
    }
    if(q) {
      findNext(cm, rev);
    }
    if(state.annotate) {
      var current_match_index = state.annotate.matches.findIndex(function(e) {
        return e.from.line == state.posFrom.line && 
          e.from.ch == state.posFrom.ch && e.to.line == state.posTo.line && 
          e.to.ch == state.posTo.ch;
      })+1;
      var total_matchs = cm.display.wrapper.querySelector('.CodeMirror-search-total-matchs');
      total_matchs.innerText = state.annotate.matches.length;
      var current_match = cm.display.wrapper.querySelector('.CodeMirror-search-current-match');
      current_match.innerText = current_match_index;
    }
  }

  function findNext(cm, rev, callback) {cm.operation(function() {
    var state = getSearchState(cm);
    var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
    if(!cursor.find(rev)) {
      cursor = getSearchCursor(cm, state.query, rev ? CodeMirror.Pos(cm.lastLine()) : CodeMirror.Pos(cm.firstLine(), 0));
      if(!cursor.find(rev)) return;
    }
    cm.setSelection(cursor.from(), cursor.to());
    cm.scrollIntoView({from: cursor.from(), to: cursor.to()}, 20);
    state.posFrom = cursor.from(); state.posTo = cursor.to();
    if(callback) callback(cursor.from(), cursor.to());
  });}

  function clearSearch(cm) {cm.operation(function() {
    var state = getSearchState(cm);
    state.lastQuery = state.query;
    if(!state.query) return;
    state.query = state.queryText = null;
    cm.removeOverlay(state.overlay);
    if(state.annotate) { state.annotate.clear(); state.annotate = null; }
  });}

  function replaceAll(cm, query, text) {
    clearSearch(cm);
    cm.operation(function() {
      for(var cursor = getSearchCursor(cm, query); cursor.findNext();) {
        if(typeof query != "string") {
          var match = cm.getRange(cursor.from(), cursor.to()).match(query);
          cursor.replace(text.replace(/\$(\d)/g, function(_, i) { return match[i]; }));
        } else cursor.replace(text);
      }
    });
  }

  function replace(cm, text, all) {
    if(cm.getOption("readOnly")) return;
    var query = getSearchState(cm).query;
    if(query) {
      text = parseString(text);
      if(all) {
        replaceAll(cm, query, text);
      } else {
        var cursor = getSearchCursor(cm, query, cm.getCursor());
        var start = cursor.from(), match;
        if(!(match = cursor.findNext())) {
          cursor = getSearchCursor(cm, query);
          if(!(match = cursor.findNext()) ||
            (start && cursor.from().line == start.line && cursor.from().ch == start.ch)) return;
        }
        cm.setSelection(cursor.from(), cursor.to());
        cursor.replace(typeof query == "string" ? text :
          text.replace(/\$(\d)/, function(w, i) {return match[i];}));
      }
    }
  }
  
  CodeMirror.commands.showSearchDialog = function(cm) {clearSearch(cm); showSearchDialog(cm);};
  CodeMirror.commands.hideSearchDialog = function(cm) {clearSearch(cm); hideSearchDialog(cm);};
  CodeMirror.commands.find = function(cm) {clearSearch(cm); doSearch(cm);};
  CodeMirror.commands.findNext = function(cm) {doSearch(cm, false);};
  CodeMirror.commands.findPrev = function(cm) {doSearch(cm, true);};
  CodeMirror.commands.clearSearch = clearSearch;
  CodeMirror.commands.replace = replace;
  CodeMirror.commands.replaceAll = function(cm) {replace(cm, true);};
});

\end{lstlisting}

% ------------------------------
\subsection{dev}


\begin{lstlisting}[style=JavaScriptStyle, caption={build-configure.js}]
/**
 * @file Native modules build
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */
 
// Import the filesystem module
const fs = require('fs');

global.process_arguments = process.argv;
require('../init-config.js');

console.log('[build-configure.js] Started');
var t = performance.now();

// Change package.json
console.log('Changing package.json...');
var data = JSON.parse(fs.readFileSync('package.json'));
var filename = data.name+'_'+data.version;
if(process.argv.length > 3) {
  var action = process.argv[3];
  if(action == 'dist-portable') {
    filename += '_portable';
  }
}

data.build.artifactName = filename+'.${ext}';

if(config.SIGN_BUILD) {
  data.build.win.sign = "js/dev/build-sign.js";
} else {
  delete data.build.win.sign;
}

fs.writeFileSync('package.json', JSON.stringify(data, null, 2));

// Creating binding.gyp
console.log('Creating binding.gyp...');
var binding_data = {targets: []};

// - Native module
if(fs.existsSync('cpp/binding.gyp')) {
  var data = JSON.parse(fs.readFileSync('cpp/binding.gyp'));
  if(!Array.isArray(data)) {
    data = [data];
  }
  for(var i = 0; i < data.length; i++) {
    binding_data.targets[i] = data[i];
    binding_data.targets[i].defines = ["NAPI_DISABLE_CPP_EXCEPTIONS"];
  }
}

// - Libs binding.gyp
config.COMPILE_LIBS.forEach(function(lib) {
  var data = JSON.parse(fs.readFileSync('lib/'+lib+'/binding.gyp'));
  binding_data.targets.push(data);
});

// - Save binding.gyp
fs.writeFileSync('binding.gyp', JSON.stringify(binding_data, null, 2));

// Create bin folder
if(!fs.existsSync('bin/')) {
  fs.mkdirSync('bin/');
}

console.log('[build-configure.js] ' + ((performance.now()-t)/1000).toFixed(3) + ' s');
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={build-sign.js}]
/**
 * @file Build sign
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */
 
require('../init-config.js');

console.log('[build-sign.js] Started');
var t = performance.now();

if(!process.env.COMPANY_NAME) {
  console.error('Environment variable COMPANY_NAME must be defined!');
}
if(!process.env.TIMESTAMP_SERVER) {
  console.error('Environment variable TIMESTAMP_SERVER must be defined!');
}
if(!process.env.SIGN_TOOL_PATH) {
  console.error('Environment variable SIGN_TOOL_PATH must be defined!');
}

const { execSync } = require('child_process');


/**
 * Signs a specified file using the digital signature tool and parameters defined in the application's configuration. The
 * function reads the configuration to obtain the path to the signing tool, the company name for the signature, and other
 * necessary parameters. It then constructs the command to execute the signing process and runs it using `execSync`.
 * 
 * @param {Object} data - An object containing parameters for the signing process.
 * @param {string} data.path - The path to the file that needs to be signed.
 * @param {string} data.hash - The hash algorithm to use for signing (e.g., 'sha256').
 */
exports.default = function(data) {
  console.info('Signing '+data.path+' with '+data.hash+' to '+config.COMPANY_NAME);
  
  const sha256 = data.hash === 'sha256';
  const appendCert = sha256 ? '/as' : null;
  const timestamp = sha256 ? '/tr' : '/t';
  const appendTd = sha256 ? '/td sha256' : null;

  let args = [
    '"'+config.SIGN_TOOL_PATH+'"',
    'sign',
    '/debug',
    '/n',
    '"'+config.COMPANY_NAME+'"',
    '/a',
    appendCert,
    '/fd',
    data.hash,
    timestamp,
    config.TIMESTAMP_SERVER,
    appendTd,
    '/v',
    `"${data.path}"`
  ];

  try {
    const { stdout } = execSync(args.join(' '));
    console.log(stdout);
  } catch(err) {
    throw err;
  }
  
  console.log('[build-sign.js] ' + ((performance.now()-t)/1000).toFixed(3) + ' s');
};
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={clear-app-data.js}]
/**
 * @file Clear app data
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */
 
// Import modules
const fs = require('fs');
const os = require('os');
const rimraf = require('rimraf');
const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});

var data = JSON.parse(fs.readFileSync('package.json'));

console.log('[clear-app-data.js] Started');
var t = performance.now();

// Variables
var confirm = process.argv.includes('--confirm');

if(confirm) {
  readline.question("Clear app data? yes/[no]: ", function(answer) {
    if(answer == 'yes') {
      main();
    } else {
      console.log('Action aborted.');
      console.log('[clear-app-data.js] Execution done in ' + ((performance.now()-t)/1000).toFixed(3) + ' s');
      process.exit();
    }
    readline.close();
  });
} else {
  main();
}

function main() {
  var path = os.homedir()+'\\AppData\\Roaming\\'+data.name;
  console.log('Clearing app data from '+path);
  rimraf.sync(path);
  
  console.log('[clear-app-data.js] Execution done in ' + ((performance.now()-t)/1000).toFixed(3) + ' s');
  process.exit();
}

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={download-libs.js}]
/**
 * @file Download libs
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */
 
// Import modules
const fs = require('fs');
const rimraf = require('rimraf');
const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout
});
const path = require('path');
const { extractFull } = require('node-7z');
const bin_path = require('7zip-bin').path7za;

require('../init-config.js');

console.log('[dev-download-libs.js] Started');
var t = performance.now();

// Variables
var force = process.argv.includes('--force');
var confirm = process.argv.includes('--confirm');

if(confirm) {
  readline.question("Download libs? yes/[no]: ", function(answer) {
    if(answer == 'yes') {
      main();
    } else {
      console.log('Libs download aborted.');
      console.log('[dev-download-libs.js] Execution done in ' + ((performance.now() - t) / 1000).toFixed(3) + ' s');
      process.exit();
    }
    readline.close();
  });
} else {
  main();
}

async function main() {
  if(force) {
    console.log('Deleting all libs...');
    rimraf.sync('./lib');
  }

  for(const lib of config.USED_LIBS) {
    const libDir = path.join('./lib', lib);
    const serverLibDir = path.join(config.SERVER_LIBS_PATH, lib);
    const serverLib7z = path.join(config.SERVER_LIBS_PATH, `${lib}.7z`);
    const lib7z = path.join('./lib', `${lib}.7z`);

    // Check if lib folder exists locally
    if(!fs.existsSync(libDir)) {
      if(fs.existsSync(serverLibDir)) {
        process.stdout.write(`Downloading ${lib}...`);
        await fs.promises.cp(serverLibDir, libDir, { recursive: true });
        process.stdout.clearLine(0);
        process.stdout.cursorTo(0);
        console.log(`Downloading of ${lib} complete.`);
      } else if(fs.existsSync(serverLib7z)) {
        await copyWithProgress(lib, serverLib7z, lib7z);
        await extractWithProgress(lib, lib7z, './lib');
      } else {
        console.log(`[ERROR] Neither folder nor .7z found for ${lib}.`);
      }
    } else {
      console.log(`Lib ${lib} already downloaded.`);
    }
  }

  console.log('\nAll libraries downloaded.');
  console.log('[download-libs.js] Execution done in ' + ((performance.now() - t) / 1000).toFixed(3) + ' s');
  process.exit();
}

// Function to copy files with progress
async function copyWithProgress(lib, src, dest) {
  return new Promise((resolve, reject) => {
    const total_size = fs.statSync(src).size;
    let copied = 0;

    const read_stream = fs.createReadStream(src);
    const write_stream = fs.createWriteStream(dest);

    read_stream.on('data', (chunk) => {
      copied += chunk.length;
      const progress = ((copied / total_size) * 100).toFixed(2);

      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      process.stdout.write(`Downloading ${lib}: ${progress}% (${copied}/${total_size})`);
    });

    read_stream.pipe(write_stream);

    write_stream.on('finish', () => {
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      console.log(`Downloading of ${lib} complete.`);
      resolve();
    });

    read_stream.on('error', reject);
    write_stream.on('error', reject);
  });
}

// Function to extract .7z with progress
async function extractWithProgress(lib, archive, dest) {
  return new Promise((resolve, reject) => {
    const extractor = extractFull(archive, dest, {
      $bin: bin_path,
      $progress: true
    });

    extractor.on('progress', (progress) => {
      const percent = progress.percent.toFixed(0);
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      process.stdout.write(`Extracting ${lib}: ${percent}%`);
    });

    extractor.on('end', () => {
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      console.log(`Extraction of ${lib} complete.`);
      fs.unlinkSync(archive);
      resolve();
    });

    extractor.on('error', (err) => {
      console.error(`Extraction error for ${lib}:`, err);
      fs.unlinkSync(archive);
      reject(err);
    });
  });
}
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={make-doc.js}]
/**
 * @file Generate sandbox documentation for JSLAB
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */

const jsdoc = require('jsdoc-api');
const fs = require('fs');
const cp = require("child_process");
const rimraf = require('rimraf');

require('../init-config.js');

console.log('[make-doc.js] Started');
var t = performance.now();

var package_data = JSON.parse(fs.readFileSync('package.json'));
var app_version = package_data.version;
var year = new Date().getFullYear();

var jslab_doc = {
  'global': {},
  'lib': {}
};

async function processDoc(module) {
  var docs_out;
  if(config.OUTPUT_COMPLETE_JSDOC) {
    docs_out = [];
  } else {
    docs_out = {};
  }
  var docs = await jsdoc.explain({ files: 'js/sandbox/'+module.file+'.js' });
  docs.forEach(function(doc) {
    if(config.OUTPUT_COMPLETE_JSDOC) {
      docs_out.push(doc);
    } else if((doc.kind == 'function' || doc.kind == 'member') && 
        doc.memberof == module.class_name && 
        !doc.name.startsWith('_') && 
        !doc.name.startsWith('#') && 
        doc.name != 'jsl' && 
        doc.description) {
      var doc_output = {};
      doc_output.name = doc.name;
      doc_output.kind = doc.kind;
      doc_output.description = doc.description;
      if(doc.params) {
        doc_output.params = doc.params;
      }
      if(doc.returns) {
        doc_output.returns = doc.returns;
      }
      if(doc.async) {
        doc_output.async = doc.async;
      }
      if(doc.meta) {
        doc_output.source_filename = doc.meta.filename;
        doc_output.source_lineno = doc.meta.lineno;
        doc_output.source_range = doc.meta.range;
      }
      docs_out[doc.name] = doc_output;
    }
  });
  return docs_out;
}

(async function main() {
  config.SUBMODULES['builtin'].push(...config.DOC_SUBMODULES_ADDITIONAL);
  for(var module of config.SUBMODULES['builtin']) { 
    console.log(' Generating documentation for: global/' + module.name);
    jslab_doc['global'][module.name] = await processDoc(module);
  }
  for(var lib of config.SUBMODULES['lib']) {
    console.log(' Generating documentation for: lib/' + lib.name);
    jslab_doc['lib'][lib.name] = await processDoc(lib);
  }
  var jslab_doc_flat = Object.values(jslab_doc).reduce((acc, innerObj) => {
    return { ...acc, ...innerObj };
  }, {});
  if(config.OUTPUT_COMPLETE_JSDOC) {
    return;
  }
  
  // Make JSON documentation
  console.log(' Making documentation.json');
  fs.writeFileSync('docs/documentation.json', JSON.stringify(jslab_doc, null, 2));
  
  // Make HTML documentation
  console.log(' Making documentation.html');
  var html_template = fs.readFileSync('dev/documentation_template.html', 'utf8');
  html_template = html_template.replaceAll('$JSLAB_CODE_DATA

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}, JSON.stringify(jslab_doc_flat, null, 2));
  html_template = html_template.replaceAll('$JSLAB_APP_VERSION

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}, '"v'+app_version+'"');
  html_template = html_template.replaceAll('$JSLAB_PUBLISH_YEAR

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}, '"'+year+'"');
  fs.writeFileSync('docs/documentation.html', html_template);
  
  // Make tex
  console.log(' Making documentation.tex');
  var latex_template = fs.readFileSync('dev/documentation_template.tex', 'utf8');
  latex_template = latex_template.replaceAll('$JSLAB_APP_VERSION

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}, 'v'+app_version+'');
  latex_template = latex_template.replaceAll('$JSLAB_PUBLISH_YEAR

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}, year);
  
  function getLatexByCodeCategory(category) {
    // Helper function to escape LaTeX special characters
    function escapeLatex(string) {
      if(typeof string !== 'string') {
        return string;
      }
      return string
        .replace(/\\/g, '\\textbackslash{}')
        .replace(/&/g, '\\&')
        .replace(/%/g, '\\%')
        .replace(/\$/g, '\\

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document})
        .replace(/#/g, '\\#')
        .replace(/_/g, '\\_')
        .replace(/{/g, '\\{')
        .replace(/}/g, '\\}')
        .replace(/~/g, '\\textasciitilde{}')
        .replace(/\^/g, '\\textasciicircum{}')
        .replace(/`/g, '\\textasciigrave{}');
    }

    let latex = '';

    // Iterate over each item in the specified category
    latex += `\\subsection{${escapeLatex(category)}}\n`;
    
    for(const item_name in jslab_doc_flat[category]) {
      const item = jslab_doc_flat[category][item_name];

      if(item.kind === 'function') {
        // Generate the function signature
        const params = item.params
          ? item.params
              .map(param => {
                if(param.type === 'Object' && param.properties) {
                  // Generate nested object structure for 'opts'
                  const nestedSignature = param.properties
                    .map(prop =>
                      prop.optional
                        ? `[${escapeLatex(prop.name)}]`
                        : `${escapeLatex(prop.name)}`
                    )
                    .join(', ');

                  // Format the 'opts' parameter
                  return param.optional
                    ? `[${escapeLatex(param.name)}\\{ ${nestedSignature} \\}]`
                    : `${escapeLatex(param.name)}\\{ ${nestedSignature} \\}`;
                } else {
                  // Handle simple parameters with optionality and default values
                  return param.optional
                    ? `[${escapeLatex(param.name)}${param.default ? `=${escapeLatex(param.default)}` : ''}]`
                    : `${escapeLatex(param.name)}${param.default ? `=${escapeLatex(param.default)}` : ''}`;
                }
              })
              .join(', ')
          : "";

        // Add a title for the function
        latex += `\\vspace{5mm}\n\\noindent \\codeBlock{\\texttt{${escapeLatex(item.name)}(${params})}}{\\color{jsl-gray}\\vspace{2mm}\\hrule\\vspace{4mm}}\n\n`;

        // Add metadata if available
        if(item.since) {
          latex += `\\textbf{Added in:} v${escapeLatex(item.since)}\\\\\n`;
        }

        // Add parameters section
        if(item.params && item.params.length > 0) {
          latex += `\n\\noindent \\textbf{Parameters:}\n\\begin{itemize}\n`;
          item.params.forEach(param => {
            const type = param.type && param.type.names && param.type.names[0] ? param.type.names[0] : 'Unknown';
            latex += `  \\item \\texttt{${escapeLatex(param.name)}} \\texttt{<${escapeLatex(type)}>}: ${escapeLatex(param.description || '')}\n`;
          });
          latex += `\\end{itemize}\n`;
        }

        // Add returns section
        if(item.returns && item.returns.length > 0) {
          const returnType = item.returns[0].type && item.returns[0].type.names && item.returns[0].type.names[0] ? item.returns[0].type.names[0] : 'Unknown';
          latex += `\n\\noindent \\textbf{Returns:} \\texttt{<${escapeLatex(returnType)}>}: ${escapeLatex(item.returns[0].description || '')}\n`;
        }

        // Add description
        if(item.description) {
          latex += `\n\\noindent ${escapeLatex(item.description)}\n\n`;
        }

        // Add examples if available
        if(item.examples && item.examples.length > 0) {
          latex += `\\begin{verbatim}\n${escapeLatex(item.examples[0])}\n\\end{verbatim}\n\n`;
        }

      } else if(item.kind === 'member') {
        // Add a title for the member
        latex += `\\vspace{5mm}\n\\noindent \\code{\\texttt{${escapeLatex(item.name)}}}{\\color{jsl-gray}\\vspace{2mm}\\hrule}\\vspace{4mm}\n\n`;

        // Add metadata if available
        if(item.since) {
          latex += `\\textbf{Added in:} v${escapeLatex(item.since)}\\\\\n`;
        }

        // Add type information
        const type = item.type && item.type.names && item.type.names[0] ? item.type.names[0] : 'Unknown';
        latex += `\n\\noindent \\textbf{Type:} \\texttt{<${escapeLatex(type)}>}\n`;

        // Add description
        if(item.description) {
          latex += `\n\\noindent ${escapeLatex(item.description)}\n\n`;
        }
      }
    }
    
    latex += '\n';
    
    return latex;
  }

  var latex_text = '';
  for(const category in jslab_doc_flat) {
    latex_text += getLatexByCodeCategory(category);
  }
  latex_template = latex_template.replaceAll('$JSLAB_CODE_DATA

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}, latex_text);
  fs.writeFileSync('docs/documentation.tex', latex_template);

  // Make pdf
  console.log(' Making documentation.pdf');
  
  var dir = __dirname + '/../../dev/latex/';
  var file = dir + 'documentation.tex';
  fs.mkdirSync(dir, { recursive: true });
  fs.copyFileSync('docs/documentation.tex', file);
  fs.cpSync('docs/resources/', dir + 'resources/', { recursive: true });
  
  for(var i = 0; i < config.DOC_LATEX_RERUNS_NUMBER; i++) {
    console.log(' Run ' + (i+1) + '/' + config.DOC_LATEX_RERUNS_NUMBER);
    try {
      cp.execSync('cd ' + dir + ' & pdflatex documentation.tex --interaction=nonstopmode', { cwd: dir });
    } catch(e) {
      if(!fs.existsSync(dir + 'documentation.pdf') || (e.output && 
          e.output.toString().trim().split('\n').pop().toLowerCase().includes('fatal'))) {
        console.log(' LaTeX compile failed! Add path to pdflatex to environment variables and try again with MiKTeX 24.1 or later. Output: ');
        if(e.output) {
          console.log(e.output.toString());
        } else {
          console.log(e);
        }
        break;
      }
    }
  }
  if(fs.existsSync(dir + 'documentation.pdf')) {
    fs.copyFileSync(dir + 'documentation.pdf', 'docs/documentation.pdf');
  }
  rimraf.sync(dir);

  console.log('[make-doc.js] ' + ((performance.now()-t)/1000).toFixed(3) + ' s');
})();

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={make-source-code-book.js}]
/**
 * @file Generate source code book for JSLAB
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */

const fs = require('fs');
const path = require('path');
const cp = require("child_process");
const rimraf = require('rimraf');

require('../init-config.js');

console.log('[make-source-code-book.js] Started');
var t = performance.now();

var package_data = JSON.parse(fs.readFileSync('package.json'));
var app_version = package_data.version;
var year = new Date().getFullYear();

var levels = ['\\section', '\\subsection', '\\subsubsection'];
var latex = '';

var SOURCE_CODE_BOOK_FILES_EXCLUDE = config.SOURCE_CODE_BOOK_FILES_EXCLUDE.map(p => path.resolve(p));

// Helper function for excluding
function isExcluded(absolutePath) {
  if(SOURCE_CODE_BOOK_FILES_EXCLUDE.includes(absolutePath)) return true;
  return SOURCE_CODE_BOOK_FILES_EXCLUDE.some(dir => absolutePath.startsWith(dir + path.sep));
}

// Helper function to escape LaTeX special characters
function escapeLatex(string) {
  if(typeof string !== 'string') {
    return string;
  }
  return string
    .replace(/\\/g, '\\textbackslash{}')
    .replace(/&/g, '\\&')
    .replace(/%/g, '\\%')
    .replace(/\$/g, '\\

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document})
    .replace(/#/g, '\\#')
    .replace(/_/g, '\\_')
    .replace(/{/g, '\\{')
    .replace(/}/g, '\\}')
    .replace(/~/g, '\\textasciitilde{}')
    .replace(/\^/g, '\\textasciicircum{}')
    .replace(/`/g, '\\textasciigrave{}');
}
    
/**
 * Recursively traverses directories and reads file contents.
 * @param {string[]} pathsList - List of file or folder paths to process.
 * @returns {Promise<Object>} - An object representing the directory structure with file details.
 */
async function buildFileStructure(pathsList) {
  const result = {root:{}};

  for(const itemPath of pathsList) {
    const absolutePath = path.resolve(itemPath);
    if(isExcluded(absolutePath)) continue;
    
    const stats = await fs.promises.lstat(absolutePath);

    if(stats.isDirectory()) {
      // Recursively process the directory
      result[path.basename(absolutePath)] = await traverseDirectory(absolutePath);
    } else if(stats.isFile()) {
      result['root'][path.basename(absolutePath)] = await fs.promises.readFile(absolutePath, 'utf-8');
    }
  }

  return result;
}

/**
 * Helper function to traverse a directory recursively.
 * @param {string} dirPath - The directory path to traverse.
 * @returns {Promise<Object>} - An object representing the directory structure.
 */
async function traverseDirectory(dirPath) {
  if(isExcluded(dirPath)) return {};
  
  const dirContents = await fs.promises.readdir(dirPath, { withFileTypes: true });
  const dirObject = {};

  // Separate files and directories
  const files = dirContents.filter(dirent => dirent.isFile());
  const directories = dirContents.filter(dirent => dirent.isDirectory());

  // Process files first
  for(const file of files) {
    const fullPath = path.join(dirPath, file.name);
    if(isExcluded(fullPath)) continue;
    dirObject[file.name] = await fs.promises.readFile(fullPath, 'utf-8');
  }

  // Then process directories
  for(const directory of directories) {
    const fullPath = path.join(dirPath, directory.name);
    if(isExcluded(fullPath)) continue;
    dirObject[directory.name] = await traverseDirectory(fullPath);
  }

  return dirObject;
}

/**
 * Determines the programming language based on the file extension.
 * @param {string} filename - The name of the file (e.g., "main.cpp").
 * @returns {string|null} - The corresponding language name or null if unknown.
 */
function getLanguage(filename) {
  const extensionMatch = filename.match(/\.([^.]+)$/);
  if(!extensionMatch) {
    return null;
  }

  const extension = extensionMatch[1].toLowerCase();

  // Mapping of extensions to languages
  const extensionToLanguageMap = {
    'cpp': 'C++',
    'h': 'C++',
    'js': 'JavaScript',
    'json': 'JavaScript',
    'gyp': 'JavaScript',
    'css': 'CSS',
    'html': 'HTML'
  };

  return extensionToLanguageMap[extension] || null;
}

/**
 * Recursively traverses an object and performs actions based on the type of each property.
 * @param {Object} obj - The object to traverse.
 * @param {Function} callback - A function to execute on each property.
 * @param {number} [level=0] - The current recursion level (used internally).
 */
function traverseObject(obj, level = 0) {
  for(const key in obj) {
    if(obj.hasOwnProperty(key)) {
      if(typeof obj[key] === 'object' && obj[key] !== null) {
        latex += '\n% ' + '----------'.repeat(4-level) + '\n' + levels[level] + '{' + escapeLatex(key) + '}\n\n';
        traverseObject(obj[key], level + 1);
      } else {
        latex += `
\\begin{lstlisting}[style=${getLanguage(key)}Style, caption={${escapeLatex(key)}}]
${obj[key]}
\\end{lstlisting}
`;
      }
    }
  }
}

(async function main() {
  // Make tex
  console.log(' Making source-code-book.tex');
  var latex_template = fs.readFileSync('dev/source_code_template.tex', 'utf8');
  latex_template = latex_template.replaceAll('$JSLAB_APP_VERSION

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}, 'v'+app_version+'');
  latex_template = latex_template.replaceAll('$JSLAB_PUBLISH_YEAR

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}, year);
  
  var app_path = __dirname + '/../../';
  var fileStructure = await buildFileStructure(config.SOURCE_CODE_BOOK_FILES);
  traverseObject(fileStructure);
  latex_template = latex_template.replaceAll('$JSLAB_SOURCE_CODE_DATA

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}, latex);
  fs.writeFileSync('docs/source-code-book.tex', latex_template);

  // Make pdf
  console.log(' Making source-code-book.pdf');
  
  var dir = __dirname + '/../../dev/latex/';
  var file = dir + 'source-code-book.tex';
  fs.mkdirSync(dir, { recursive: true });
  fs.copyFileSync('docs/source-code-book.tex', file);
  
  for(var i = 0; i < config.SOURCE_CODE_BOOK_LATEX_RERUNS_NUMBER; i++) {
    console.log(' Run ' + (i+1) + '/' + config.SOURCE_CODE_BOOK_LATEX_RERUNS_NUMBER);
    try {
      cp.execSync('cd ' + dir + ' & pdflatex source-code-book.tex --interaction=nonstopmode', { cwd: dir });
    } catch(e) {
      if(!fs.existsSync(dir + 'source-code-book.pdf') || (e.output && 
          e.output.toString().trim().split('\n').pop().toLowerCase().includes('fatal'))) {
        console.log(' LaTeX compile failed! Add path to pdflatex to environment variables and try again with MiKTeX 24.1 or later. Output: ');
        if(e.output) {
          console.log(e.output.toString());
        } else {
          console.log(e);
        }
        break;
      }
    }
  }
  if(fs.existsSync(dir + 'source-code-book.pdf')) {
    fs.copyFileSync(dir + 'source-code-book.pdf', 'docs/source-code-book.pdf');
  }
  rimraf.sync(dir);

  console.log('[make-source-code-book.js.js] ' + ((performance.now()-t)/1000).toFixed(3) + ' s');
})();

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={prepare-libs.js}]
/**
 * @file Prepare libs
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */
 
// Import modules
const fs = require('fs');
const rimraf = require('rimraf');
const path = require('path');
const { extractFull } = require('node-7z');
const bin_path = require('7zip-bin').path7za;

require('../init-config.js');

console.log('[prepare-libs.js] Started');
var t = performance.now();

async function main() {
  for(const lib of config.COMPRESSED_LIBS) {
    const lib_dir = path.join('./lib', lib);
    const lib_7z = path.join('./lib', `${lib}.7z`);

    // Check if lib folder exists locally
    if(!fs.existsSync(lib_dir)) {
      await extractWithProgress(lib, lib_7z, './lib');
    } else {
      console.log(`Lib ${lib} already uncompressed.`);
    }
  }

  console.log('\nAll libraries ready.');
  console.log('[prepare-libs.js] Execution done in ' + ((performance.now() - t) / 1000).toFixed(3) + ' s');
}

main();

// Function to extract .7z with progress
async function extractWithProgress(lib, archive, dest) {
  return new Promise((resolve, reject) => {
    const extractor = extractFull(archive, dest, {
      $bin: bin_path,
      $progress: true
    });

    extractor.on('progress', (progress) => {
      const percent = progress.percent.toFixed(0);
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      process.stdout.write(`Extracting ${lib}: ${percent}%`);
    });

    extractor.on('end', () => {
      process.stdout.clearLine(0);
      process.stdout.cursorTo(0);
      console.log(`Extraction of ${lib} complete.`);
      fs.unlinkSync(archive);
      resolve();
    });

    extractor.on('error', (err) => {
      console.error(`Extraction error for ${lib}:`, err);
      fs.unlinkSync(archive);
      reject(err);
    });
  });
}
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={upload-source-code.js}]
/**
 * @file Upload source code
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */
 
// Import modules
const fs = require('fs');
const dircompare = require('dir-compare');
const path = require('path');

require('../init-config.js');

console.log('[upload-source-code.js] Started');
var start = performance.now();

if(!process.env.SERVER_PATH) {
  console.error('Environment variable SERVER_PATH must be defined!');
}
if(!process.env.SERVER_LIBS_PATH) {
  console.error('Environment variable SERVER_LIBS_PATH must be defined!');
}

// Variables
const options = { 
  compareSize: config.UPLOAD_COMPARE_SIZE,
  compareContent: config.UPLOAD_COMPARE_CONTENT,
  compareDate: config.UPLOAD_COMPARE_DATE,
  excludeFilter: config.SOURCE_UPLOAD_EXCLUDE.join(',')
};

// Compare directories
console.log('Comparing directories...');
var result = dircompare.compareSync('.', config.SERVER_SOURCE_PATH, options);

console.log('Statistics: \n Equal entries: %s, \n Distinct entries: %s, \n Left only entries: %s, \n Right only entries: %s, \n Differences: %s\n',
  result.equal, result.distinct, result.left, result.right, result.differences);

if(result.differences) {
  // Analyzing different files
  console.log('Analyzing different files...');
  result.diffSet.forEach(function(dif) {
    if(dif.type1 == 'file' || dif.type2 == 'file') {
      if(dif.state != 'equal') {
        switch(dif.state) {
          case 'distinct':
            if(!config.UPLOAD_COMPARE_SIZE_ON_DISTINCT || dif.date1 >= dif.date2) {
              console.log('File ' + path.join(dif.relativePath, dif.name1) + ' changed.');
            } else {
              console.log('File ' + path.join(dif.relativePath, dif.name1) + ' last modified on server.');
            }
            break;
          case 'left':
            console.log('File ' + path.join(dif.relativePath, dif.name1) + ' missing on server.');
            break;
          case 'right':
            console.log('File ' + path.join(dif.relativePath, dif.name2) + ' exists only on server.');
            break;
          default:
            console.log('Unhandled state for: ');
            console.log(dif);
        }

        if(['distinct', 'left'].includes(dif.state)) {
          if(!dif.date2 || !config.UPLOAD_COMPARE_SIZE_ON_DISTINCT || dif.date1 >= dif.date2) {
            console.log(' Uploading file to server...');
            
            if(!dif.date2) {
              fs.mkdirSync(path.join(config.SERVER_SOURCE_PATH, dif.relativePath), { recursive: true });
              fs.copyFileSync(path.join(dif.path1, dif.name1), 
                path.join(config.SERVER_SOURCE_PATH, dif.relativePath, dif.name1));
            } else {
              fs.mkdirSync(dif.path2, { recursive: true });
              fs.copyFileSync(path.join(dif.path1, dif.name1), 
                path.join(dif.path2, dif.name2));
            }
          }
        }
        //console.log(dif);
      }
    }
  });
} else {
  console.log('No different files...');
}

let d = new Date(), t = ((performance.now()-start)/1000).toFixed(3);
console.log(`[upload-source-code.js] Execution done in ${t}s - ${('0'+d.getHours()).slice(-2)}:${('0'+d.getMinutes()).slice(-2)}:${('0'+d.getSeconds()).slice(-2)}.${('00'+d.getMilliseconds()).slice(-3)} ${('0'+d.getDate()).slice(-2)}/${('0'+(d.getMonth()+1)).slice(-2)}/${d.getFullYear()}`);
\end{lstlisting}

% ------------------------------
\subsection{editor}


\begin{lstlisting}[style=JavaScriptStyle, caption={editor.js}]
/**
 * @file JSLAB editor module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB editor.
 */
class PRDC_JSLAB_EDITOR {

  /**
   * Initializes the editor, setting up event listeners for UI interactions and window controls.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    this.fullscreen = false;
    
    // On menu click
    $("#save-menu").click(function() { obj.win.script_manager.saveScript(); });
    $("#save-as-menu").click(function() { obj.win.script_manager.saveAsScript(); });
    $("#open-menu").click(function() { obj.win.script_manager.openScriptFile(); });

    $("#run-menu").click(function() { obj.win.script_manager.runScript(); });
    $("#new-tab").click(function() { obj.win.script_manager.createScript(); });
    $("#new-script").click(function() { obj.win.script_manager.createScript(); });
    
    $("#close-dialog-save").click(function() { obj.win.script_manager.closingDialogButton(2); });
    $("#close-dialog-discard").click(function() { obj.win.script_manager.closingDialogButton(1); });
    $("#close-dialog-cancel").click(function() { obj.win.script_manager.closingDialogButton(0); });

    $("#search-dialog-menu").click(function() { 
      obj.win.script_manager.openSearchDialog();
      obj.win.editor_more_popup.close();
    });
    $("#compile-dialog-menu").click(function() { 
      obj.win.script_manager.compileArduino();
      obj.win.editor_more_popup.close();
    });
    $("#upload-dialog-menu").click(function() { 
      obj.win.script_manager.uploadArduino();
      obj.win.editor_more_popup.close();
    });
    
    // Keydown actions
    document.addEventListener("keydown", function(e) {
      if(e.key == 'F11') {
        obj.toggleFullscreen();
      } if(e.key == 'F12') {
        ipcRenderer.send('MainProcess', 'show-dev-tools');
      } else if(e.ctrlKey && e.key.toLowerCase() === "n") {
        obj.win.script_manager.createScript();
      } else if(e.ctrlKey && e.key === "F4") {
        obj.win.script_manager.removeScriptByTab(obj.win.script_manager.active_tab);
      } else if(e.key === "F5") {
        obj.win.script_manager.runScript();
      } else if(e.ctrlKey && e.key.toLowerCase() === "o") {
        obj.win.script_manager.openScriptFile();
      } else if(e.ctrlKey && e.key.toLowerCase() === "s" && !e.shiftKey) {
        obj.win.script_manager.saveScript();
      } else if(e.ctrlKey && e.key.toLowerCase() === "s" && e.shiftKey) {
        obj.win.script_manager.saveAsScript();
      }
    });
    
    // Window controls    
    window.addEventListener('resize', function() {
      // Detect change of maximize
      obj.maximized = ipcRenderer.sendSync('sync-message', 'is-maximized-win');
      if(obj.maximized) {
       $("#win-restore img").attr('src', '../img/win-restore.svg');
      } else {
       $("#win-restore img").attr('src', '../img/win-maximize.svg');
      }
    }, true);
    
    $("#win-close").click(function() {
      ipcRenderer.send('MainProcess', 'close-editor');
    });
    
    $("#win-restore").click(function() {
      obj.toggleFullscreen(false);
      obj.maximized = !obj.maximized;
      if(obj.maximized) {
       ipcRenderer.send('MainProcess', 'maximize-win');
      } else {
       ipcRenderer.send('MainProcess', 'restore-win');
      }
    });
    
    $("#win-minimize").click(function() {
      obj.toggleFullscreen(false);
      ipcRenderer.send('MainProcess', 'minimize-win');
    });
    
    window.dispatchEvent(new Event('resize'));
  }

  /**
   * Toggles the fullscreen state of the editor window, or sets it explicitly if a parameter is provided.
   * @param {boolean} [fullscreen] Optional. If specified, sets the fullscreen state to the provided value. If omitted, toggles the current state.
   */
  toggleFullscreen(fullscreen) {
    if(fullscreen == null) {
      fullscreen = !this.fullscreen;
    }
    if(fullscreen) {
      ipcRenderer.send('MainProcess', 'set-fullscreen', true);
    } else {
      ipcRenderer.send('MainProcess', 'set-fullscreen', false);
    }
    this.fullscreen = fullscreen;
  }
  
  /**
   * Displays a message to the user through the application's main window. Can optionally request to focus the window.
   * @param {string} msg The message to display.
   * @param {boolean} [focus=true] Optional. Whether to focus the application window when displaying the message. Defaults to true.
   */
  disp(msg, focus = true) {
    ipcRenderer.send("MainWindow", "editor-disp", [msg, focus]);
  }

  /**
   * Displays an internal message within the application's main window. Can optionally request to focus the window.
   * @param {string} msg - The internal message to display.
   * @param {boolean} [focus=true] - Optional. Whether to focus the application window when displaying the message. Defaults to true.
   */
  dispInternal(msg, focus = true) {
    ipcRenderer.send("MainWindow", "disp-internal", [msg, focus]);
  }
  
  /**
   * Displays an error message through the application's main window. Typically used for internal errors.
   * @param {string} msg The error message to display.
   */
  errorInternal(msg) {
    ipcRenderer.send("MainWindow", "internal-error", msg);
  }
}

exports.PRDC_JSLAB_EDITOR = PRDC_JSLAB_EDITOR;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={init-editor.js}]
/**
 * @file JSLAB editor window init file
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

// Modules
// --------------------
const { ipcRenderer } = require('electron');

const helper = require("../js/helper.js");
require("../js/init-config.js");
const { PRDC_APP_LOGGER } = require('../lib/PRDC_APP_LOGGER/PRDC_APP_LOGGER');
const { PRDC_JSLAB_LANGUAGE } = require('../js/language');

global.app_path = process.argv.find(e => e.startsWith('--app-path=')).split('=')[1].replace(/\\js\\?$/, '');

const { PRDC_JSLAB_WIN_EDITOR } = require('../js/editor/win-editor');

// Start log
const log_file = ipcRenderer.sendSync('sync-message', 'get-log-file');
const app_logger = new PRDC_APP_LOGGER(log_file);

// Global variables
var language = new PRDC_JSLAB_LANGUAGE();
var win_editor = new PRDC_JSLAB_WIN_EDITOR();

// When document is ready
// --------------------
ready(function() {
  // Jquery ready
  $(document).ready(function() {
    win_editor.onReady();
  });
});
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={script-manager.js}]
/**
 * @file JSLAB editor script manager module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const { PRDC_JSLAB_EDITOR_SCRIPT } = require('./script');

const fs = require('fs');
const { pathEqual } = require('path-equal');
const Store = require('electron-store');
const { ESLint } = require("eslint");
const path = require("path");

const store = new Store();

/**
 * Class for JSLAB editor script.
 */
class PRDC_JSLAB_EDITOR_SCRIPT_MANAGER {

  /**
   * Initializes the script manager with references to the application window and sets up event listeners for tab interactions.
   * @param {object} win The application window where the editor is hosted.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    this.scripts = [];
    this.last_script_paths = [];
    this.last_active_script;
    this.active_tab;
    this.close_window = false;
    this.tabs = new PRDC_TABS();
    
    this.eslint = new ESLint(config.LINT_OPTIONS);
    
    // Tabs
    this.tabs_cont = document.querySelector(".tabs");
    this.tabs.init(this.tabs_cont);
    
    // On tab add
    this.tabs_cont.addEventListener("tabAdd", function({ detail }) {
      $("#close-dialog-cont").hide();
      detail.tabEl.onmousedown = function (e) {
        if(e && (e.which == 2 || e.button == 4)) {
          obj.removeScriptByTab(detail.tabEl);
        }
      };
    });

    // On tab remove
    this.tabs_cont.addEventListener("tabRemove", function() {
      if(obj.scripts.length == 0) {
        if(obj.close_window) {
          store.set("last_script_paths", obj.last_script_paths);
          store.set("last_active_script", obj.last_active_script);
          ipcRenderer.send("MainProcess", "close-editor");
        } else {
          obj.createScript();
        }
      }
    });

    // On tab close
    this.tabs_cont.addEventListener("tabClose", function({ detail }) {
      obj.removeScriptByTab(detail.tabEl);
    });

    // On tab change
    this.tabs_cont.addEventListener("activeTabChange", function({ detail }) {
      if(obj.active_tab !== undefined) {
        // Update code to last active_tab
        var [script] = obj.getScriptByTab(obj.active_tab);
        if(script !== undefined) {
          script.update();
        }
      }
      obj.active_tab = detail.tabEl;
      var [script] = obj.getScriptByTab(obj.active_tab);
      if(script !== undefined) {
        if(!script.closing) {
          $("#close-dialog-cont").hide();
        }
        script.show();
      }
      obj.updateActiveExtension(script);
    });

    
    // On start up
    var argv = ipcRenderer.sendSync('sync-message', 'get-process-arguments');
    var file_path = argv.find(arg => arg.endsWith('.jsl')); // path as argument
    var script_paths = store.get("last_script_paths"); // last opened scripts
    if(file_path) {
      if(script_paths) {
        script_paths.push(file_path);
      } else {
        script_paths = [file_path];
      }
    }
    if(script_paths) {
      script_paths.forEach(function(script_path) {
        var lstat = fs.lstatSync(script_path, {throwIfNoEntry: false});
        if(lstat && lstat.isFile()) {
          var [script, i] = obj.getScriptByPath(script_path);
          if(script == undefined) {
            obj.createScript(script_path);
          } else {
            script.activate();
          }
        }
      });
    }
    
    if(this.scripts.length > 0) {
      if(file_path) {
        this.activateScriptByPath(file_path);
      } else {
        var last_active_script = store.get("last_active_script");
        if(last_active_script) {
          this.activateScriptByPath(last_active_script);
        }
      }
      this.win.showEditor();
    } else {
      // New tab
      this.createScript();
    }
  }
  
  /**
   * Saves the currently active script.
   */
  saveScript() {
    this.getScriptByTab(this.active_tab)[0].save();
  }
  
  /**
   * Saves the currently active script under a new file name.
   */
  saveAsScript() {
    this.getScriptByTab(this.active_tab)[0].saveAs();
  }
  
  /**
   * Opens search dialog for currently active script.
   */
  openSearchDialog() {
    this.getScriptByTab(this.active_tab)[0].openSearchDialog();
  }
  
  /**
   * Compiles arduino code.
   */
  compileArduino() {
    this.getScriptByTab(this.active_tab)[0].compileArduino();
  }
  
  /**
   * Uploads arduino code.
   */
  uploadArduino() {
    this.getScriptByTab(this.active_tab)[0].uploadArduino();
  }
  
  /**
   * Opens a script file from the filesystem into the editor.
   */
  openScriptFile() {
    var obj = this;
    let options = {
      title: language.currentString(146),
      buttonLabel: language.currentString(147),
      filters: [
        { name: "All Files", extensions: ["*"] },
      ],
    };

    ipcRenderer.invoke("dialog", "showOpenDialog", options)
      .then(function(result) {
        if(result.canceled) return obj.win.editor.disp("@editor/openScriptFile: "+language.string(132));
        var open_path = result.filePaths[0];
        var [script, i] = obj.getScriptByPath(open_path);
        if(script == undefined) {
          obj.createScript(open_path);
        } else {
          script.activate();
        }
      }).catch(function(err) {
        obj.win.editor.errorInternal(err);
      });
  }
  
  /**
   * Opens a script by its path if not already open, or activates it if it is already open.
   * @param {Array<string, number>} data - An array where the first element is the script path and the second is the line number.
   */
  openScript(data) {
    var script_path = data[0];
    var script_lineno = data[1];
    var script_charpos = data[2];
    var lstat = fs.lstatSync(script_path, {throwIfNoEntry: false});
    if(lstat && lstat.isFile()) {
      var [script, i] = this.getScriptByPath(script_path);
      if(script == undefined) {
        this.createScript(script_path, script_lineno, script_charpos);
      } else {
        this.win.editor.disp("@editor/openScript: "+language.string(133)+" "+script_path+" "+language.string(134)+"!", false);
        script.activate();
        script.setLine(script_lineno, script_charpos);
      }
    }
  }
  
  /**
   * Executes the currently active script.
   */
  runScript() {
    this.getScriptByTab(this.active_tab)[0].run();
  }

  /**
   * Creates a new script tab and editor instance, loading the script from the given path.
   * @param {string} path - The file path of the script to load.
   * @param {number} lineno - The line number to navigate to in the newly created script.
   * @param {number} charpos - The char position to navigate to in the newly created script.
   */
  createScript(path, lineno, charpos) {
    this.tab = this.tabs.addTab();
    var script = new PRDC_JSLAB_EDITOR_SCRIPT(this.win, this, path, this.tab);
    script.setLine(lineno, charpos);
    this.scripts.push(script);
  }
  
  /**
   * Toggles the comment state of the selected lines in the currently active script tab.
   * This action uses the active tab's associated script editor to apply or remove comments.
   */
  toggleComment() {
    this.getScriptByTab(this.active_tab)[0].toggleComment();
  }
  
  /**
   * Activates the script associated with the given tab element.
   * @param {HTMLElement} tab The tab element associated with the script to activate.
   */
  activateScriptByTab(tab) {
    this.tabs.setCurrentTab(tab);
  }

  /**
   * Activates the script associated with the given filesystem path.
   * @param {string} script_path The path to the script to activate.
   */
  activateScriptByPath(script_path) {
    var [script, i] = this.getScriptByPath(script_path);
    if(script != undefined) {
      this.activateScriptByTab(script.tab);
    }
  }
  
  /**
   * Retrieves the script object and its index associated with the given tab element.
   * @param {HTMLElement} tab The tab element associated with the script.
   * @returns {Array} An array containing the script object and its index in the scripts array.
   */
  getScriptByTab(tab) {
    var i = this.scripts.findIndex(function(script) {
      return script.tab == tab;
    });
    if(i > -1) {
      return [this.scripts[i], i];
    } else {
      return [undefined, -1];
    }
  }

  /**
   * Retrieves the script object and its index associated with the given filesystem path.
   * @param {string} script_path The path to the script.
   * @returns {Array} An array containing the script object and its index in the scripts array.
   */
  getScriptByPath(script_path) {
    var i = this.scripts.findIndex(function(script) {
      return pathEqual(script.path, script_path);
    });
    if(i > -1) {
      return [this.scripts[i], i];
    } else {
      return [undefined, -1];
    }
  }
  
  /**
   * Updates the name displayed on a script's tab.
   * @param {HTMLElement} tab The tab element associated with the script.
   * @param {string} name The new name to display on the tab.
   */
  setScriptNameByTab(tab, name) {
    this.tabs.updateTab(tab, {
      title: name,
      favicon: false
    }); 
  }
  
  /**
   * Removes the script associated with the given tab element from the manager and UI.
   * @param {HTMLElement} tab The tab element associated with the script to remove.
   */
  removeScriptByTab(tab) {
    var [script, i] = this.getScriptByTab(tab);
    script.activate();
    if(script.remove()) {
      this.scripts[i].removeCodeEditor();
      this.scripts.splice(i, 1);
      this.tabs.removeTab(tab);
    }
  }
  
  /**
   * Initiates the closure of all open scripts, optionally persisting their state for future sessions.
   */
  closeAllScripts() {
    var obj = this;
    this.close_window = true;
    this.last_script_paths = [];
    this.last_active_script = this.active_tab.getAttribute('title');

    this.tabs_cont.querySelectorAll('.tabs-content .tab').forEach(function(tab) {
      var path = tab.getAttribute('title');
      if(path) {
        obj.last_script_paths.push(path);
      }
    });
    
    ipcRenderer.send("MainProcess", "focus-win");
    $("#close-dialog-cancel").hide();
    for(var i = this.scripts.length - 1; i >= 0; i--) {
      var tab = this.scripts[i].tab;
      if(this.scripts[i].remove()) {
        this.scripts[i].removeCodeEditor();
        this.scripts.splice(i, 1);
        this.tabs.removeTab(tab);
      }
    }
  }

  /**
   * Checks if a script with the given filesystem path is already open in the editor.
   * @param {string} script_path The path to the script to check.
   * @returns {boolean} True if the script is already open, false otherwise.
   */
  checkScriptOpenByPath(script_path) {
    var [script, i] = this.getScriptByPath(script_path);
    return !(script == undefined);
  }
  
  /**
   * Handles user interaction with the script closing dialog, determining whether to save changes, discard them, or cancel the closure.
   * @param {number} s - button state
   */
  closingDialogButton(s) {
    var [script, i] = this.getScriptByTab(this.active_tab);
    var tab = this.scripts[i].tab;
    var script_path = this.scripts[i].path;
    if(s == 2 || s == 1) {
      if(s == 2) {
        this.scripts[i].save();
        script_path = this.scripts[i].path;
      }
      this.scripts[i].removeCodeEditor();
      this.scripts.splice(i, 1);
      this.tabs.removeTab(tab);
    } else {
      this.scripts[i].closing = false;
      $("#close-dialog-cont").hide();
    }
    if(this.close_window && script_path !== undefined) {
      this.last_script_paths.push(script_path);
    }
  }
  
  /**
   * Updates body class based on active extension of script 
   */
  updateActiveExtension(script) {
    if(script && (typeof script.path === 'string' || script.path instanceof String)) {
      $(document.body).attr("class", 'file-' + path.extname(script.path).substring(1));
    } else {
      $(document.body).attr("class", '');
    }
  }
}

exports.PRDC_JSLAB_EDITOR_SCRIPT_MANAGER = PRDC_JSLAB_EDITOR_SCRIPT_MANAGER
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={script.js}]
/**
 * @file JSLAB editor script module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const fs = require('fs');
const path = require('path');

/**
 * Class for JSLAB editor script.
 */
class PRDC_JSLAB_EDITOR_SCRIPT {

  /**
   * Initializes a new instance of the editor script, setting up the code editor and loading any specified script.
   * @param {object} win The window object where the editor is embedded.
   * @param {object} script_manager The script manager handling multiple scripts.
   * @param {string} script_path The path to the script file to be loaded into the editor.
   * @param {HTMLElement} tab The tab element associated with this script in the UI.
   */
  constructor(win, script_manager, script_path, tab) {
    var obj = this;
    this.win = win;
    this.script_manager = script_manager;
    this.tab = tab;
    
    this.code_editor;
    this.code = "";
    this.path;
    this.name;
    this.saved_code = "";
    this.closing = false;

    if(script_path !== undefined) {
      this.path = script_path;
      this.name = path.basename(this.path);
      this.loadCode(script_path);
    } else {
      this.path = undefined;
      this.name = "Unknown";
    }

    this.tab.setAttribute("title", this.path);
    this.script_manager.setScriptNameByTab(this.tab, this.name);

    this.code_editor = CodeMirror(document.getElementById("code"), {
      theme: "notepadpp",
      rulers: [{ color: "#aff", column: 75, lineStyle: "solid" }],
      indentUnit: 2,
      tabSize: 2,
      lineNumbers: true,
      lineWrapping: true,
      styleActiveLine: true,
      matchBrackets: true,
      gutter: true,
      gutters: [
        "CodeMirror-linenumbers",
        "CodeMirror-foldgutter",
        "CodeMirror-lint-markers",
      ],
      foldGutter: true,
      searchDialog: true,
      highlightSelectionMatches: { annotateScrollbar: true },
    });

    CodeMirror.keyMap.default["Shift-Tab"] = "indentLess";
    CodeMirror.keyMap.default["Tab"] = "indentMore";
    CodeMirror.keyMap.default["Ctrl-F"] = "showSearchDialog";
    CodeMirror.keyMap.default['Ctrl-G'] = 'findNext';
    CodeMirror.keyMap.default['Shift-Ctrl-G'] = 'findPrev';
    CodeMirror.keyMap.default['Shift-Ctrl-F'] = 'replace';
    CodeMirror.keyMap.default['Shift-Ctrl-R'] = 'replaceAll';
    CodeMirror.keyMap.default['Ctrl-/'] = 'toggleComment';
    
    // Keypress events
    this.code_editor.on("keypress", function (cm, event) {
      if(
        !cm.state.completionActive &&
        !event.ctrlKey &&
        event.key != "Enter" &&
        event.key != ";" &&
        event.key != " " &&
        (event.key != "{") & (event.key != "}")
      ) {
        CodeMirror.commands.autocomplete(cm, null, { completeSingle: false });
      }
    });

    // Drop events
    this.code_editor.on("drop", function (data, e) {
      e.preventDefault();
    });

    this.code_editor.setValue(this.code);
    this.code_editor.clearHistory();
    this.code_editor.on("change", function() {
      obj.codeChanged();
    });
    
    this.show();
  }

  /**
   * Loads the code from the specified script path into the editor.
   * @param {string} script_path The path to the script file to be loaded.
   */
  loadCode(script_path) {
    try {
      var data = fs.readFileSync(script_path);
      this.code = data.toString();
    } catch (err) {
      this.win.editor.errorInternal(err.stack);
    }
    this.saved_code = this.code;
  }

  /**
   * Displays the editor for this script, focusing it and hiding other scripts' editors.
   */
  show() {
    $(".CodeMirror").hide();
    if(this.closing) {
      $("#close-file").text(this.name);
      $("#close-dialog-cont").fadeIn(300, "linear");
    }
    $(this.code_editor.display.wrapper).show();
    this.code_editor.focus();
    this.updateEditorMode();
  }

  /**
   * Updates the editor's stored code value based on the current content in the editor.
   */
  update() {
    this.code = this.code_editor.getValue();
  }

  /**
   * Saves the current script to its associated file path. If the script does not have a path, prompts for one.
   * @returns {boolean} True if the save operation was successful, false otherwise.
   */
  save() {
    if(this.path !== undefined) {
      if(this.isActive()) {
        this.update();
      }
      this.tab.classList.remove("changed");
      if(this.code != this.saved_code) {
        try {
          fs.writeFileSync(this.path, this.code);
        } catch (err) {
          this.win.editor.errorInternal(err.stack);
          return false;
        }
        this.saved_code = this.code;
        this.tab.classList.remove("changed");
        return true;
      } else {
        return true;
      }
    } else {
      return this.saveAs();
    }
  }

  /**
   * Saves the current script to a new file, prompting the user for the file path.
   * @returns {boolean} True if the save operation was successful, false otherwise.
   */
  saveAs() {
    var script_path;
    if(this.path === undefined) {
      script_path = "script.jsl";
    } else {
      script_path = this.path;
    }
    let options = {
      title: language.currentString(144),
      defaultPath: script_path,
      buttonLabel: language.currentString(145),
      filters: [
        { name: "All Files", extensions: ["*"] },
      ],
    };

    if(this.isActive()) {
      this.update();
    }

    script_path = ipcRenderer.sendSync("dialog", "showSaveDialogSync", options);
    if(script_path === undefined) {
      this.win.editor.disp("@editor/saveAs: "+language.string(129));
      return false;
    }
    
    if(script_path != this.path) {
      if(!this.script_manager.checkScriptOpenByPath(script_path)) {
        try {
          fs.writeFileSync(script_path, this.code);
        } catch (err) {
          this.win.editor.errorInternal(err.stack);
          return false;
        }
        this.path = script_path;
        this.name = this.path.replace(/^.*[\\\/]/, "");
        this.tab.setAttribute("title", this.path);
        this.tab.querySelector(".tab-title").innerHTML = this.name;
        this.saved_code = this.code;
        this.tab.classList.remove("changed");
        this.updateEditorMode();
        return true;
      } else {
        this.win.editor.errorInternal(language.string(130));
        return false;
      }
    } else {
      return false;
    }
  }

  /**
   * Prepares the script for removal, checking if changes are unsaved and potentially prompting the user.
   * @returns {boolean} True if the script can be safely removed, false if there are unsaved changes.
   */
  remove() {
    this.closing = true;
    if(this.isActive()) {
      this.update();
    }
    if(this.code.replace(/[\r]/g, '') != this.saved_code.replace(/[\r]/g, '')) {
      // Fade in window
      ipcRenderer.send("MainProcess", "fade-in-win");
      if(this.isActive()) {
        $("#close-file").text(this.name);
        $("#close-dialog-cont").fadeIn(300, "linear");
      }
      return false;
    } else {
      return true;
    }
  }

  /**
   * Removes the code editor associated with this script from the DOM.
   */
  removeCodeEditor() {
    $(this.code_editor.display.wrapper).remove();
  }

  /**
   * Checks if the script's tab is currently active in the UI.
   * @returns {boolean} True if this script's tab is active, false otherwise.
   */
  isActive() {
    return this.tab == this.script_manager.active_tab;
  }

  /**
   * Activates this script's tab in the UI, showing its editor and hiding others.
   */
  activate() {
    if(!this.isActive()) {
      this.script_manager.activateScriptByTab(this.tab);
      this.show();
    }
  }

  /**
   * Sets the cursor in the code editor to the specified line number.
   * @param {number} lineno - The line number to navigate to (1-based index).
   * @param {number} charpos - The char position to navigate to in the newly created script.
   */
  setLine(lineno, charpos = 0) {
    if(isFinite(lineno)) {
      this.code_editor.setCursor({ line: lineno - 1, ch: charpos - 1 });
    }
  }
  
  /**
   * Saves the script and then runs it, typically in an external execution environment.
   * @param {array} lines The specific lines or sections of the script to execute, if applicable.
   */
  run(lines) {
    if(this.save()) {
      ipcRenderer.send("MainWindow", "run", [this.path, lines]);
    } else {
      this.win.editor.disp("@editor/run: "+language.string(131));
    }
  }
  
  /**
   * Marks the script as having unsaved changes, updating the UI accordingly.
   */
  codeChanged() {
    this.tab.classList.add("changed");
  }
  
  /**
   * Toggles the comment state of the currently selected lines in the code editor.
   */
  toggleComment() {
    this.code_editor.execCommand('toggleComment');
  }
  
  /**
   * Update editor mode based on script extension
   */
  updateEditorMode() {
    var obj = this;
    this.script_manager.updateActiveExtension(this);
    if(typeof this.name === 'string' || this.name instanceof String) {
      var file_extension = path.extname(this.name);
      if(['.cpp', '.c', '.ino', '.h', '.hpp'].includes(file_extension.toLowerCase())) {
        this.code_editor.setOption("mode", "text/x-csrc");
        this.code_editor.setOption("lint", {});
        return;
      }
    }
    this.code_editor.setOption("mode", "javascript");
    this.code_editor.setOption("lint", {
      getAnnotations: async function(text, callback) {
        var results = await obj.script_manager.eslint.lintText(text);
        callback(results[0].messages.map(message => ({
          from: CodeMirror.Pos(message.line - 1, message.column - 1),
          to: CodeMirror.Pos(
            message.endLine ? message.endLine - 1 : message.line - 1,
            message.endColumn ? message.endColumn - 1 : message.column
          ),
          severity: message.severity === 2 ? "error" : "warning",
          message: message.message,
        })));
      },
      async: true
    });
  }
  
  /**
   * Opens search dialog in the code editor.
   */
  openSearchDialog() {
    this.code_editor.execCommand('showSearchDialog');
  }
  
  /**
   * Compiles arduino code.
   */
  compileArduino() {
    if(typeof this.path === 'string' || this.path instanceof String) {
      ipcRenderer.send("MainWindow", "eval-command", [`compileArduino('${path.dirname(this.path).replace(/\\(?!\\)/g, "\\\\")}')`]);
    } else {
      this.win.editor.disp("@editor/compileArduino: "+language.string(229));
    }
  }
  
  /**
   * Uploads arduino code.
   */
  uploadArduino() {
    if(typeof this.path === 'string' || this.path instanceof String) {
      ipcRenderer.send("MainWindow", "eval-command", [`uploadArduino('${path.dirname(this.path).replace(/\\(?!\\)/g, "\\\\")}')`]);
    } else {
      this.win.editor.disp("@editor/uploadArduino: "+language.string(229));
    }
  }
}

exports.PRDC_JSLAB_EDITOR_SCRIPT = PRDC_JSLAB_EDITOR_SCRIPT;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={win-editor.js}]
/**
 * @file JSLAB Editor
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

// Modules
// --------------------
const { ipcRenderer, webUtils } = require('electron');

const { PRDC_JSLAB_EDITOR } = require('./editor');
const { PRDC_JSLAB_EDITOR_SCRIPT_MANAGER } = require('./script-manager');

const { PRDC_POPUP } = require('./../../lib/PRDC_POPUP/PRDC_POPUP');

const fs = require("fs");

/**
 * Class for JSLAB editor win.
 */
class PRDC_JSLAB_WIN_EDITOR {  

  /**
   * Create editor win.
   */
  constructor() {
    var obj = this;

    // Classes
    this.editor = new PRDC_JSLAB_EDITOR(this);
    this.script_manager = new PRDC_JSLAB_EDITOR_SCRIPT_MANAGER(this);
    this.editor_more_popup = new PRDC_POPUP(document.getElementById('editor-more-icon'),
      document.getElementById('editor-more-popup'));
      
    // Prevent redirects
    preventRedirect();

    // Events
    // --------------------
    // Toggle DevTools
    document.addEventListener("keydown", function (e) {
      if(e.key == "F12") {
        ipcRenderer.send("MainProcess", "toggle-dev-tools");
      } else if(e.ctrlKey && e.key.toLowerCase() == 'c') {
        if(obj.getSelectionText() == "") {
          // No selected text
          obj.editor.dispInternal(language.string(89));
          ipcRenderer.send('SandboxWindow', 'stop-loop', true);
          e.stopPropagation();
          e.preventDefault();
        }
      }
    });

    // Error handle
    // --------------------
    window.addEventListener("unhandledrejection", function (e) {
      obj.editor.errorInternal(e.reason.stack);
      e.preventDefault();
    });

    window.addEventListener("error", function (e) {
      obj.editor.errorInternal(e.error.stack);
      e.preventDefault();
    });
    
    // On IPC message
    ipcRenderer.on("EditorWindow", function(event, action, data) {
      switch(action) {
        case "open-script":
          // On open script
          obj.script_manager.openScript(data);
          break;
        case "close-all":
          // On close all
          obj.script_manager.closeAllScripts();
          break;
        case "set-language":
          language.set(data);
          break;
        case "toggle-comment":
          obj.script_manager.toggleComment();
          break;
      }
    });

    // On file drop
    document.addEventListener("drop", function(e) {
      e.stopPropagation();
      e.preventDefault();
      console.log(e);
      
      for(const f of e.dataTransfer.files) {
        obj.script_manager.openScript([webUtils.getPathForFile(f)]);
      }
    }, false);
  }
  
  /**
   * Retrieves selected text within the application, if any.
   * @return {string} The currently selected text.
   */
  getSelectionText() {
    var text = "";
    if(window.getSelection) {
        text = window.getSelection().toString();
    } else if(document.selection && document.selection.type != "Control") {
        text = document.selection.createRange().text;
    }
    return text;
  }
  
  /**
   * Method used to execute code when gui is ready.
   */
  onReady() {
    // Fade in window
    ipcRenderer.send('MainProcess', 'fade-in-win');
  }
  
  /**
   * Show editor
   */
  showEditor() {
    ipcRenderer.send("MainProcess", "show-editor");
  }
}
exports.PRDC_JSLAB_WIN_EDITOR = PRDC_JSLAB_WIN_EDITOR;
\end{lstlisting}

% ------------------------------
\subsection{main}


\begin{lstlisting}[style=JavaScriptStyle, caption={app.js}]
/**
 * @file JSLAB app module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const os = require('os');
const cp = require('child_process');

/**
 * Class for JSLAB app.
 */
class PRDC_JSLAB_APP {

  /**
   * Initializes application properties, fetching system and environment information relevant to the application.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    this.version;
    this.user;
    this.documents_path;
    
    // Platform specific code
    this.computer_name;
    switch(process.platform) {
      case 'win32':
        this.computer_name = process.env.COMPUTERNAME;
        break;
      case 'darwin':
        this.computer_name = cp.execSync('scutil --get ComputerName')
          .toString().trim();
        break;
      default:
        this.computer_name = os.hostname();
        break;
    }
    this.version = ipcRenderer.sendSync('sync-message', 'get-app-version');
    this.documents_path = ipcRenderer.sendSync('sync-message', 
      'get-path', 'documents');
    this.exe_path = ipcRenderer.sendSync('sync-message', 
      'get-path', 'exe');
    this.user = os.userInfo().username + '@' + this.computer_name;
  }

  /**
   * Generates a formatted string representing the current date and time, suitable for timestamps and logging.
   * @param {number} [t=Date.now()] Optional timestamp to format, defaults to the current time if not provided.
   * @returns {string} A string formatted to represent a date and time, structured as DD_MM_YYYY. HH_MM_SS_mmm.
   */
  getDateTimeFullStr(t = Date.now()) {
    var d = new Date(t);
    return ('0' + d.getDate()).slice(-2) + "_" + 
      ('0' + (d.getMonth() + 1)).slice(-2) + "_" + 
      d.getFullYear() + '. ' + ('0'+d.getHours()).slice(-2) + "_" +  
      ('0'+d.getMinutes()).slice(-2) + "_" +  
      ('0'+d.getSeconds()).slice(-2) + "_" +
      ('00'+d.getMilliseconds()).slice(-3);
  }
}

exports.PRDC_JSLAB_APP = PRDC_JSLAB_APP;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={command-history.js}]
/**
 * @file JSLAB command history module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const Store = require('electron-store');

const store = new Store();

/**
 * Class for JSLAB command history.
 */
class PRDC_JSLAB_COMMAND_HISTORY {
  
  /**
   * Initializes the command history.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    this.history_cont = document.getElementById('command-history');
    this.full_history = store.get('full_history') || [];
    this.history = [];
    
    this.N_history_max = Number(store.get('N_history_max'));
    if(!isFinite(this.N_history_max)) {
      this.setMaxSize(20);
    }

    this.renderHistory();

    // Append initialization command
    const init_cmd = `// JSLAB ${this.win.app.version}, ${new Date()} [${this.win.app.user}]`;
    this.updateHistory(init_cmd);

    // History clear button click
    const clear_button = document.querySelector('#command-history-options .clear');
    if(clear_button) {
      clear_button.addEventListener('click', function() {
        obj.clearHistory()
      });
    }

    // Event delegation for command interactions
    this.history_cont.addEventListener('click', function(e) {
      if(e.target && !e.target.classList.contains('comment')) {
        obj.selectCommand(e.target.textContent);
      }
    });

    this.history_cont.addEventListener('dblclick', function(e) {
      if(e.target && !e.target.classList.contains('comment')) {
        obj.evalSelectedCommand(e.target.textContent);
      }
    });
  }

  /**
   * Renders the entire history efficiently using DocumentFragment.
   */
  renderHistory() {
    const fragment = document.createDocumentFragment();

    this.full_history.forEach((cmd) => {
      const div = document.createElement('div');
      if(cmd.startsWith('//')) {
        div.classList.add('comment');
      }
      div.textContent = cmd.replace(/\\/g, '\\\\');
      fragment.appendChild(div);
    });

    this.history_cont.appendChild(fragment);
    this.scrollToBottom();
  }

  /**
   * Adds a command to the history, updating the UI and internal storage accordingly.
   * @param {string} cmd The command to be added to the history.
   */
  updateHistory(cmd) {
    if(this.full_history.length >= this.N_history_max) {
      this.full_history.shift();
      if(this.history_cont.firstChild) {
        this.history_cont.removeChild(this.history_cont.firstChild);
      }
    }

    const div = document.createElement('div');
    if(cmd.startsWith('//')) {
      div.classList.add('comment');
    } else {
      this.history.unshift(cmd)
    }
    div.textContent = cmd;
    this.history_cont.appendChild(div);
    this.full_history.push(cmd);

    this.scrollToBottom();
    this.saveHistory();
  }

  /**
   * Scrolls the history container to the bottom.
   */
  scrollToBottom() {
    this.history_cont.scrollTop = this.history_cont.scrollHeight;
  }

  /**
   * Selects a command from the history, placing it in the command input for potential modification and re-execution.
   * @param {string} cmd The command to select.
   */
  selectCommand(cmd) {
    const code_input = this.win.command_window.code_input;
    code_input.setValue(cmd);
    code_input.focus();
    code_input.setCursor(code_input.lineCount(), 0);
  }

  /**
   * Evaluates a selected command from the history, directly executing it without modification.
   * @param {string} cmd The command to evaluate.
   */
  evalSelectedCommand(cmd) {
    this.win.eval.evalCommand(cmd);
  }

  /**
   * Clears the command history.
   */
  clearHistory() {
    this.full_history = [];
    this.history_cont.innerHTML = '';
    this.saveHistory();
  }

  /**
   * Saves the current history to storage asynchronously.
   */
  saveHistory() {
    store.set('full_history', this.full_history);
  }

  /**
   * Sets the maximum number of commands to retain in the history.
   * @param {number} N - The desired maximum number of history entries
   */
  setMaxSize(N) {
    if(N < 5) {
      N = 5;
    }
    this.N_history_max = N;
    $('#settings-container .N-history-max').val(N);
    while(this.full_history.length >= this.N_history_max) {
      this.full_history.shift();
      if(this.history_cont.firstChild) {
        this.history_cont.removeChild(this.history_cont.firstChild);
      }
    }
    store.set('N_history_max', this.N_history_max);
    this.saveHistory();
  }
}

exports.PRDC_JSLAB_COMMAND_HISTORY = PRDC_JSLAB_COMMAND_HISTORY;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={command-window.js}]
/**
 * @file JSLAB command window module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const { shell } = require('electron');
const { BigJsonViewerDom } = require('big-json-viewer');
const Store = require('electron-store');
const { ESLint } = require("eslint");

const store = new Store();

/**
 * Class for JSLAB command window.
 */
class PRDC_JSLAB_COMMAND_WINDOW {

  /**
   * Initializes the command window, setting up the UI components, event listeners, and loading settings from storage.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;

    this.terminal_cont = document.getElementById('right-panel');
    
    this.terminal_history_cont;
    this.terminal_options_cont;
    this.messages;
    this.autoscroll = true;
    this.show_timestamp = false;
    this.write_timestamps = true;
    this.log = [];
    this.log_dialog;
    this.settings_dialog;
    this.N_messages = 1;
    this.N_messages_max = Infinity;
    this.code_input;
    this.textarea;
    this.ignore_output = false;
    this.no_ans = false;
    this.i_history = -1;
    
    this.last_class;
    this.last_tic;

    this.eslint = new ESLint(config.LINT_OPTIONS);
    
    // Load settings
    this.autoscroll = store.get('autoscroll');
    if(!this.autoscroll) {
      this.autoscroll = true;
    }
    this.show_timestamp = store.get('show_timestamp');
    if(!this.show_timestamp) {
      this.show_timestamp = false;
    }
    this.N_messages_max = Number(store.get('N_messages_max'));
    if(!isFinite(this.N_messages_max) || this.N_messages_max == 0) {
      this.N_messages_max = Infinity;
    }
    this.write_timestamps = store.get('write_timestamps');
    if(!this.write_timestamps) {
      this.write_timestamps = true;
    }

    // Create terminal DOM
    this.messages = $('#right-panel .messages');

    // Welcome message
    var ts = this.getTimestamp();
    $(this.messages).html('<div class="welcome-message system-in message"><span class="timestamp">' + ts + '</span><img class="app-logo" src="../img/JSLAB.svg"><img class="company-logo" src="../img/PR-DC_icon.svg"><div class="clear"></div><p><span>JSLAB</span>, '+language.string(8)+' ' + this.win.app.version + '</p><p>'+language.string(136)+' ' + new Date().getFullYear() + ' © <span>PR-DC</span> info@pr-dc.com</p><p>'+language.string(137)+'</p><p>'+language.string(138)+'</p><p>'+language.string(139)+' <span>cmd_help</span></p><p>'+language.string(135)+' <a href="https://pr-dc.com/jslab">pr-dc.com/jslab</a></p></div>');

    // Command history
    this.terminal_history_cont = 
      $('#right-panel .history-cont');
    $('#right-panel .history-close').click(function(){
      obj.closeTerminalDialog(obj.terminal_history_cont);
    });
    this.terminal_history_cont.on('keydown', function(e) {
      // https://keycode.info/
      function activateCommand() {
        var el_a = $('#right-panel .history-cont .history-panel li.active');
        var el = $('#right-panel .history-cont .history-panel li[i="'+obj.i_history+'"]');
        el_a.removeClass('active');
        el.addClass('active');
        el[0].scrollIntoView({block: 'center', inline: 'center'});
        obj.code_input.setValue(obj.win.command_history.history[obj.i_history]);
        obj.code_input.setCursor(obj.code_input.lineCount(), 0);
      }

      if(e.key == 'Enter' && !e.shiftKey) {
        // Enter
        var el_a = $('#right-panel .history-cont .history-panel li.active');
        var cmd = el_a.html();
        obj.win.eval.evalCommand(cmd);
        obj.closeTerminalDialog(obj.terminal_history_cont);
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'Escape') {
        // ESC
        obj.closeTerminalDialog(obj.terminal_history_cont);
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'ArrowUp') {
        // Arrow up
        if(obj.i_history > 0) {
          obj.i_history -= 1;
          activateCommand();
        }
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'ArrowDown') {
        // Arrow down
        if(obj.i_history < (obj.win.command_history.history.length-1)) {
          obj.i_history += 1;
          activateCommand();
        }
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'PageUp') {
        // Page up
        if(obj.win.command_history.history.length) {
          obj.i_history = 0;
          activateCommand();
        }
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'PageDown') {
        // Page down
        if(obj.win.command_history.history.length) {
          obj.i_history = obj.win.command_history.history.length - 1;
          activateCommand();
        }
        e.stopPropagation();
        e.preventDefault();
      }
    });

    // Create settings dialog
    this.settings_dialog = 
      $('#right-panel .terminal-settings');
    this.settings_dialog.on('keydown', function(e) {
      if(e.key == 'Escape') {
        // ESC
        obj.closeTerminalDialog(obj.settings_dialog);
        e.stopPropagation();
        e.preventDefault();
      }
    });
    $('#right-panel .terminal-settings .options-close').click(function(){
      obj.closeTerminalDialog(obj.settings_dialog);
    });
    this.setNMessagesMax();
    $('#right-panel .terminal-settings .change-settings').click(function(){
      obj.closeTerminalDialog(obj.settings_dialog);
      obj.N_messages_max =
        Number($('#right-panel .terminal-settings .N-messages-max').val());
      obj.setNMessagesMax();
      if(obj.N_messages > obj.N_messages_max) {
        while(obj.N_messages > obj.N_messages_max) {
          obj.messages[0].firstChild.remove();
          obj.N_messages -= 1;
        }
      }
    });

    // Create log save dialog
    this.log_dialog = $('#right-panel .terminal-log');
    this.log_dialog.on('keydown', function(e) {
      if(e.key == 'Escape') {
        // ESC
        obj.closeTerminalDialog(obj.log_dialog);
        e.stopPropagation();
        e.preventDefault();
      }
    });
    $('#right-panel .terminal-log .options-close').click(function(){
      obj.closeTerminalDialog(obj.log_dialog);
    });
    $('#right-panel .terminal-log .write-timestamps').click(function(){
      obj.write_timestamps = this.checked;
      obj.setWriteTimestamps();
    });
    this.setWriteTimestamps();
    $('#right-panel .terminal-log .save-log').click(function(){
      obj.closeTerminalDialog(obj.log_dialog);
      obj.saveLog();
    });

    // Document keydown callbacks
    $(document).on('keydown', function(e) {
      if(e.key.toLowerCase() == 'f' && e.ctrlKey) {
        // Ctrl + F
        obj.scrollToBottom();
        obj.code_input.focus();
        obj.code_input.setCursor(obj.code_input.lineCount(), 0);
        e.stopPropagation();
        e.preventDefault();
      }
    });

    // Create code input
    this.code_input = CodeMirror.fromTextArea(
        document.getElementById('command-window-input'), {
      mode: 'javascript',
      theme: 'notepadpp',
      indentUnit: 2,
      tabSize: 2,
      lineWrapping: true,
      matchBrackets: true,
      gutter: true,
      gutters: ['CodeMirror-lint-markers'],
      lint: {
        getAnnotations: async function(text, callback) {
          var results = await obj.eslint.lintText(text);
          callback(results[0].messages.map(message => ({
            from: CodeMirror.Pos(message.line - 1, message.column - 1),
            to: CodeMirror.Pos(
              message.endLine ? message.endLine - 1 : message.line - 1,
              message.endColumn ? message.endColumn - 1 : message.column
            ),
            severity: message.severity === 2 ? "error" : "warning",
            message: message.message,
          })));
        },
        async: true
      },
      highlightSelectionMatches: {annotateScrollbar: true},
      viewportMargin: Infinity,
      extraKeys: { Enter: function(){
        sendCommand();
      } }
    });
    
    $('#command-window-input-submit-cont').click(function() {
      sendCommand();
    });
    
    CodeMirror.keyMap.default['Shift-Tab'] = 'indentLess';
    CodeMirror.keyMap.default['Tab'] = 'indentMore';

    this.code_input.on('keypress', function(cm, event) {
      if(!cm.state.completionActive && !event.ctrlKey && 
          event.key != 'Enter' && 
          event.key != ';' && event.key != ' ' &&
          event.key != '{' & event.key != '}') {
        CodeMirror.commands.autocomplete(cm, null, 
          {completeSingle: false});
      }
    });

    // Code input keydown callbacks
    function historyUp() {
      if(obj.i_history < (obj.win.command_history.history.length - 1)) {
        obj.i_history += 1;
        obj.code_input.setValue(obj.win.command_history.history[obj.i_history]);
        obj.code_input.setCursor(obj.code_input.lineCount(), 0);
        obj.scrollToBottom();
      }
    }
    
    function historyDown() {
      if(obj.i_history > 0) {
        obj.i_history -= 1;
        obj.code_input.setValue(obj.win.command_history.history[obj.i_history]);
        obj.code_input.setCursor(obj.code_input.lineCount(), 0);
      }
    }
    
    function sendCommand() {
      var cmd = obj.code_input.getValue();
      obj.win.eval.evalCommand(cmd);
    }
    
    this.code_input.on('keydown', function(cm, e) {
      // https://keycode.info/
      if(e.key == 'Escape' && 
          !obj.code_input.state.completionActive) {
        // ESC
        obj.code_input.setValue('');
        obj.resetHistoryIndex();
        obj.scrollToBottom();
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'ArrowUp' && 
          !obj.code_input.state.completionActive) {
        // Arrow up

        var cursor = obj.code_input.getCursor();
        var line = obj.code_input.lineCount()-1;
        var position = obj.code_input.getLine(line).length;
        if(cursor.line == 0 && (cursor.ch == position || cursor.ch == 0)) {
          historyUp(e);
          e.stopPropagation();
          e.preventDefault();
        }
      } else if(e.key == 'ArrowDown' &&
          !obj.code_input.state.completionActive) {
        // Arrow down

        var cursor = obj.code_input.getCursor();
        var line = obj.code_input.lineCount()-1;
        var position = obj.code_input.getLine(line).length;
        if(cursor.line == line && (cursor.ch == position || cursor.ch == 0)) {
          historyDown(e);
          e.stopPropagation();
          e.preventDefault();
        }
      } else if(e.key == 'PageUp') {
        // Page up
        if(obj.win.command_history.history.length) {
          obj.i_history = obj.win.command_history.history.length-1;
          obj.code_input.setValue(obj.win.command_history.history[obj.win.command_history.history.length-1]);
          obj.code_input.setCursor(obj.code_input.lineCount(), 0);
          obj.scrollToBottom();
        }
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'PageDown') {
        // Page down
        if(obj.win.command_history.history.length) {
          obj.i_history = 0;
          obj.code_input.setValue(obj.win.command_history.history[0]);
          obj.code_input.setCursor(obj.code_input.lineCount(), 0);
          obj.scrollToBottom();
        }
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'F3') {
        // F3
        if(obj.win.command_history.history.length) {
          var new_cmd = obj.win.command_history.history[0];
          obj.win.eval.evalCommand(new_cmd);
        }
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'F7' && e.altKey) {
        // Alt + F7
        obj.resetHistoryIndex();
        obj.win.command_history.history = [];
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'F7') {
        // F7
        obj.openTerminalDialog(obj.terminal_history_cont);
        var cmds_cont = $('#right-panel .history-cont .history-panel');
        cmds_cont.html('');
        if(obj.win.command_history.history.length) {
          obj.win.command_history.history.forEach(function(e, i) {
            if(i == obj.i_history) {
              cmds_cont
                .append('<li i="' + i + '" class="active">' + e + '</li>');
            } else {
              cmds_cont.append('<li i="' + i + '">' + e + '</li>');
            }
          });
          var el_a = $('#right-panel .history-cont .history-panel li.active');
          if(el_a.length > 0) {
            el_a[0].scrollIntoView({block: 'center', inline: 'center'});
          }
          var cmds = cmds_cont.find('li');
          cmds.on('click', function() {
            cmds.removeClass('active');
            $(this).addClass('active');
            obj.i_history = Number($(this).attr('i'));
          });
        } else {
          cmds_cont
            .append('<div class="history-empty">History is empty!</div>');
        }
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key == 'F8') {
        // F8
        var cursor = obj.code_input.getCursor();
        var line = cursor.line;
        var position = cursor.ch;
        var cmd = obj.code_input.getLine(line).substring(0, position);
        var j = -1;
        for(var i = 0; i < obj.win.command_history.history.length; i++) {
          if(obj.win.command_history.history[i].startsWith(cmd)) {
            if(j > -1) {
              if(i > obj.i_history) {
                j = i;
                break;
              }
            } else {
              j = i;
              if(obj.i_history == -1) {
                break;
              }
            }
          }
        }
        if(j > -1) {
          obj.i_history = j;
          obj.code_input.setValue(obj.win.command_history.history[obj.i_history]);
          if(obj.win.command_history.history[obj.i_history].length > position) {
            obj.code_input.focus();
            obj.code_input.setCursor(cursor);
          }
        }
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key.toLowerCase() == 's' && e.ctrlKey) {
        // Ctrl + S
        obj.openTerminalDialog(obj.settings_dialog);
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key.toLowerCase() == 'l' && e.ctrlKey) {
        // Ctrl + L
        obj.openTerminalDialog(obj.log_dialog);
        e.stopPropagation();
        e.preventDefault();
      } 
    });
     
    // Focus code input
    $('#right-panel .terminal-panel').click(function(e){
      if(e.target != this) return;
      obj.code_input.focus();
      obj.code_input.setCursor(obj.code_input.lineCount(), 0);
    });
    
    $('#command-window-input-container').click(function(e){
      if(e.target != this) return;
      obj.code_input.focus();
      obj.code_input.setCursor(obj.code_input.lineCount(), 0);
    });

    // Terminal options cont
    this.terminal_options_cont = $('#right-panel .options');

    // Terminal settings button click
    $('#right-panel .options .settings').click(function(){
      obj.openTerminalDialog(obj.settings_dialog);
    });

    // Terminal timestamp button click
    $('#right-panel .options .timestamp').click(function(){
      if(obj.show_timestamp) {
        obj.show_timestamp = false;
      } else {
        obj.show_timestamp = true;
      }
      obj.setTimestamp();
    });
    this.setTimestamp();

    // Terminal auto scroll button click
    $('#right-panel .options .autoscroll').click(function(){
      if(obj.autoscroll) {
        obj.autoscroll = false;
      } else {
        obj.autoscroll = true;
      }
      obj.setAutoscroll();
    });
    this.setAutoscroll();

    // Terminal clear button click
    $('#right-panel .options .clear').click(function(){
      obj.clear();
    });

    // Terminal save log button click
    $('#right-panel .options .log').click(function(){
      obj.openTerminalDialog(obj.log_dialog);
    });
    
    // Terminal scroll to bottom button click
    $('#right-panel .options .to-bottom').click(function(){
      obj.scrollToBottom();
      obj.code_input.focus();
      obj.code_input.setCursor(obj.code_input.lineCount(), 0);
    });
    
    // Prevent all redirects
    $(document.body).on('click', '#command-window-messages a', function(e) {
      if(e.target.href) {
        e.preventDefault();
        shell.openExternal(e.target.href);
        return false;
      }
      return true;
    });
    
    // Commands for evaluation
    $(document.body).on('click', '#command-window-messages span.eval-code', function() {
      obj.win.eval.evalCommand(this.innerText);
    });
    
    // Open script in editor
    $(document.body).on('click', '#command-window-messages span.open-editor', function() {
       ipcRenderer.send('EditorWindow', 'open-script', [$(this).attr('file_path'), $(this).attr('line_number'), $(this).attr('char_pos')]);
    });
  }

  /**
   * Resets the index used for navigating through command history to its default state.
   */
  resetHistoryIndex() {
    this.i_history = -1;
  }
  
  /**
   * Applies syntax highlighting to a given snippet of code, returning HTML markup with syntax highlighting styles applied.
   * @param {string} data The code snippet to which syntax highlighting should be applied.
   * @returns {string} HTML string representing the highlighted code. Special HTML characters like '<' and '>' are properly escaped.
   */
  highlightCode(data) {
    return hljs.highlight(data, 
      {language: 'javascript'}).value
      .replaceAll('&lt;', '<').replaceAll('&gt;', '>');  // Return < and >
  }
  
  /**
   * Clears all messages from the command window.
   */
  clear() {
    this.N_messages = 0;
    $(this.messages).html('');
  }

  /**
   * Displays an error message in the command window.
   * @param {string} msg The error message to display.
   */
  error(msg) {
    this.win.workspace.updateWorkspace();
    return this.addMessage('data-in', '<span class="error">' +
      this.prettyPrint(msg) + '<span>');
  }

  /**
   * Displays a warning message in the command window.
   * @param {string} msg The warning message to display.
   */
  warn(msg) {
    this.win.workspace.updateWorkspace();
    return this.addMessage('data-in', '<span class="warn">' +
      this.prettyPrint(msg) + '<span>');
  }
  
  /**
   * Highlights and displays a response message in the command window, particularly used for 'ans' variable responses.
   * @param {Array|string} data The data to be highlighted and displayed.
   */
  highlightAnsMessage(data) {
    if(data[1]) {
      var el = this.message('ans = ', 'ans = '+data[0]);
      try {
        var json_data = this.truncateStrings(JSON.parse(data[0]));
        BigJsonViewerDom.fromObject(json_data).then(function(viewer) {
          const node = viewer.getRootElement();
          el[0].appendChild(node);
          node.openAll(1);
        }).catch(function(err) {
          console.log(err);
        });
      } catch(err) {
        console.log(err);
      }
    } else {
      this.message(this.highlightCode('ans = ' + data[0]), 'ans = ' + data[0]);
    }
  }
  
  /**
   * Displays a general message in the command window.
   * @param {string} msg The message to display.
   * @param {string} raw Raw message to log.
   */
  message(msg, raw) {
    this.win.workspace.updateWorkspace();
    return this.addMessage('data-in', this.prettyPrint(msg), raw);
  }

  /**
   * Displays a general message in the command window with monospaced font.
   * @param {string} msg The message to display.
   * @param {string} raw Raw message to log.
   */
  messageMonospaced(msg, raw) {
    this.win.workspace.updateWorkspace();
    return this.addMessage('data-in', '<div class="monospaced">'+this.prettyPrint(msg)+"</div>", raw);
  }
  
  /**
   * Displays a general message in the command window.
   * @param {string} msg The message to display.
   */
  messageLatex(msg) {
    this.win.workspace.updateWorkspace();
    var el = this.addMessage('data-in', '\\('+msg+'\\)');
    MathJax.typeset(el);
    return el;
  }
  
  /**
   * Displays a message from internal operations in the command window.
   * @param {string} msg The internal message to display.
   */
  messageInternal(msg) {
    this.addMessage('system-in', this.prettyPrint(msg));
  }
  
  /**
   * Displays an error message originating from internal operations or system errors.
   * @param {string} msg The error message to display.
   */
  errorInternal(msg) {
    this.addMessage('system-in', '<span class="error">' +
      this.prettyPrint(msg) + '<span>');
  }
  
  /**
   * Displays a message related to editor operations in the command window.
   * @param {string} msg The editor message to display.
   */
  messageEditor(msg) {
    this.addMessage('system-in', '<span class="log">Editor: ' +
      this.prettyPrint(msg) + '</span>');
  }
  
  /**
   * Opens a specified dialog related to the terminal, like settings or history.
   * @param {jQuery} e The jQuery object representing the dialog to open.
   */
  openTerminalDialog(e) {
    if(!e.is(':visible')) {
      $('.terminal-dialog').fadeOut(300, 'linear');
      e.fadeIn(300, 'linear', function() {
        e.focus();
      });
    }
  }

  /**
   * Closes a specified dialog related to the terminal.
   * @param {jQuery} e The jQuery object representing the dialog to close.
   */
  closeTerminalDialog(e) {
    e.fadeOut(300, 'linear');
    this.code_input.focus();
    this.code_input.setCursor(this.code_input.lineCount(), 0);
  } 

  /**
   * Adds a command as a message to the terminal, applying syntax highlighting and pretty printing.
   * @param {string} cmd The command to add to the terminal output.
   */
  addMessageCmd(cmd) {
    var txt = this.prettyPrint(cmd);
    this.addMessage('data-out', this.highlightCode(txt), txt);
  }

  /**
   * Adds a message to the terminal output. Supports merging messages for continuous output scenarios.
   * @param {string} msg_class The CSS class to apply to the message, defining its type (e.g., 'system-in', 'data-out').
   * @param {string} data The message content, which can include HTML markup.
   * @param {boolean} [merge_messages=false] Whether to merge this message with the previous one if they are of the same class.
   * @returns {Object} A jQuery object representing the created message element.
   */
  addMessage(msg_class, data, raw, merge_messages = false) {
    if(typeof raw == 'undefined') {
      raw = data;
    }
    var t = performance.now();
    var el;
    if(msg_class != this.last_class) {
      this.last_class = msg_class;
      this.last_tic = t;
      var ts = this.getTimestamp();
      if(this.N_messages < this.N_messages_max) {
        this.N_messages += 1;
      } else {
        this.messages[0].firstChild.remove();
      }
      el = $('<div class="' + msg_class +
        '"><span class="timestamp">' +
        ts + '</span>' + data + '</div>');
      $(this.messages).append(el);
      this.log.push({'class': msg_class, 'timestamp': ts, 'data': raw});
    } else {
      if(!merge_messages || t-this.last_tic > 1) {
        this.last_tic = t;
        var ts = this.getTimestamp();
        if(this.N_messages < this.N_messages_max) {
          this.N_messages += 1;
        } else {
          this.messages[0].firstChild.remove();
        }
        el = $('<div class="' + msg_class + 
          '"><span class="timestamp">' + 
          ts +'</span>' + data + '</div>');
        $(this.messages).append(el);
        this.log.push({'class': msg_class, 'timestamp': ts, 'data': raw});
      } else {
        el = $(this.messages).find('div').last();
        el.append(data);
        this.log[this.log.length-1].data += raw;
      }
    }
    if(this.autoscroll) {
      this.scrollToBottom();
    }
    return el;
  }
  
  /**
   * Toggles the visibility of timestamps in the command window.
   */
  setTimestamp() {
    var timestamp_button = 
      $('#right-panel .options .timestamp');
    if(this.show_timestamp) {
      if($(this.messages).hasClass('no-timestamp')) {
        $(this.messages).removeClass('no-timestamp');
        $(timestamp_button).addClass('active');
        $(timestamp_button).attr('title', language.currentString(41));
        $(timestamp_button).attr('title-str', 41);
      }
    } else {
      if(!$(this.messages).hasClass('no-timestamp')) {
        $(this.messages).addClass('no-timestamp');
        $(timestamp_button).removeClass('active');
        $(timestamp_button).attr('title', language.currentString(166));
        $(timestamp_button).attr('title-str', 166);
      }
    }
    store.set('show_timestamp', this.show_timestamp);
  }

  /**
   * Toggles the autoscroll feature of the command window, ensuring the latest messages are always in view.
   */
  setAutoscroll() {
    var autoscroll_button = 
      $('#right-panel .options .autoscroll');
    if(this.autoscroll) {
      if(!$(autoscroll_button).hasClass('active')) {
        $(autoscroll_button).addClass('active');
        $(autoscroll_button).attr('title', language.currentString(42));
        $(autoscroll_button).attr('title-str', 42);
      }
    } else {
      if($(autoscroll_button).hasClass('active')) {
        $(autoscroll_button).removeClass('active');
        $(autoscroll_button).attr('title', language.currentString(167));
        $(autoscroll_button).attr('title-str', 167);
      }
    }
    store.set('autoscroll', this.autoscroll);
  }

  /**
   * Sets the maximum number of messages to display in the command window before older messages are removed.
   */
  setNMessagesMax() {
    var N_messages_max_input =
      $('#right-panel .terminal-settings .N-messages-max');
    if(this.N_messages_max < 5) {
      this.N_messages_max = 5;
    }
    if($(N_messages_max_input).val() != this.N_messages_max) {
      $(N_messages_max_input).val(this.N_messages_max);
    }
    store.set('N_messages_max', this.N_messages_max);
  }

  /**
   * Toggles whether timestamps are written to the log file.
   */
  setWriteTimestamps() {
    var write_timestamps_input =
      $('#right-panel .terminal-log .write-timestamps')[0];
    if(this.write_timestamps) {
      if(!write_timestamps_input.checked) {
        write_timestamps_input.checked = true;
      }
    } else {
      if(write_timestamps_input.checked) {
        write_timestamps_input.checked = false;
      }
    }
    store.set('write_timestamps', this.write_timestamps);
  }

  /**
   * Saves the current log of the command window to a file.
   */
  saveLog() {
    let options = {
     title: language.currentString(150),
     defaultPath : 'jslab_'+ this.win.app.getDateTimeFullStr() + '.log',
     buttonLabel: language.currentString(151),
     filters: [
      {name: 'Log', extensions: ['log', 'txt']},
      {name: 'All Files', extensions: ['*']}
     ]
    };

    var obj = this;
    ipcRenderer.invoke('dialog', 'showSaveDialog', options).then(function(result) {
      if(!result.canceled) {
        var data = '';
        obj.log.forEach(function(x) {
          data += x.class + ': ';
          if(obj.write_timestamps) {
            data += '[' + x.timestamp + '] ';
          }
          data += x.data + '\r\n';
        });

        const fs = require('fs');
        fs.writeFile(result.filePath, data, function(err) {
          if(err) {
            obj.errorInternal(err);
          }
        });
      }
    }).catch(function(err) {
      obj.errorInternal(err);
    });
  }

  /**
   * Scrolls the command window to the bottom, ensuring the latest messages are visible.
   */
  scrollToBottom() {
    var bcr = this.messages[0].getBoundingClientRect();
    $(this.messages).parent()[0].scrollTop = bcr.height;
  }

  /**
   * Generates a timestamp for use in the command window.
   * @returns {string} A string representing the current timestamp.
   */
  getTimestamp() {
    var date = new Date();
    var pad = function(num, size) {
      return('000' + num).slice(size * -1);
    };
    var time = parseFloat(date.getTime()/1000).toFixed(3);
    var hours = date.getHours();
    var minutes = Math.floor(time / 60) % 60;
    var seconds = Math.floor(time - minutes * 60);
    var milliseconds = time.slice(-3);

    return pad(hours, 2) + ':' + pad(minutes, 2) + ':' +
      pad(seconds, 2) + '.' + pad(milliseconds, 3);
  }

  /**
   * Provides a function to replace circular references while stringifying an object. Useful for logging objects with circular references.
   * @returns {Function} A replacer function for JSON.stringify.
   */
  getCircularReplacer() {
    const seen = new WeakSet();
    return function(key, value) {
      if(typeof value === 'object' && value !== null) {
        if(seen.has(value)) {
          return;
        }
        seen.add(value);
      }
      return value;
    };
  }

  /**
   * Formats and pretty-prints data for display in the command window.
   * @param {object|string} data The data to format.
   * @returns {string} The formatted data as a string.
   */
  prettyPrint(data) {
    if(typeof data == 'string') {
      return data.replace(/\n/g, '<br/>');
    } else if(typeof data == 'object') {
      if(!Object.keys(data).length){
        if(data.constructor.name == 'Error') {
          return data.stack.toString();
        } else {
          return data.toString();
        }
      } else {
        return JSON.stringify(data, this.getCircularReplacer(), 2);
      }
    } else {
      return String(data);
    }
  }

  /**
   * Truncates strings in data to config.MAX_JSON_STRING_LENGTH.
   * @param {any} data - Data to be processed.
   * @returns {any} Truncated data.
   */
  truncateStrings(data) {
    if(typeof data === 'string') {
      if(data.length <= config.MAX_JSON_STRING_LENGTH) return data;

      const suffix_prefix = " ... [truncated | full size: ";
      const suffix_suffix = "]";
      
      let prefix_length = config.MAX_JSON_STRING_LENGTH;
      while(true) {
        const full_size_digits = String(data.length).length;
        const suffix_length = suffix_prefix.length + full_size_digits + suffix_suffix.length;
        const new_prefix_length = config.MAX_JSON_STRING_LENGTH - suffix_length;
        if(new_prefix_length >= prefix_length) {
          prefix_length = new_prefix_length;
          break;
        }
        if(new_prefix_length === prefix_length) break;
        prefix_length = new_prefix_length;
      }
      const suffix = suffix_prefix + data.length + suffix_suffix;
      return data.slice(0, prefix_length) + suffix;
    } else if(Array.isArray(data)) {
      return data.map(item => this.truncateStrings(item));
    } else if(data !== null && typeof data === 'object') {
      const new_obj = {};
      for(const key in data) {
        if(Object.prototype.hasOwnProperty.call(data, key)) {
          new_obj[key] = this.truncateStrings(data[key]);
        }
      }
      return new_obj;
    }
    return data;
  }
}

exports.PRDC_JSLAB_COMMAND_WINDOW = PRDC_JSLAB_COMMAND_WINDOW;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={eval.js}]
/**
 * @file JSLAB eval module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const path = require('path');

/**
 * Class for JSLAB eval.
 */
class PRDC_JSLAB_EVAL {

  /**
   * Initializes the script evaluation functionality, setting up the necessary environment and variables.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    this.last_script_path;
    this.jslfilename = 'jslcmdwindow';
  }

  /**
   * Evaluates a script from the specified path, optionally focusing on specific lines. Manages the evaluation process to prevent overlap with ongoing evaluations.
   * @param {string} script_path The path to the script file to be evaluated.
   * @param {Array<number>} [lines] Optional. Specifies the lines of the script to focus the evaluation on.
   */
  evalScript(script_path, lines) {
    if(!this.win.evaluating) {
      this.last_script_path = script_path;
      script_path = script_path.replace(/\\/g, '\\\\');
      var cmd;
      if(lines !== undefined) {
        cmd = 'run("' + script_path + ', ' + lines.toString() + '")';
      } else {
        cmd = 'run("' + script_path + '")';
      }
      this.evalCommand(cmd);
    } else {
      this.win.command_window.message('@evalScript: Sandbox is busy...');
    }
  }

  /**
   * Evaluates a given command, optionally displaying the output in the application's command window. Manages the command evaluation process to prevent overlap with ongoing evaluations.
   * @param {string} cmd The command to be evaluated.
   * @param {boolean} [show_output=true] Specifies whether the output of the command should be displayed in the command window.
   * @param {string} [jsl_file_name='jslcmdwindow'] Specifies the file name context for the command evaluation.
   */
  evalCommand(cmd, show_output = true, jsl_file_name = 'jslcmdwindow') {
    if(!this.win.evaluating) {
      if(cmd.length) {
        this.win.command_window.addMessageCmd(cmd);
        this.win.command_history.updateHistory(cmd);
        this.win.command_window.code_input.setValue('');
        this.win.command_window.scrollToBottom();
        this.win.command_window.resetHistoryIndex();
        this.evalCode(cmd, show_output, jsl_file_name);
      }
    } else {
      this.win.command_window.message('@evalCommand: Sandbox is busy...');
    }
  }

  /**
   * Directly evaluates code, interacting with the sandbox environment for execution. Ensures that only one evaluation is happening at any time.
   * @param {string} code The code snippet to be evaluated.
   * @param {boolean} [show_output=true] Specifies whether the output of the code evaluation should be shown.
   * @param {string} [jsl_file_name='jslcmdwindow'] The context file name for the code evaluation.
   */
  evalCode(code, show_output = true, jsl_file_name = 'jslcmdwindow') {
    if(!this.win.evaluating) {
      this.win.evaluating = true;
      ipcRenderer.send('SandboxWindow', 'eval-code', 
        [code, show_output, jsl_file_name]);
    } else {
      this.win.command_window.message('@evalCode: Sandbox is busy...');
    }
  }

  /**
   * Handles actions for the script directory dialog buttons, including changing the active directory, saving the directory to paths, and running the last script.
   * @param {number} s The button state indicating the action to be performed.
   */
  scriptDirDialogButton(s) {
    this.win.gui.closeDialog($('#script-path-container'));
    var script_dir = path.dirname(this.last_script_path);
    if(s == 2) {
      // Change active directory
      this.win.folder_navigation.setPath(script_dir);
    } else if(s == 1) {
      // Add directory to saved paths
      this.win.folder_navigation.savePath(script_dir);
    }
    
    ipcRenderer.send('SandboxWindow', 'run-last-script'); 
  }

}

exports.PRDC_JSLAB_EVAL = PRDC_JSLAB_EVAL;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={file-browser.js}]
/**
 * @file JSLAB file browser module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const fs = require('fs');
const path = require('path');

/**
 * Class for JSLAB file browser.
 */
class PRDC_JSLAB_FILE_BROWSER {

  /**
   * Initializes the file browser, setting up the UI component and event listeners for file browser interactions.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    this.file_browser_cont = document.getElementById('file-browser-cont');
    
    // File browser refresh button click
    $('#file-browser-options .refresh').click(function(e){
      obj.updateFileBrowser();
    });
  }

  /**
   * Displays the contents of a specified folder within the file browser UI, optionally clearing the current display and replacing it with the new content.
   * @param {string} folder_path The path to the folder whose contents should be displayed.
   * @param {HTMLElement} [element=this.file_browser_cont] The HTML element where the folder contents should be displayed. Defaults to the file browser container.
   * @param {boolean} [root=false] Indicates whether the folder is the root folder being displayed. If true, the browser will clear its current content.
   */
  showFolderContent(folder_path, element = this.file_browser_cont, root = false) {
    var obj = this;
    var ul = document.createElement('ul');
    ul.setAttribute('path', folder_path.replace(/\\/g, '/'));
    if(root) {
      $(element).html('');
    } else {
      $(element).find('ul').remove();
    }
    fs.readdir(folder_path, {withFileTypes: true}, function(err, dirents) {
      if(err) {
        obj.win.command_window.errorInternal(language.string(92) + ': ' + err);
        return;
      }
      
      dirents.sort((a, b) => {
        if(a.isDirectory() && !b.isDirectory()) return -1;
        if(!a.isDirectory() && b.isDirectory()) return 1;

        return a.name.localeCompare(b.name);
      });
    
      dirents.forEach(function(dirent) {
        var absolute_path = path.join(folder_path, dirent.name);
        obj.addFileBrowserItem(absolute_path, dirent, ul);
      });
      $(ul).appendTo(element).hide().slideDown(300, 'linear');
    });
  }

  /**
   * Adds an item to the file browser UI, such as a file or folder, including its name and an icon indicating its type.
   * @param {string} absolute_path The absolute path to the file or folder to add.
   * @param {HTMLElement} ul The unordered list (UL) HTML element to which the item should be added.
   */
  addFileBrowserItem(absolute_path, dirent, ul) {
    var obj = this;
    var type_folder = false;
    var li = document.createElement('li');
    li.setAttribute('path', absolute_path.replace(/\\/g, '/'));
    li.innerHTML = '<span>' + path.basename(absolute_path) + '</span>';
    
    if(dirent.isDirectory()) {
      li.className = 'folder';
      type_folder = true;
    } else if(dirent.isSymbolicLink()) {
      li.className = 'link';
      absolute_path = fs.readlinkSync(absolute_path);
      type_folder = true;
    } else {
      li.className = 'file';
      li.ondblclick = function(e) {
        e.stopPropagation();
        e.preventDefault();
        ipcRenderer.send('EditorWindow', 'open-script', [absolute_path]);
      };
      var ext = absolute_path.split('.').pop();
      if(ext == 'jsl') {
        li.classList.add('jsl');
      } else if(ext == 'js') {
        li.classList.add('js');
      } else if(ext == 'json') {
        li.classList.add('json');
      }
    }
    if(type_folder) {
      li.ondblclick = function(e) {
        e.stopPropagation();
        e.preventDefault();
        obj.win.folder_navigation.setPath(absolute_path);
      };
      var expand = document.createElement('i');
      expand.className = 'expend';
      expand.onclick = function(e) {
        e.stopPropagation();
        e.preventDefault();
        if($(this).hasClass('expended')) {
          $(this).removeClass('expended');
          var parent_ul = $(this).parent().find('ul');
          $(parent_ul).slideUp(300, 'linear', function() {
            $(parent_ul).remove();
          });
        } else {
          $(this).addClass('expended');
          obj.showFolderContent(absolute_path, $(this).parent());
        }
      };
      li.appendChild(expand);
    } 
    ul.appendChild(li);
  }
              
  /**
   * Refreshes the file browser to reflect the current state of the filesystem or the contents of the current directory.
   */
  updateFileBrowser() {
    this.win.folder_navigation.setPath(this.win.folder_navigation.current_path);
  }

}

exports.PRDC_JSLAB_FILE_BROWSER = PRDC_JSLAB_FILE_BROWSER;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={folder-navigation.js}]
/**
 * @file JSLAB folder navigation module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const fs = require('fs');
const path = require('path');
const { pathEqual } = require('path-equal');
const Store = require('electron-store');

const store = new Store();

/**
 * Class for JSLAB folder navigation.
 */
class PRDC_JSLAB_FOLDER_NAVIGATION {

  /**
   * Initializes folder navigation, setting up UI components and event listeners for folder navigation actions.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    this.current_path = undefined;
    this.saved_paths = [];
    this.path_history = [];
    this.i_path_history = 0;
    
    this.folder_navigation_cont = document.getElementById('folder-navigation-container');
    
    // Folder navigation
    $('#folder-navigation-container .address-line').blur(function() {
      obj.onPathInput(this);
    });
    $('#folder-navigation-container .address-line').on('keydown', function(e) {
      if(e.key == 'Enter' && !e.shiftKey) {
        // Enter
        e.stopPropagation();
        e.preventDefault();
        obj.onPathInput(this);
      }
    });
    $('#folder-navigation-container .address-line').focus(function() {
      this.setSelectionRange(0, this.value.length);
    });
    $('#folder-navigation-container .open-folder').click(function() {
      let options = {
       title: language.currentString(148),
       defaultPath: obj.current_path,
       buttonLabel: language.currentString(149),
       properties: ['openDirectory']
      };
      ipcRenderer.invoke('dialog', 'showOpenDialog', options).then(function(result) {
        if(!result.canceled) {
          obj.setPath(result.filePaths[0]);
        }
      }).catch(function(err) {
        obj.win.command_window.errorInternal(err);
      });
    });
    $('#folder-navigation-container .up-folder').click(function() {
      var folders = obj.current_path.split(path.sep);
      folders = folders.filter(function(el) { return el != ''; });
      folders.pop();
      if(folders.length == 1) {
        obj.setPath(folders);
      } else {
        obj.setPath(path.join(...folders));
      }
    });
    $('#folder-navigation-container .previous-folder').click(function() {
      obj.setPath(obj.current_path, obj.i_path_history+1);
    });
    $('#folder-navigation-container .next-folder').click(function() {
      obj.setPath(obj.current_path, obj.i_path_history-1);
    });
    
    // Paths logic
    $('#paths-menu').click(function() {
      obj.updatePathsList();
      obj.win.gui.openPathsMenu();
    });
    $('#paths-close').click(function() {
      obj.win.gui.closePathsMenu();
    });
    $('#paths-container').on('keydown', function(e) {
      if(e.key == 'Escape') {
        // ESC
        obj.win.gui.closePathsMenu();
        e.stopPropagation();
        e.preventDefault();
      }
    });
    $('#save-path').click(function() {
      obj.toggleSavePath();
    });
    
    // Script path logic
    $('#script-path-close').click(function() {
      obj.win.gui.closeDialog($('#script-path-container'));
    });
    $('#script-path-container').on('keydown', function(e) {
      if(e.key == 'Escape') {
        // ESC
        obj.win.gui.closeDialog($('#script-path-container'));
        e.stopPropagation();
        e.preventDefault();
      }
    });
    
    // Saved paths
    this.saved_paths = store.get('saved_paths');
    if(!this.saved_paths) {
      this.saved_paths = [];
    }
    ipcRenderer.send('SandboxWindow', 'set-saved-paths', this.saved_paths);
    
    // Set path
    var current_path = store.get('current_path');
    if(!current_path || !(fs.existsSync(current_path) && 
        fs.lstatSync(current_path, {throwIfNoEntry: false}).isDirectory())) {
      current_path = this.win.app.documents_path;
    }
    this.setPath(current_path);
  }
 
  /**
   * Processes the input from the address line, navigating to the specified path if it is different from the current path.
   * @param {HTMLElement} e The HTML input element containing the path.
   */
  onPathInput(e) {
    var new_path = $(e).val();
    new_path = this.addPathSep(new_path);
    if(!pathEqual(new_path, this.current_path)) {
      $(e).val(new_path);
      this.setPath(new_path);
    }
  }

  /**
   * Sets the current path for navigation, updating the UI and internal state accordingly. Supports navigation through history via index.
   * @param {string} new_path The new path to set as the current directory.
   * @param {number} [i=undefined] Optional index for navigation through the path history.
   * @param {boolean} [inform_sandbox=true] Whether to inform the sandbox process of the path change.
   */
  setPath(new_path, i = undefined, inform_sandbox = true) {
    new_path = this.addPathSep(new_path);
    if(this.checkDirectory(new_path)) {
      if(!pathEqual(new_path, this.current_path) && i === undefined) {
        this.path_history.unshift(new_path);
        if(this.path_history.length > 1) {
          $('#folder-navigation-container .previous-folder').removeClass('disabled');
          $('#folder-navigation-container .next-folder').addClass('disabled');
          this.i_path_history = 0;
        }
      } else if(i !== undefined && i >= 0 &&
          i < this.path_history.length) {
        this.i_path_history = i;
        new_path = this.path_history[i];
        if(i == 0) {
          $('#folder-navigation-container .next-folder').addClass('disabled'); 
        } else {
          $('#folder-navigation-container .next-folder').removeClass('disabled'); 
        }
        if(i == (this.path_history.length-1)) {
          $('#folder-navigation-container .previous-folder').addClass('disabled'); 
        } else {
          $('#folder-navigation-container .previous-folder').removeClass('disabled'); 
        }
      }

      this.current_path = new_path;
      if(inform_sandbox) {
        ipcRenderer.send('SandboxWindow', 'set-current-path', new_path);
      }
      if(this.saved_paths.indexOf(this.current_path) >= 0) {
        $('#save-path').addClass('saved');
      } else {
        $('#save-path').removeClass('saved');
      }
      this.win.file_browser.showFolderContent(this.current_path, undefined, true);
    } else {
      this.setPath(this.win.app.documents_path);
    }
   this.showCurrentPath();
  }

  /**
   * Saves the current path to the list of saved paths for quick access.
   * @param {string} new_path The path to save.
   * @param {boolean} [inform_sandbox=true] Whether to inform the sandbox process of the update.
   */
  savePath(new_path, inform_sandbox = true) {
    new_path = this.addPathSep(new_path);
    var i = this.saved_paths.indexOf(new_path);
    if(i < 0) {
      this.saved_paths.push(new_path);
    }
    if(inform_sandbox) {
      ipcRenderer.send('SandboxWindow', 'set-saved-paths', this.saved_paths);
    }
  }

  /**
   * Removes a path from the list of saved paths.
   * @param {string} saved_path The path to remove.
   * @param {boolean} [inform_sandbox=true] Whether to inform the sandbox process of the update.
   */
  removePath(saved_path, inform_sandbox = true) {
    saved_path = this.addPathSep(saved_path);
    var i = this.saved_paths.indexOf(saved_path);
    if(i >= 0) {
      this.saved_paths.splice(i, 1);
    }
    if(inform_sandbox) {
      ipcRenderer.send('SandboxWindow', 'set-saved-paths', this.saved_paths);
    }
  }
 
  /**
   * Toggles the current path between being saved and not saved, updating the UI and stored paths accordingly.
   */
  toggleSavePath() {
    var i = this.saved_paths.indexOf(this.current_path);
    if(i >= 0) {
      this.removePath(this.current_path);
      $('#save-path').removeClass('saved');
    } else {
      this.savePath(this.current_path);
      $('#save-path').addClass('saved');
    }
    this.updatePathsList();
  }

  /**
   * Updates the UI to display the current path in the address line and navigation breadcrumbs.
   */
  showCurrentPath() {
    var obj = this;
    $('#folder-navigation-container .address-line').val(this.current_path);
    var folders = this.current_path.split(path.sep);
    folders = folders.filter(function(el) { return el != ''; });
    var address = $('#folder-navigation-container .current-address')[0];
    address.innerHTML = '';
    var full_path = folders[0];
    if(folders.length == 1) {
      $('#folder-navigation-container .up-folder').addClass('disabled');
    } else {
      $('#folder-navigation-container .up-folder').removeClass('disabled');
    }      
    for(var i = 0; i < folders.length; i++) {
      if(i > 0) {
        full_path += path.sep;
        full_path += folders[i];
      }
      if(folders[i] != '') {
        var span = document.createElement('span');
        span.className = 'folder';
        span.title = full_path;
        if(i == 0) {
          span.title += path.sep;
        }
        span.textContent = folders[i];
        span.onclick = function() {
          obj.setPath(this.title);
        };
        address.appendChild(span);
        if(i != (folders.length-1)) {
          $(address).append('<i class="i-next-folder"></i>');
        }
      }
    }
  }
   
  /**
   * Updates the list of saved paths in the UI, allowing users to quickly navigate to frequently accessed directories.
   */
  updatePathsList() {
    var obj = this;
    var cont = $('#paths-container .page-panel ul');
    if(this.saved_paths.length > 0) {
      $(cont).html('');
      this.saved_paths.forEach(function(saved_path) {
        var row = document.createElement('li');
        row.textContent = saved_path;
        row.onclick = function() {
          obj.win.gui.closePathsMenu();
          obj.setPath(saved_path);
        };
        if(!obj.checkDirectory(saved_path)) {
          row.className = 'inactive';
        }
        var btn = document.createElement('img');
        btn.src = '../img/close.svg';
        btn.className = 'remove-path';
        btn.onclick = function(event) {
          event.preventDefault();
          event.stopPropagation();
          if(pathEqual(saved_path, obj.current_path)) {
            $('#save-path').removeClass('saved');
          }
          obj.removePath(saved_path);
          $(this).parent().remove();
          if(obj.saved_paths.length == 0) {
            $(cont).html('<li class="no-paths">'+language.string(140)+'</li>');
          }
        };
        row.appendChild(btn);
        $(cont).append(row);
      });
    } else {
      $(cont).html('<li class="no-paths">'+language.string(140)+'</li>');
    }
  }
  
  /**
   * Handles UI and state updates when a script directory is unknown, prompting the user for action.
   */
  unknownScriptDir() {
    var script_dir = this.addPathSep(path.dirname(this.win.eval.last_script_path));
    $('#script-path').text(script_dir);
    this.win.gui.openDialog($('#script-path-container'));
    return true;
  }
  
  /**
   * Appends a path separator to the end of a path string if it is not already present.
   * @param {string} path_str The path string to modify.
   * @return {string} The modified path string with a trailing separator.
   */
  addPathSep(path_str) {
    if(path_str && path_str[path_str.length-1] != path.sep) {
      path_str += path.sep;
    }
    return path_str;
  }
  
  /**
   * Checks if the specified directory exists and is a directory.
   * @param {string} directory The path to check.
   * @return {boolean} True if the directory exists and is a directory, false otherwise.
   */
  checkDirectory(directory) {
    var lstat = fs.lstatSync(directory, {throwIfNoEntry: false});
    if(lstat != undefined && lstat.isDirectory()) {
      return true;        
    } else {
      return false;
    }
  }
  
  /**
   * Checks if the specified file exists and is a file.
   * @param {string} file_path The path to the file to check.
   * @return {boolean} True if the file exists and is a file, false otherwise.
   */
  checkFile(file_path) {
    var lstat = fs.lstatSync(file_path, {throwIfNoEntry: false});
    if(lstat != undefined && lstat.isFile()) {
      return true;        
    } else {
      return false;
    }
  }
}

exports.PRDC_JSLAB_FOLDER_NAVIGATION = PRDC_JSLAB_FOLDER_NAVIGATION;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={gui.js}]
/**
 * @file JSLAB GUI module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB GUI.
 */
class PRDC_JSLAB_GUI {

  /**
   * Initializes the GUI, setting up event listeners for window controls, menu actions, and dialog interactions.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    this.state = 'ready';
    this.stats = {};
    this.stats_num = 0;
    this.fullscreen = false;
    
    this.last_focus = document.activeElement;
    this.status_cont = document.getElementById('status');
    this.sandbox_stats_icon = document.getElementById('sandbox-stats-icon');
    
    document.addEventListener("keydown", function(e) {
      if(e.key == 'F11') {
        obj.toggleFullscreen();
      }
    });
        
    // On devtools-menu click
    $('#devtools-menu').click(function() {
      ipcRenderer.send('MainProcess', 'show-dev-tools');
    });

    // On editor-menu click
    $('#editor-menu').click(function() {
      ipcRenderer.send('MainProcess', 'show-editor');
    });
            
    $("#script-path-dialog-change-dir").click(function() { obj.win.eval.scriptDirDialogButton(2); });
    $("#script-path-dialog-save").click(function() { obj.win.eval.scriptDirDialogButton(1); });
    $("#script-path-dialog-run").click(function() { obj.win.eval.scriptDirDialogButton(0); });
    
    // Window controls    
    window.addEventListener('resize', function() {
      // Detect change of maximize
      obj.maximized = ipcRenderer.sendSync('sync-message', 'is-maximized-win');
      if(obj.maximized) {
       $("#win-restore img").attr('src', '../img/win-restore.svg');
      } else {
       $("#win-restore img").attr('src', '../img/win-maximize.svg');
      }
    }, true);
    
    $("#win-close").click(function() {
      obj.win.close();
    });
    
    $("#win-restore").click(function() {
      obj.toggleFullscreen(false);
      obj.maximized = !obj.maximized;
      if(obj.maximized) {
       ipcRenderer.send('MainProcess', 'maximize-win');
      } else {
       ipcRenderer.send('MainProcess', 'restore-win');
      }
    });
    
    $("#win-minimize").click(function() {
      obj.toggleFullscreen(false);
      ipcRenderer.send('MainProcess', 'minimize-win');
    });
    window.dispatchEvent(new Event('resize'));
  }

  /**
   * Invoked when the GUI is ready, performing initial UI setup tasks such as fading in the window.
   */
  onReady() {
    // Fade in window
    ipcRenderer.send('MainProcess', 'fade-in-win');
  }

  /**
   * Toggles the fullscreen state of the application window.
   * @param {boolean} [fullscreen] Optional. Specifies the fullscreen state. If not provided, the state is toggled based on the current state.
   */
  toggleFullscreen(fullscreen) {
    if(fullscreen == null) {
      fullscreen = !this.fullscreen;
    }
    if(fullscreen) {
      ipcRenderer.send('MainProcess', 'set-fullscreen', true);
    } else {
      ipcRenderer.send('MainProcess', 'set-fullscreen', false);
    }
    this.fullscreen = fullscreen;
  }
  
  /**
   * Updates the status displayed in the status bar of the application.
   * @param {string} state The current state to display.
   * @param {string} txt The text to display in the status bar.
   */
  setStatus(state, txt) {
    this.state = state;
    $(this.status_cont).html(txt);
    this.setStatsIcon();
  }
  
  /**
   * Resets the stats data to initial values.
   */
  resetStats() {
    this.setStatus('ready', language.string(87));
    var stats = {
      'required_modules': 0,
      'promises': 0,
      'timeouts': 0,
      'immediates': 0,
      'intervals': 0,
      'animation_frames': 0,
      'idle_callbacks': 0
    };
    this.setStats(stats);
  }
  
  /**
   * Updates the statistics displayed in the GUI, such as the number of active promises, timeouts, and intervals.
   * @param {object} stats An object containing statistical information to display.
   */
  setStats(stats) {
    this.stats = stats;
    $('#sandbox-required-modules-num').text(stats['required_modules']);
    $('#sandbox-promises-num').text(stats['promises']);
    $('#sandbox-timeouts-num').text(stats['timeouts']);
    $('#sandbox-immediates-num').text(stats['immediates']);
    $('#sandbox-intervals-num').text(stats['intervals']);
    $('#sandbox-animation-frames-num').text(stats['animation_frames']);
    $('#sandbox-idle-callbacks-num').text(stats['idle_callbacks']);
    this.stats_num = stats['promises']+stats['timeouts']+stats['immediates']+
      stats['intervals']+stats['animation_frames']+stats['idle_callbacks'];
    this.setStatsIcon();
  }

  /**
   * Updates the visibility and appearance of the statistics icon based on the current application state and stats.
   */
  setStatsIcon() {
    this.sandbox_stats_icon.className = '';
    if(this.state == 'ready') {
      if(this.stats_num > 0) {
        this.sandbox_stats_icon.classList.add('async-busy');
      } else {
        this.sandbox_stats_icon.classList.add('ready');
      }
    } else {
      this.sandbox_stats_icon.classList.add('busy');
    }
  }
  
  /**
   * Opens a specified dialog within the application.
   * @param {jQuery} e The jQuery object representing the dialog to open.
   */
  openDialog(e) {
    if(!e.is(':visible')) {
      this.last_focus = document.activeElement;
      $('.main-dialog').fadeOut(300, 'linear');
      e.fadeIn(300, 'linear', function() {
        e.focus();
      });
    }
  }
 
  /**
   * Closes a specified dialog within the application.
   * @param {jQuery} e The jQuery object representing the dialog to close.
   */
  closeDialog(e) {
    e.fadeOut(300, 'linear');
    $(this.last_focus).focus();
  } 

  /**
   * Opens the paths menu dialog, providing quick access to saved and frequently used paths.
   */
  openPathsMenu() {
    this.openDialog($('#paths-container'));
  }
  
  /**
   * Closes the paths menu dialog.
   */
  closePathsMenu() {
    this.closeDialog($('#paths-container'));
  }

  /**
   * Opens the help dialog, providing access to application documentation or assistance.
   */
  help() {
    this.openDialog($('#help-container'));
  }

  /**
   * Closes the help dialog.
   */
  closeHelp() {
    this.closeDialog($('#help-container'));
  }

  /**
   * Opens the application info dialog, displaying information about the application.
   */
  info() {
    this.openDialog($('#info-container'));
  }

  /**
   * Closes the application info dialog.
   */
  closeInfo() {
    this.closeDialog($('#info-container'));
  }

  /**
   * Opens the settings dialog, allowing the user to configure application settings.
   */
  settings() {
    this.openDialog($('#settings-container'));
  }

  /**
   * Closes the settings dialog.
   */
  closeSettings() {
    this.closeDialog($('#settings-container'));
  }
  
  /**
   * Changes the application language to the specified language ID.
   * @param {number} id The ID of the language to switch to.
   */
  changeLangauge(id) {
    language.set(id);
    ipcRenderer.send('EditorWindow', 'set-language', id);
    ipcRenderer.send('SandboxWindow', 'set-language', id);
  }
}

exports.PRDC_JSLAB_GUI = PRDC_JSLAB_GUI;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={help.js}]
/**
 * @file JSLAB help module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB help.
 */
class PRDC_JSLAB_HELP {

  /**
   * Initializes the help functionality, setting up event listeners for help menu actions and dialog interactions.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    // Help logic
    $('#help-menu').click(function() { obj.win.gui.help(); });
    
    $('#help-close').click(function() { obj.win.gui.closeHelp(); });
    
    $('#help-container').on('keydown', function(e) {
      if(e.key == 'Escape') {
        // ESC
        obj.win.gui.closeHelp();
        e.stopPropagation();
        e.preventDefault();
      }
    });
  }

}

exports.PRDC_JSLAB_HELP = PRDC_JSLAB_HELP
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={info.js}]
/**
 * @file JSLAB info module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB info.
 */
class PRDC_JSLAB_INFO {

  /**
   * Initializes the information display functionality, setting up event listeners for information menu actions and dialog interactions.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    // Info logic
    $('#info-container .app-version').text('version ' + this.win.app.version);
    $('#info-menu').click(function() { obj.win.gui.info(); });
    $('#info-close').click(function() { obj.win.gui.closeInfo(); });
    $('#info-container').on('keydown', function(e) {
      if(e.key == 'Escape') {
        // ESC
        obj.win.gui.closeInfo();
        e.stopPropagation();
        e.preventDefault();
      }
    });
  }

}

exports.PRDC_JSLAB_INFO = PRDC_JSLAB_INFO
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={init-main.js}]
/**
 * @file JSLAB main window init file
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

// Modules
// --------------------
const { ipcRenderer } = require('electron');


const helper = require("../js/helper.js");
require("../js/init-config.js");
const { PRDC_APP_LOGGER } = require('../lib/PRDC_APP_LOGGER/PRDC_APP_LOGGER');
const { PRDC_JSLAB_LANGUAGE } = require('../js/language');

global.app_path = process.argv.find(e => e.startsWith('--app-path=')).split('=')[1].replace(/\\js\\?$/, '');

const { PRDC_JSLAB_WIN_MAIN } = require('../js/main/win-main');

// Start log
const log_file = ipcRenderer.sendSync('sync-message', 'get-log-file');
const app_logger = new PRDC_APP_LOGGER(log_file);

// Global variables
var language = new PRDC_JSLAB_LANGUAGE();
var win_main = new PRDC_JSLAB_WIN_MAIN();

// When document is ready
// --------------------
ready(function() {
  // Jquery ready
  $(document).ready(function() {
    win_main.onReady();
  });
});
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={panels.js}]
/**
 * @file JSLAB panels module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const { PRDC_PANEL } = require('../../lib/PRDC_PANEL/PRDC_PANEL');

/**
 * Class for JSLAB panels.
 */
class PRDC_JSLAB_PANELS {

  /**
   * Initializes main application panels and configures their default sizes and orientations.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    this.columns = new PRDC_PANEL('columns', 'vertical', document.getElementById('panels-container'), [document.getElementById('left-panel'), document.getElementById('right-panel')], config.PANEL_DEFAULT_COLUMNS);
    
    this.left_rows = new PRDC_PANEL('left-rows', 'horizontal', document.getElementById('left-panel'), [document.getElementById('left-top-panel'), document.getElementById('left-middle-panel'), document.getElementById('left-bottom-panel')], config.PANEL_DEFAULT_LEFT_ROWS);
    
    this.workspace_columns = new PRDC_PANEL('workspace-columns', 'vertical', document.getElementById('workspace'), ['#left-middle-panel .col-1', '#left-middle-panel .col-2', '#left-middle-panel .col-3'], config.PANEL_DEFAULT_WORKSPACE_COLUMNS);
    
    this.columns.addSubPanel(this.left_rows);
    this.left_rows.addSubPanel(this.workspace_columns);
    
    // Initialize panels
    window.addEventListener('resize', function() {
      obj.columns.onResize();
    });
  }

  /**
   * Invoked when the application window is ready, triggering an initial resize event to ensure panels are correctly laid out.
   */
  onReady() {
    this.columns.onResize();
  }
}

exports.PRDC_JSLAB_PANELS = PRDC_JSLAB_PANELS;

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={settings.js}]
/**
 * @file JSLAB settings module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB settings.
 */
class PRDC_JSLAB_SETTINGS {

  /**
   * Initializes the settings management functionality, setting up event listeners for settings menu actions and dialog interactions.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    // Settings logic
    $('#settings-menu').click(function() { obj.win.gui.settings(); });
    $('#settings-close').click(function() { obj.win.gui.closeSettings(); });
    $('#settings-container').on('keydown', function(e) {
      if(e.key == 'Escape') {
        // ESC
        obj.win.gui.closeSettings();
        e.stopPropagation();
        e.preventDefault();
      }
    });
    
    $('#settings-container .set-langauge').on('change', function() {
      obj.win.gui.changeLangauge($(this).val());
    });
    $("#settings-container .set-langauge").val(language.lang);
    
    $('#settings-container .change-settings').on('click', function() {
      obj.win.command_history.setMaxSize($('#settings-container .N-history-max').val());
      obj.win.gui.closeSettings();
    });
  }
}

exports.PRDC_JSLAB_SETTINGS = PRDC_JSLAB_SETTINGS
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={win-main.js}]
/**
 * @file JSLAB GUI script
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
// Modules
// --------------------
const { ipcRenderer } = require('electron');

const { PRDC_JSLAB_HELP } = require('./help');
const { PRDC_JSLAB_INFO } = require('./info');
const { PRDC_JSLAB_SETTINGS } = require('./settings');
const { PRDC_JSLAB_EVAL } = require('./eval');
const { PRDC_JSLAB_COMMAND_WINDOW } = require('./command-window');
const { PRDC_JSLAB_COMMAND_HISTORY } = require('./command-history');
const { PRDC_JSLAB_WORKSPACE } = require('./workspace');
const { PRDC_JSLAB_FOLDER_NAVIGATION } = require('./folder-navigation');
const { PRDC_JSLAB_FILE_BROWSER } = require('./file-browser');
const { PRDC_JSLAB_PANELS } = require('./panels');
const { PRDC_JSLAB_GUI } = require('./gui');
const { PRDC_JSLAB_APP } = require('./app');

const { PRDC_POPUP } = require('./../../lib/PRDC_POPUP/PRDC_POPUP');

const fs = require('fs');
const path = require('path');
const Store = require('electron-store');

const store = new Store();

/**
 * Class for JSLAB main win.
 */
class PRDC_JSLAB_WIN_MAIN {  

  /**
   * Create main win.
   */
  constructor() {
    var obj = this;

    // Classes
    this.eval = new PRDC_JSLAB_EVAL(this);
    this.workspace = new PRDC_JSLAB_WORKSPACE(this);
    this.file_browser = new PRDC_JSLAB_FILE_BROWSER(this);
    this.panels = new PRDC_JSLAB_PANELS(this);
    this.gui = new PRDC_JSLAB_GUI(this);
    this.help = new PRDC_JSLAB_HELP(this);
    this.app = new PRDC_JSLAB_APP(this);
    this.command_history = new PRDC_JSLAB_COMMAND_HISTORY(this);
    this.command_window = new PRDC_JSLAB_COMMAND_WINDOW(this);
    this.info = new PRDC_JSLAB_INFO(this);
    this.settings = new PRDC_JSLAB_SETTINGS(this);
    this.folder_navigation = new PRDC_JSLAB_FOLDER_NAVIGATION(this);
    
    this.flight_commands_popup = new PRDC_POPUP(document.getElementById('sandbox-stats-icon'),
      document.getElementById('sandbox-stats-popup'));
      
    // Prevent redirects
    preventRedirect();

    // Events
    // --------------------
    // Catch errors
    window.addEventListener('unhandledrejection', function(e) {
      obj.command_window.errorInternal(e.reason.stack);
      e.preventDefault();
    });

    window.addEventListener('error', function(e) {
      obj.command_window.errorInternal(e.error.stack);
      e.preventDefault();
    });

    // On IPC message
    ipcRenderer.on('MainWindow', function(event, action, data) {
      switch(action) {
        case 'editor-disp':
          var msg = data[0];
          var focus = data[1];
          obj.command_window.messageEditor(msg);
          if(focus) {
            ipcRenderer.send('MainProcess', 'focus-win');
          }
          break;
        case 'disp':
          obj.command_window.message(data);
          break;
        case 'disp-monospaced':
          obj.command_window.messageMonospaced(data);
          break;
        case 'disp-latex':
          obj.command_window.messageLatex(data);
          break;
        case 'error':
          obj.command_window.error(data);
          ipcRenderer.send('MainProcess', 'focus-win');
          break;
        case 'warn':
          obj.command_window.warn(data);
          ipcRenderer.send('MainProcess', 'focus-win');
          break;
        case 'internal-error':
          obj.command_window.errorInternal(data);
          ipcRenderer.send('MainProcess', 'focus-win');
          break;
        case 'run':
          var script_path = data[0];
          var lines = data[1];
          obj.eval.evalScript(script_path, lines);
          ipcRenderer.send('MainProcess', 'focus-win');
          break;
        case 'eval-command':
          obj.eval.evalCommand(data[0]);
          ipcRenderer.send('MainProcess', 'focus-win');
          break;
        case 'help':
          obj.gui.help();
          break;
        case 'info':
          obj.gui.info();
          break;
        case 'settings':
          obj.gui.settings();
          break;
        case 'clear':
          obj.command_window.clear();
          break;
        case 'save-path':
          var new_path = data;
          obj.folder_navigation.savePath(new_path, false);
          break;
        case 'remove-path':
          var saved_path = data;
          obj.folder_navigation.removePath(saved_path, false);
          break;
        case 'set-workspace':
          obj.workspace.setWorkspace(data);
          break;
        case 'update-workspace':
          obj.workspace.updateWorkspace();
          break;
        case 'update-file-browser':
          obj.file_browser.updateFileBrowser();
          break;
        case 'code-evaluating':
          obj.evaluating = true;
          break; 
        case 'code-evaluated':
          obj.evaluating = false;
          break; 
        case 'show-ans':
          obj.command_window.highlightAnsMessage(data);
          break;
        case 'set-status':
          var state = data[0];
          var txt = data[1];
          obj.gui.setStatus(state, txt);
          break;
        case 'set-stats':
          var stats = data;
          obj.gui.setStats(stats);
          break;
        case 'clear-storage':
          store.clear();
          break;
        case 'unknown-script-dir':
          obj.folder_navigation.unknownScriptDir();
          break;
        case 'set-current-path':
          obj.folder_navigation.setPath(data);
          break;
      }
    });

    // Keyboard events
    document.addEventListener('keydown', function(e) {
      // Show Dev Tools
      if(e.key == 'F12') {
        ipcRenderer.send('MainProcess', 'show-dev-tools');
        ipcRenderer.send('MainProcess', 'show-sandbox-dev-tools');
        e.stopPropagation();
        e.preventDefault();
      } else if(e.ctrlKey && e.key.toLowerCase() == 'c') {
        if(obj.getSelectionText() == "") {
          // No selected text
          obj.command_window.messageInternal(language.string(89));
          ipcRenderer.send('SandboxWindow', 'stop-loop', true);
          e.stopPropagation();
          e.preventDefault();
        }
      } else if(e.key.toLowerCase() == 'h' && e.ctrlKey) {
        // Ctrl + H
        obj.gui.help();
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key.toLowerCase() == 'i' && e.ctrlKey) {
        // Ctrl + I
        obj.gui.info();
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key.toLowerCase() == 's' && e.ctrlKey) {
        // Ctrl + S
        obj.gui.settings();
        e.stopPropagation();
        e.preventDefault();
      } else if(e.key.toLowerCase() == 'd' && e.ctrlKey) {
        // Ctrl + D
        obj.eval.evalCommand('openDoc()');
        e.stopPropagation();
        e.preventDefault();
      }
    });
  }
  
  /**
   * Method called when the program is ready to start.
   */
  onReady() {
    var obj = this;
    obj.processArguments();
    obj.panels.onReady();
    
    // Fade in window
    ipcRenderer.send('MainProcess', 'fade-in-win');
    
    // Focus code input
    obj.command_window.code_input.focus();
    obj.command_window.code_input.setCursor(
    obj.command_window.code_input.lineCount(), 0);
  }

  /**
   * Processes startup arguments, opening files or setting the workspace as needed.
   */
  processArguments() {
    // Process arguments
    if(process.argv.length > 0) {
      var arg = process.argv[1];
      
      // Check if there is scripts in argument
      if(arg && this.folder_navigation.checkFile(arg)) {
        // Open script in editor
        ipcRenderer.send('EditorWindow', 'open-script', [arg]);
        var dir = path.dirname(arg);
        if(dir !== undefined) {
          this.folder_navigation.setPath(dir);
        }
      }
    }
  }
  
  /**
   * Retrieves selected text within the application, if any.
   * @return {string} The currently selected text.
   */
  getSelectionText() {
    var text = "";
    if(window.getSelection) {
        text = window.getSelection().toString();
    } else if(document.selection && document.selection.type != "Control") {
        text = document.selection.createRange().text;
    }
    return text;
  }
  
  /**
   * Resets the sandbox and updates paths and settings.
   */
  onSandboxReset() {
    ipcRenderer.send('SandboxWindow', 'set-language', language.lang);
    ipcRenderer.send('SandboxWindow', 'set-saved-paths', this.folder_navigation.saved_paths);
    ipcRenderer.send('SandboxWindow', 'set-current-path', this.folder_navigation.current_path);
    this.command_window.clear();
    this.workspace.updateWorkspace();
    this.gui.resetStats();
    this.evaluating = false;
  }
   
  /**
   * Gracefully closes the application after performing necessary cleanup operations.
   */
  close() {
    store.set('full_history', this.command_history.full_history);
    store.set('current_path', this.folder_navigation.current_path);
    store.set('saved_paths', this.folder_navigation.saved_paths);
    ipcRenderer.send('MainProcess', 'close-app');
  }
}

exports.PRDC_JSLAB_WIN_MAIN = PRDC_JSLAB_WIN_MAIN;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={workspace.js}]
/**
 * @file JSLAB workspace module
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB workspace.
 */
class PRDC_JSLAB_WORKSPACE {

  /**
   * Initializes the workspace, setting up the UI component and event listeners for workspace interactions.
   * @param {object} win The window object representing the current Electron window.
   */
  constructor(win) {
    var obj = this;
    this.win = win;
    
    this.data = [];
    this.workspace_cont = document.getElementById('workspace');
    
    // Workspace clear button click
    $('#workspace-options .clear').click(function(){
      obj.win.eval.evalCommand('clear');
    });
  }

  /**
   * Updates the workspace with new data, refreshing the display of variables and their values.
   * @param {Array} data The data to be displayed in the workspace, typically an array of variable information.
   */
  setWorkspace(data) {
    this.data = data;
    this.updateWorkspace();
  }
  
  /**
   * Refreshes the workspace display based on the current data, updating the layout and content of the workspace area.
   */
  updateWorkspace() {
    var obj = this;
    
    var workspace_table = $('#workspace .table')[0];
    workspace_table.innerHTML = '';
    var cells_size = this.win.panels.workspace_columns.cells_size;
    this.data.forEach(function(v) {
      var row = document.createElement('div');
      row.onclick = function() {
        obj.win.command_window.code_input.setValue(this.getAttribute('variable'));
        obj.win.command_window.code_input.focus();
        obj.win.command_window.code_input.setCursor(obj.win.command_window.code_input.lineCount(), 0);
      };
      row.ondblclick = function() {
        obj.win.eval.evalCommand(this.getAttribute('variable'));
      };
      row.setAttribute('variable', v[0]);
      row.className = 'row';
      row.innerHTML = '<div class="col col-1" style="width:'+cells_size[0]+'%">' + v[0] +
        '</div><div class="col col-2" style="width:'+cells_size[1]+'%">' + v[1] +
        '</div><div class="col col-3" style="width:'+cells_size[2]+'%">' + v[2] + '</div>';
      workspace_table.appendChild(row);
    });
  }
}

exports.PRDC_JSLAB_WORKSPACE = PRDC_JSLAB_WORKSPACE;
\end{lstlisting}

% ------------------------------
\subsection{sandbox}


\begin{lstlisting}[style=JavaScriptStyle, caption={array.js}]
/**
 * @file JSLAB library array submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB array submodule.
 * Column-major order for matrix operation
 */
class PRDC_JSLAB_LIB_ARRAY {
  
  /**
   * Constructs an array submodule object for JSLAB.
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }
  
  /**
   * Converts an iterable or array-like object into a standard array.
   * @param {Iterable|ArrayLike} A - The iterable or array-like object to convert.
   * @returns {Array} A new array containing the elements from the input.
   */
  array(A) {
    return Array.from(A);
  }
  
  /**
   * Retrieves the last element from the provided array.
   * @param {Array} A - The array from which the last element is to be retrieved.
   * @returns {*} The last element of the array. If the array is empty, returns undefined.
   */
  end(A) {
    return A[A.length-1];
  }
  
  /**
   * Returns the index of the last element in the array.
   * @param {Array} A - The array to evaluate.
   * @returns {number} The index of the last element.
   */
  endi(A) {
    return A.length-1;
  }
  
  /**
   * Retrieves a specific column from the provided matrix.
   * @param {Array} A - The matrix array.
   * @param {number} col - The column index to retrieve.
   * @returns {Array} The specified column as an array.
   */
  column(A, col) {
    return A.map(function(x) { return x[col]; });
  }

  /**
   * Retrieves a specific row from the provided matrix.
   * @param {Array} A - The matrix array.
   * @param {number} row - The row index to retrieve.
   * @returns {Array} The specified row as an array.
   */
  row(A, row) {
    return A[row];
  }

  /**
   * Returns the first N elements from an array.
   * @param {Array} A - The input array.
   * @param {number} [N=1] - The number of elements to return from the start.
   * @returns {Array} - An array containing the first N elements.
   */
  first(A, N = 1) {
    return A.slice(0, N);
  }

  /**
   * Returns the last N elements from an array.
   * @param {Array} A - The input array.
   * @param {number} [N=1] - The number of elements to return from the end.
   * @returns {Array} - An array containing the last N elements.
   */
  last(A, N = 1) {
    return A.slice(-N);
  }
  
  /**
   * Generates an array of indices based on rows and columns.
   * @param {number|number[]} rows - The row index or array of row indices.
   * @param {number|number[]} cols - The column index or array of column indices.
   * @param {number} rows_max - The maximum number of rows.
   * @returns {number[]} An array of calculated indices.
   */
  index(rows, cols, rows_max) {
    if(!Array.isArray(rows)) {
      rows = [rows];
    }
    if(!Array.isArray(cols)) {
      cols = [cols];
    }
    var A = zeros(rows.length * cols.length);
    
    var k = 0;
    for(var j = 0; j < cols.length; j++) {
      for(var i = 0; i < rows.length; i++) {
        A[k++] = rows[i] + cols[j] * rows_max;
      }
    }
    
    return A;
  }
  
  /**
   * Finds all indices of a specified value in the array.
   * @param {Array} A - The array to search.
   * @param {*} value - The value to find.
   * @returns {number[]} An array of indices where the value is found.
   */
  indexOfAll(A, value) {
    return A.reduce(function(a, e, i) {
        if(e === value) {
          a.push(i);
        }
        return a;
    }, []);
  }
  
  /**
   * Returns the index of a value in an array.
   * @param {Array} A - Array to search.
   * @param {*} value - Value to locate.
   * @returns {number} Index of value or -1.
   */
  indexOf(A, value) {
    return A.indexOf(value);
  }
  
  /**
   * Finds the index of a sequence of elements in the array.
   * @param {Array} A - The array to search.
   * @param {Array} search_elements - The sequence of elements to find.
   * @param {number} [from_index=0] - The index to start the search from.
   * @returns {number} The starting index of the found sequence, or -1 if not found.
   */
  indexOfMulti(A, search_elements, from_index) {
    from_index = from_index || 0;

    var index = Array.prototype.indexOf.call(A, search_elements[0],
      from_index);
    if(search_elements.length === 1 || index === -1) {
      // Not found or no other elements to check
      return index;
    }

    for(var i = index, j = 0;
      j < search_elements.length && i < A.length; i++, j++) {
      if(A[i] !== search_elements[j]) {
        return indexOfMulti(A, search_elements, index + 1);
      }
    }

    return (i === index + search_elements.length) ? index : -1;
  }

  /**
   * Shuffles indices of an array using the Fisher-Yates algorithm.
   * @param {Array} array Array whose indices are to be shuffled.
   * @return {Array} Shuffled array of indices.
   */
  shuffleIndices(array) {
    const idx = Array.from(array.keys());
    for(let i = idx.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [idx[i], idx[j]] = [idx[j], idx[i]];
    }
    return idx;
  }

  /**
   * Sets a subset of array elements based on provided indices.
   * @param {Array} A - The target array.
   * @param {number[]} indices - The indices at which to set values.
   * @param {Array} B - The array of values to set.
   */
  setSub(A, indices, B) {
    var j = 0;
    if(!Array.isArray(B)) {
      B = createFilledArray(indices.length, B);
    }
    for(var i = 0; i < indices.length; i++) {
      A[indices[i]] = B[j++];
    }
  }

  /**
   * Sets a subset of array elements based on provided boolean indices.
   * @param {Array} A - The target array to modify.
   * @param {boolean[]} b - A boolean array indicating which elements to set (true = set, false = skip).
   * @param {Array} B - The array of values to set at the indices determined by `b`.
   */
  setSubB(A, b, B) {
    this.setSub(A, b2i(b), B);
  }
  
  /**
   * Retrieves a subset of array elements based on provided indices.
   * @param {Array} A - The source array.
   * @param {number[]} indices - The indices of elements to retrieve.
   * @returns {Array} An array containing the retrieved elements.
   */
  getSub(A, indices) {
    var B = zeros(indices.length);
    var j = 0;
    for(var i = 0; i < indices.length; i++) {
      B[j++] = A[indices[i]];
    }
    return B;
  }
  
  /**
   * Retrieves a subset of array elements based on provided indices.
   * @param {Array} A - The source array.
   * @param {boolean[]} b - A boolean array indicating which elements to retrieve.
   * @returns {Array} An array containing the retrieved elements.
   */
  getSubB(A, b) {
    return this.getSub(A, b2i(b));
  }
  
  /**
   * Moves an element within the array from one index to another.
   * @param {Array} A - The array to modify.
   * @param {number} from_index - The index of the element to move.
   * @param {number} to_index - The target index where the element should be moved.
   * @returns {Array} The modified array with the element moved.
   */
  moveElement(A, from_index, to_index) {
    const start_index = from_index < 0 ? A.length + from_index : from_index;

    if(start_index >= 0 && start_index < A.length) {
      const end_index = to_index < 0 ? A.length + to_index : to_index;

      const [item] = A.splice(from_index, 1);
      A.splice(end_index, 0, item);
    }
    return A;
  }

  /**
   * Removes an element from the array at the specified index.
   * @param {Array} A - The array to modify.
   * @param {number} index - The index of the element to remove.
   * @returns {Array} The array after the element has been removed.
   */
  removeElement(A, index) {
    return A.splice(index, 1);
  }

  /**
   * Removes the first occurrence of a specified value from the array.
   * @param {Array} A - The array to modify.
   * @param {*} value - The value to remove.
   * @returns {Array} The array after the value has been removed.
   */
  removeElementByValue(A, value) {
    var index = A.indexOf(value);
    if(index !== -1) {
      A.splice(index, 1);
    }
    return A;
  }
  
  /**
   * Removes elements from array A that have properties listed in array B.
   * @param {Array<Object>} A - The array to filter.
   * @param {Array} B - The array of properties or values to remove.
   * @param {string} [prop] - The property name to check in objects within A.
   * @returns {Array} The filtered array.
   */
  removeElementProp(A, B, prop) {
    if(prop) {
      return A.filter(function(e) { return !B.includes(e[prop]); });
    } else {
      return A.filter(function(e) { return !B.includes(e); });
    }
  }
  
  /**
   * Finds the index of the first object in the array where the specified property matches the given value.
   * @param {Array<Object>} A - The array to search.
   * @param {string} property - The property name to compare.
   * @param {*} value - The value to match.
   * @returns {number} The index of the matching object, or -1 if not found.
   */
  findIndexProp(A, property, value) {
    return A.findIndex(function(object) {
      return object[property] == value;
    });
  }

  /**
   * Sets a value at the specified multi-dimensional indices in the array.
   * @param {Array} A - The target array.
   * @param {number[]} indices - An array of indices representing the position.
   * @param {*} value - The value to set.
   * @returns {*} The value that was set.
   */
  setValueAt(A, indices, value) {
    var reference = A;
    for(var i = 0; i < indices.length - 1; i++) {
      reference = reference[indices[i]];
    }
    reference[indices[indices.length - 1]] = value;
    return reference;
  }

  /**
   * Retrieves a value from the array at the specified multi-dimensional indices.
   * @param {Array} A - The source array.
   * @param {number[]} indices - An array of indices representing the position.
   * @returns {*} The value at the specified indices, or undefined if out of bounds.
   */
  getValueAt(A, indices) {
    if(Array.isArray(A)) {
      var reference = A;
      for(var i = 0; i < indices.length; i++) {
        if(indices[i] < reference.length) {
          reference = reference[indices[i]];
        } else {
          return undefined;
        }
      }
      return reference;
    } else {
      return undefined;
    }
  }
  
  /**
   * Alias for setValueAt.
   * @param {Array} A - The target array.
   * @param {number[]} indices - An array of indices representing the position.
   * @param {*} value - The value to set.
   * @returns {*} The value that was set.
   */
  setVal(A, indices, value) {
    return this.setValueAt(A, indices, value);
  }
  
  /**
   * Alias for getValueAt.
   * @param {Array} A - The source array.
   * @param {number[]} indices - An array of indices representing the position.
   * @returns {*} The value at the specified indices, or undefined if out of bounds.
   */
  getVal(A, indices) {
    return this.getValueAt(A, indices);
  }
  
  /**
   * Returns the intersection of two arrays.
   * @param {Array} A - First array.
   * @param {Array} B - Second array.
   * @returns {Array} Common elements.
   */
  arrayIntersect(A, B) {
    if (A.length > B.length) [A, B] = [B, A];
    const set_B = new Set(B);
    return [...A.filter(item => set_B.has(item))];
  }
  
  /**
   * Creates a shallow copy of the provided array.
   * @param {Array} A - The array to clone.
   * @returns {Array} A new array containing all elements from A.
   */
  cloneArray(A) {
    return structuredClone(A);
  }
  
  /**
   * Creates an n-dimensional array.
   * @param {number} length - The size of the first dimension.
   * @param {...number} [dimensions] - Sizes of subsequent dimensions.
   * @returns {Array} The newly created n-dimensional array.
   */
  createArray(length) {
    var A = new Array(length || 0);
    var i = length;

    if(arguments.length > 1) {
      var args = Array.prototype.slice.call(arguments, 1);
      while(i--) A[(length-1)-i] = createArray.apply(this, args);
    }

    return A;
  }

  /**
   * Creates an n-dimensional array filled with a specific value.
   * @param {number} length - The size of the first dimension.
   * @param {*} val - The value to fill the array with.
   * @param {...number} [dimensions] - Sizes of subsequent dimensions.
   * @returns {Array} The filled n-dimensional array.
   */
  createFilledArray(length, val) {
    var A = new Array(length || 0);
    var i = length;

    if(arguments.length > 2) {
      var args = Array.prototype.slice.call(arguments, 1);
      while(i--) A[(length-1)-i] = this.createFilledArray.apply(this, args);
    } else {
      A.fill(val);
    }

    return A;
  }
  
  /**
   * Fills the array with a specific value.
   * @param {*} val - The value to fill the array with.
   * @param {Array} A - The array to fill.
   * @param {number} length - The number of elements to fill.
   */
  fill(val, A, length) {
    for(var i = 0; i < length; i++) {
      A[i] = val;
    }
  }
  
  /**
   * Creates an n-dimensional array filled with NaN.
   * @param {...number} size - The size of each dimension.
   * @returns {Array} The NaN-filled n-dimensional array.
   */
  NaNs(...size) {
    return this.createFilledArray(...size, NaN);
  }

  /**
   * Creates an n-dimensional array filled with zeros.
   * @param {...number} size - The size of each dimension.
   * @returns {Array} The zero-filled n-dimensional array.
   */
  zeros(...size) {
    return this.createFilledArray(...size, 0);
  }

  /**
   * Creates an n-dimensional array filled with ones.
   * @param {...number} size - The size of each dimension.
   * @returns {Array} The one-filled n-dimensional array.
   */
  ones(...size) {
    return this.createFilledArray(...size, 1);
  }
  
  /**
   * Creates a 2-dimensional identity matrix.
   * @param {number} size - The size of the identity matrix.
   * @returns {Array} The identity matrix as a 2D array.
   */
  eye(size) {
    return this.diag(this.ones(size), size);
  }
  
  /**
   * Scales an array by a scalar.
   * @param {Array<number>} A - The array to scale.
   * @param {number} s - The scalar value.
   * @returns {Array<number>} The scaled array.
   */
  scale(A, s) {
    var obj = this;
    return A.map(function(x) {
      if(Array.isArray(x)) {
        return obj.scale(x, s);
      } else {
        return x * s;
      }
    });
  }
  
  /**
   * Creates a linearly spaced vector.
   * @param {number} x1 - The start value.
   * @param {number} x2 - The end value.
   * @param {number} [N=100] - The number of points.
   * @returns {Array<number>} The linearly spaced vector.
   */
  linspace(x1, x2, rows = 100) {
    var A = new Array(rows);
    var dx = (x2-x1)/(rows-1);
    for(var i = 0; i < rows; i++) {
      A[i] = x1+dx*i;
    }
    return A;
  }

  /**
   * Generates an array of numbers within a specified range.
   * @param {...*} args - The start, end, and optional step for the range.
   * @returns {Array<number>} An array containing numbers within the specified range.
   */
  range(...args) {
    return [...this.jsl.env.math.range(...args, true).toArray()];
  }
  
  /**
   * Generates a sequence of numbers from `x1` to `x2` with increments of `dx`.
   * @param {number} x1 - The starting value of the sequence.
   * @param {number} x2 - The ending value of the sequence.
   * @param {number} dx - The increment between values in the sequence.
   * @returns {number[]} An array of numbers from `x1` to `x2` with step size `dx`.
   */
  colon(x1, x2, dx) {
    if(dx === 0) {
      this.jsl.env.error('@colon: '+language.string(189));
    }
    const x = [];
    const tolerance = 1e-14; // Tolerance for floating-point comparisons
    let n = 0;
    let xi = x1;
    const increasing = dx > 0;

    while(
      (increasing && xi <= x2 + tolerance) ||
      (!increasing && xi >= x2 - tolerance)
    ) {
      x.push(xi);
      xi = x1 + dx * ++n;
    }

    return x;
  }

  /**
   * Applies a function to corresponding elements of one or more arrays.
   * @param {Function} func - The function to apply to the elements.
   * @param {...Array} arrays - One or more arrays to process.
   * @returns {Array} A new array with the function applied to each corresponding element.
   */
  elementWise(func, ...arrays) {
    // Ensure all arrays have the same length
    const length = arrays[0].length;

    // Initialize the result array
    const result = [];

    // Apply the function element-wise
    for(let i = 0; i < length; i++) {
      // Get the corresponding elements from all arrays
      const values = arrays.map(array => array[i]);

      // Apply the function to the values and store in the result array
      result.push(func(...values));
    }

    return result;
  }
  
  /**
   * Applies a function to each element of an array or matrix along a specified dimension.
   * @param {Array|Matrix} A - The array or matrix to process.
   * @param {number} dim - The dimension along which to apply the function.
   * @param {Function} fun - The function to apply to each element.
   * @returns {Array|Matrix} The result of applying the function to A.
   */
  arrayfun(A, dim, fun) {
    return this.jsl.env.math.apply(A, dim, fun);
  }

  /**
   * Performs element-wise division on two arrays or matrices.
   * @param {Array|Matrix} x - The numerator array or matrix.
   * @param {Array|Matrix} y - The denominator array or matrix.
   * @returns {Array|Matrix} The result of the element-wise division.
   */
  divideEl(x, y) {
    return this.jsl.env.math.dotDivide(x, y);
  }

  /**
   * Performs element-wise multiplication on two arrays or matrices.
   * @param {Array|Matrix} x - The first array or matrix.
   * @param {Array|Matrix} y - The second array or matrix.
   * @returns {Array|Matrix} The result of the element-wise multiplication.
   */
  multiplyEl(x, y) {
    return this.jsl.env.math.dotMultiply(x, y);
  }
  
  /**
   * Raises elements of an array or matrix to the power of elements in another array or matrix, element-wise.
   * @param {Array|Matrix} x - The base array or matrix.
   * @param {Array|Matrix|number} y - The exponent array, matrix, or scalar.
   * @returns {Array|Matrix} The result of the element-wise exponentiation.
   */
  powEl(x, y) {
    return this.jsl.env.math.dotPow(x, y);
  }

  /**
   * Calculates the dot product of two vectors or matrices.
   * @param {number[]} x - The first input vector or flat array.
   * @param {number[]} y - The second input vector or flat array.
   * @param {number} [cols] - Optional number of columns to reshape the inputs into matrices.
   * @returns {number | number[][]} The resulting dot product, either as a scalar or a matrix.
   */
  dot(x, y, cols) {
    if(cols) {
      var rows = x.length/cols;
      var x_in = reshape(transpose(x, cols, rows), cols, rows); 
      var y_in = reshape(transpose(y, cols, rows), cols, rows); 
      return this.elementWise((a, b) => this.jsl.env.math.dot(a, b), x_in, y_in);
    } else {
      return this.jsl.env.math.dot(x, y);
    }
  }
  
  /**
   * Determines if the element is greater than zero.
   * @param {number} e - The element to check.
   * @returns {boolean} True if greater than zero, otherwise false.
   */
  lZero(e) { 
    return e > 0; 
  }
  
  /**
   * Converts a boolean array into an array of indices where the values are `true`.
   * @param {boolean[]} arr - The input array of boolean values.
   * @returns {number[]} An array of indices corresponding to `true` values in the input array.
   */
  b2i(arr) { 
    return arr.map((value, index) => value ? index : -1).filter(index => index !== -1);
  }
  
  /**
   * Calculates the average value of an array.
   * @param {Array<number>} arr - The array to average.
   * @returns {number} The average value.
   */
  average(arr) { 
    return arr.reduce(function(p, c) { 
      return p + c; 
    }, 0) / arr.length;
  }

  /**
   * Calculates the Exponential Moving Average of the data.
   * @param {number[]} data - The data array.
   * @param {number} alpha - The smoothing factor between 0 and 1.
   * @returns {number[]} The Exponential Moving Average of the data.
   */
  averageEM(data, alpha) {
    var result = [];
    var ema = data[0];
    result.push(ema);
    for(var i = 1; i < data.length; i++) {
      ema = alpha * data[i] + (1 - alpha) * ema;
      result.push(ema);
    }
    return result;
  }
  
  /**
   * Applies a moving average filter to an input array while keeping the output array the same size.
   * @param {number[]} inputArray - The array of numbers to filter.
   * @param {number} windowSize - The size of the moving window (number of elements to average).
   * @returns {number[]} The filtered array with the same length as the input array.
   */
  averageMoving(inputArray, windowSize) {
    var result = [];
    var len = inputArray.length;
    var halfWindow = Math.floor(windowSize / 2);

    for(var i = 0; i < len; i++) {
      var start = i - halfWindow;
      var end = i + halfWindow;

      // Adjust the window if it goes beyond the array bounds
      if(start < 0) start = 0;
      if(end >= len) end = len - 1;

      var sum = 0;
      var count = 0;
      for(var j = start; j <= end; j++) {
        sum += inputArray[j];
        count++;
      }
      result.push(sum / count);
    }
    return result;
  }
  
  /**
   * Applies a moving average filter to an input array while keeping the output array the same size.
   * @param {number[]} inputArray - The array of numbers to filter.
   * @param {number} windowSize - The size of the moving window (number of elements to average).
   * @returns {number[]} The filtered array with the same length as the input array.
   */
  movmean(inputArray, windowSize) {
    return this.averageMoving(inputArray, windowSize);
  }
  
  /**
   * Determines if two arrays are equal.
   * @param {Array} A1 - The first array.
   * @param {Array} A2 - The second array.
   * @returns {boolean} True if arrays are equal, otherwise false.
   */
  isequal(A1, A2) {
    let n;
    if((n = A1.length) != A2.length) return false;
    for(let i = 0; i < n; i++) if(A1[i] !== A2[i]) return false;
    return true;
  }

  /**
   * Negates the boolean values in an array.
   * @param {Array<boolean>} A - The array to negate.
   * @returns {Array<boolean>} The negated array.
   */
  neg(A) {
    var B = new Array(A.length);
    for(var i = 0; i < A.length; i++) {
      B[i] = !A[i];
    }
    return B;
  }
  
  /**
   * Determines if all elements in an array evaluate to true.
   * @param {Array<boolean>} A - The array to check.
   * @returns {boolean} True if all elements are true, otherwise false.
   */
  all(A) {
    let n = A.length;
    for(let i = 0; i < n; i++) {
      if(!A[i]) {
        return false;
      }
    }
    return true;
  }
 
  /**
   * Determines if any element in an array evaluates to true.
   * @param {Array<boolean>} A - The array to check.
   * @returns {boolean} True if any element is true, otherwise false.
   */
  any(A) {
    let n = A.length;
    for(let i = 0; i < n; i++) {
      if(A[i]) {
        return true;
      }
    }
    return false;
  }

  /**
   * Checks if the array contains a specified item.
   * @param {Array} arr - The array to search.
   * @param {*} item - The item to search for.
   * @returns {boolean} True if the item is found, otherwise false.
   */
  arrayContains(arr, item) {
    if(!Array.prototype.indexOf) {
      var i = arr.length;
      while(i--) {
        if(arr[i] === item) {
          return true;
        }
      }
      return false;
    }
    return arr.indexOf(item) != -1;
  }
  
  /**
   * Checks if an array contains any duplicate elements.
   * @param {Array} array - The array to check for duplicates.
   * @returns {boolean} True if duplicates are found, false otherwise.
   */
  hasDuplicates(array) {
    return new Set(array).size !== array.length;
  }

  /**
   * Removes duplicate values from an array.
   * @param {Array} arr - The array from which duplicates are to be removed.
   * @returns {Array} An array containing only unique elements from the original array.
   */
  removeDuplicates(arr) {
    return arr.filter(function(item, index) { return arr.indexOf(item) === index; });
  }
  
  /**
   * Reverses the order of elements in each row of a matrix.
   * @param {Array} array - The matrix array to flip horizontally.
   * @returns {Array} The horizontally flipped matrix.
   */
  fliplr(array) {
    return array.reverse();
  }

  /**
   * Moves the first `n` elements of the array to the end.
   * @param {Array} array - The array to be modified.
   * @param {number} n - The number of elements to move from the start to the end.
   * @returns {Array} The modified array with the first `n` elements moved to the end.
   */
  movelr(array, n) {
    var A = [...array];
    if(A.length === 0 || n <= 0) return array;
    n = n % A.length;
    const elements_to_move = A.splice(0, n);
    A.push(...elements_to_move);
    return A;
  }
  
  /**
   * Adds multiple operands, which can be either scalars or arrays.
   * If multiple operands are arrays, they must be of the same length.
   * @param {...number|Array<number>} args - The operands, scalar or arrays.
   * @returns {number|Array<number>} The result of adding all operands.
   * @throws {Error} If input types are invalid or arrays have different lengths.
   */
  plus(...args) {
    if(args.length === 0) {
      this.jsl.env.error('@plus: No arguments provided');
    }

    // Helper function to add two operands
    const addTwo = (a, b) => {
      if(Array.isArray(a) && Array.isArray(b)) {
        if(a.length !== b.length) {
          this.jsl.env.error('@plus: ' + language.string(176)); // Arrays have different lengths
        }
        return a.map((val, idx) => this.plus(val, b[idx]));
      } else if(Array.isArray(a) && typeof b === 'number') {
        return a.map(val => this.plus(val, b));
      } else if(typeof a === 'number' && Array.isArray(b)) {
        return b.map(val => this.plus(a, val));
      } else if(typeof a === 'number' && typeof b === 'number') {
        return a + b;
      } else {
        this.jsl.env.error('@plus: ' + language.string(177)); // Invalid type
      }
      return false;
    };

    // Iterate through all arguments and accumulate the result
    return args.reduce((acc, current) => addTwo(acc, current));
  }

  /**
   * Adds multiple operands, which can be either scalars or arrays.
   * If multiple operands are arrays, they must be of the same length.
   * @param {...number|Array<number>} args - The operands, scalar or arrays.
   * @returns {number|Array<number>} The result of adding all operands.
   * @throws {Error} If input types are invalid or arrays have different lengths.
   */
  add(...args) {
    return this.plus(...args);
  }
  
  /**
   * Subtracts multiple operands from the first one, which can be either scalars or arrays.
   * If multiple operands are arrays, they must be of the same length.
   * @param {...number|Array<number>} args - The operands, scalar or arrays.
   * @returns {number|Array<number>} The result of subtracting all subsequent operands from the first one.
   * @throws {Error} If input types are invalid or arrays have different lengths.
   */
  minus(...args) {
    if(args.length === 0) {
      this.jsl.env.error('@minus: No arguments provided');
    }

    // Helper function to subtract two operands
    const subtractTwo = (a, b) => {
      if(Array.isArray(a) && Array.isArray(b)) {
        if(a.length !== b.length) {
          this.jsl.env.error('@minus: ' + language.string(176)); // Arrays have different lengths
        }
        return a.map((val, idx) => this.minus(val, b[idx]));
      } else if(Array.isArray(a) && typeof b === 'number') {
        return a.map(val => this.minus(val, b));
      } else if(typeof a === 'number' && Array.isArray(b)) {
        // Subtracting an array from a scalar: scalar - array
        return b.map(val => this.minus(a, val));
      } else if(typeof a === 'number' && typeof b === 'number') {
        return a - b;
      } else {
        this.jsl.env.error('@minus: ' + language.string(177)); // Invalid type
      }
      return false;
    };

    // The first argument is the initial value
    let result = args[0];

    // Iterate through the rest of the arguments and subtract each from the result
    for(let i = 1; i < args.length; i++) {
      result = subtractTwo(result, args[i]);
    }

    return result;
  }
  
  /**
   * Subtracts multiple operands from the first one, which can be either scalars or arrays.
   * If multiple operands are arrays, they must be of the same length.
   * @param {...number|Array<number>} args - The operands, scalar or arrays.
   * @returns {number|Array<number>} The result of subtracting all subsequent operands from the first one.
   * @throws {Error} If input types are invalid or arrays have different lengths.
   */
  subtract(...args) {
    return this.minus(...args);
  }
  
  /**
   * Computes the cross product of two 3D vectors.
   * @param {number[]} A - The first 3D vector.
   * @param {number[]} B - The second 3D vector.
   * @param {number} cols - The number of columns (typically 1 for single vectors).
   * @returns {number[]} The cross product vector.
   */
  cross3D(A, B, cols = 1) {
    var C = new Array(3 * cols).fill(0);
    for(var j = 0; j < cols; j++) {
      C[j * 3] = A[j * 3 + 1] * B[j * 3 + 2] - A[j * 3 + 2] * B[j * 3 + 1];
      C[j * 3 + 1] = A[j * 3 + 2] * B[j * 3] - A[j * 3] * B[j * 3 + 2];
      C[j * 3 + 2] = A[j * 3] * B[j * 3 + 1] - A[j * 3 + 1] * B[j * 3];
    }
    return C;
  }
  
  /**
   * Computes the inverse of a matrix represented as a flat array.
   * @param {number[]} A - The input matrix in a flat array format.
   * @param {number} size - The number of rows and columns in the matrix.
   * @returns {number[]|false} The inverted matrix as a flat array, or `false` if the matrix is non-invertible.
   */
  inv(A, size) {
    var A_mat = reshape(A, size, size);    
    try {
      return reshape(this.jsl.env.math.inv(A_mat), size*size, 1);
    } catch {
      return false;
    }
  }

  /**
   * Concatenates multiple matrices row-wise.
   * @param {number} cols_C - The number of columns in the concatenated matrix.
   * @param {...Array} args - The matrices to concatenate.
   * @returns {Array} The concatenated matrix.
   */
  concatRow(cols_C, ...args) {
    var N = args.length;
    var rows_C = args.reduce((a, e) => a += e.length, 0) / cols_C;
    
    var C = new Array(rows_C * cols_C).fill(0);
    
    var p = 0;
    for(var j = 0; j < cols_C; j++) {
      for(var k = 0; k < N; k++) {  
        var P = args[k].length / cols_C;
        for(var i = 0; i < P; i++) {
          C[p++] = args[k][j*P+i];
        }
      }
    }
    return C;
  }

  /**
   * Concatenates multiple matrices column-wise.
   * @param {number} rows_C - The number of rows in the concatenated matrix.
   * @param {...Array} args - The matrices to concatenate.
   * @returns {Array} The concatenated matrix.
   */
  concatCol(rows_C, ...args) {
    return args.flat();
  }

  /**
   * Concatenates multiple vectors.
   * @param {...Array} args - The vectors to concatenate.
   * @returns {Array} The concatenated vector.
   */
  concat(...args) {
    return args.flat();
  }
  
  /**
   * Repeats a row vector multiple times.
   * @param {Array} A - The row vector to repeat.
   * @param {number} rows - The number of times to repeat the row.
   * @returns {Array} The repeated row matrix.
   */
  repRow(A, rows) {
    var cols = A.length;
    var C = new Array(cols * rows).fill(0);
    for(var i = 0; i < cols; i++) {
      for(var j = 0; j < rows; j++) {
        C[i*rows+j] = A[i];
      }
    }
    return C;
  }

  /**
   * Repeats a column vector multiple times.
   * @param {Array} A - The column vector to repeat.
   * @param {number} cols - The number of times to repeat the column.
   * @returns {Array} The repeated column matrix.
   */
  repCol(A, cols) {
    var rows = A.length;
    var C = new Array(cols * rows).fill(0);
    for(var i = 0; i < cols; i++) {
      for(var j = 0; j < rows; j++) {
        C[i*rows+j] = A[j];
      }
    }
    return C;
  }

  /**
   * Sums the elements of each row in a matrix.
   * @param {Array<number>} A - The matrix array.
   * @param {number} rows - The number of rows in the matrix.
   * @param {number} cols - The number of columns in the matrix.
   * @returns {number[]} An array containing the sum of each row.
   */
  sumRow(A, rows, cols) {
    var C = new Array(rows).fill(0);
    for(var i = 0; i < rows; i++) {
      for(var j = 0; j < cols; j++) {
        C[i] += A[i*cols+j];
      }
    }
    return C;
  }
  
  /**
   * Sums the elements of each column in a matrix.
   * @param {Array<number>} A - The matrix array.
   * @param {number} rows - The number of rows in the matrix.
   * @param {number} cols - The number of columns in the matrix.
   * @returns {number[]} An array containing the sum of each column.
   */
  sumCol(A, rows, cols) {
    var C = new Array(cols).fill(0);
    for(var j = 0; j < cols; j++) {
      for(var i = 0; i < rows; i++) {
        C[j] += A[j*rows+i];
      }
    }
    return C;
  }

  /**
   * Calculates the Euclidean norm of each row in a matrix.
   * @param {Array<number>} A - The matrix array.
   * @param {number} rows - The number of rows in the matrix.
   * @param {number} cols - The number of columns in the matrix.
   * @returns {number[]} An array containing the norm of each row.
   */
  normRow(A, rows, cols) {
    var C = new Array(rows).fill(0);
    for(var i = 0; i < rows; i++) {
      for(var j = 0; j < cols; j++) {
        C[i] += Math.pow(A[i*cols+j], 2);
      }
      C[i] = Math.sqrt(C[i]);
    }
    return C;
  }
  
  /**
   * Calculates the Euclidean norm of each column in a matrix.
   * @param {Array<number>} A - The matrix array.
   * @param {number} rows - The number of rows in the matrix.
   * @param {number} cols - The number of columns in the matrix.
   * @returns {number[]} An array containing the norm of each column.
   */
  normCol(A, rows, cols) {
    var C = new Array(cols).fill(0);
    for(var j = 0; j < cols; j++) {
      for(var i = 0; i < rows; i++) {
        C[j] += Math.pow(A[j*rows+i], 2);
      }
      C[j] = Math.sqrt(C[j]);
    }
    return C;
  }

  /**
   * Transposes a matrix.
   * @param {Array<number>} A - The matrix array to transpose.
   * @param {number} rows - The number of rows in the original matrix.
   * @param {number} cols - The number of columns in the original matrix.
   * @returns {Array<number>} The transposed matrix array.
   */
  transpose(A, rows, cols) {
    var C = new Array(rows * cols).fill(0);
    for(var i = 0; i < rows; i++) {
      for(var j = 0; j < cols; j++) {
        C[j * rows + i] = A[i * cols + j];
      }
    }
    return C;
  }
  
  /**
   * Multiplies two matrices.
   * @param {Array<number>} A - The first matrix array.
   * @param {Array<number>} B - The second matrix array.
   * @param {number} rows_A - The number of rows in matrix A.
   * @param {number} cols_A - The number of columns in matrix A.
   * @param {number} cols_B - The number of columns in matrix B.
   * @returns {Array<number>} The resulting matrix array after multiplication.
   */
  multiply(A, B, rows_A, cols_A, cols_B) {
    var C = new Array(rows_A * cols_B).fill(0);
    for(var i = 0; i < rows_A; i++) {
      for(var j = 0; j < cols_A; j++) {
        for(var k = 0; k < cols_B; k++) {
          C[k * rows_A + i] += A[j * rows_A + i] * B[k * cols_A + j];
        }
      }
    }
    return C;
  }

  /**
   * Performs element-wise dot product on columns of two matrices.
   * @param {Array<number>} A - The first matrix array.
   * @param {Array<number>} B - The second matrix array.
   * @param {number} rows - The number of rows in each matrix.
   * @param {number} cols - The number of columns in each matrix.
   * @returns {Array<number>} An array containing the dot product of each column.
   */
  dotColumn(A, B, rows, cols) {
    var C = new Array(cols).fill(0);
    for(var j = 0; j < cols; j++) {
      for(var i = 0; i < rows; i++) {
        C[j] += A[j * rows + i] * B[j * rows + i];
      }
    }
    return C;
  }

  /**
   * Creates a diagonal matrix from a given array.
   * @param {number[]} A - The array to form the diagonal.
   * @param {number} length - The size of the square matrix.
   * @returns {Array<number>} The diagonal matrix as a 1D array.
   */
  diag(A, length) {
    var B = new Array(length*length).fill(0);
    for(var i = 0; i < length; i++) {
      B[i * length + i] = A[i];
    }
    return B;
  }
  
  /**
   * Solves a linear system of equations using LU decomposition.
   * @param {Array<number>} A - The coefficient matrix.
   * @param {Array<number>} B - The constant terms.
   * @param {number} N - The size of the matrix (NxN).
   * @returns {Array<number>} The solution vector.
   */
  linsolve(A, B, N) {
    return this.reshape(this.jsl.env.math.lusolve(this.reshape(A, N, N), B), 1, N);
  }
  
  /**
   * Computes the reciprocal of each element in the array.
   * @param {Array<number>} A - The array of numbers.
   * @param {number} length - The number of elements in the array.
   * @returns {Array<number>} An array containing the reciprocals of the original elements.
   */
  reciprocal(A, length) {
    var B = new Array(length).fill(0);
    for(var i = 0; i < length; i++) {
      B[i] = 1 / A[i];
    }
    return B;
  }

  /**
   * Reshapes an array into a new dimension.
   * @param {Array} A - The array to reshape.
   * @param {number} rows - The number of rows in the new shape.
   * @param {number} cols - The number of columns in the new shape.
   * @returns {Array} The reshaped array.
   * @throws {Error} If the total number of elements does not match.
   */
  reshape(A, rows, cols) {
    if(rows == _) {
      rows = A.length / cols;
    }
    if(cols == _) {
      cols = A.length / rows;
    }
    let flat_arr = [];

    if(Array.isArray(A[0])) {
      var numRows = A.length;
      var numCols = A[0].length;

      for(let j = 0; j < numCols; j++) {
        for(let i = 0; i < numRows; i++) {
          flat_arr.push(A[i][j]);
        }
      }
    } else {
      flat_arr = A.slice();
    }

    if(flat_arr.length !== rows * cols) {
      this.jsl.env.error('@reshape: '+language.string(178));
    }

    var reshaped = Array.from({ length: rows }, () => Array(cols));

    for(let j = 0; j < cols; j++) {
      for(let i = 0; i < rows; i++) {
        var index = j * rows + i;
        reshaped[i][j] = flat_arr[index];
      }
    }

    if(rows == 1 || cols == 1) {
      reshaped = reshaped.flat();
    }
    return reshaped;
  }

  /**
   * Finds the maximum element in the array and its index, excluding NaN values.
   * @param {number[]} A - The array to search.
   * @returns {Array} An array containing the max value and its index.
   * @throws {TypeError} If the input is not an array.
   * @throws {Error} If the array is empty or only contains NaN values.
   */
  maxi(A) {
    if(!Array.isArray(A)) {
      this.jsl.env.error('@maxi: '+language.string(190));
    }

    const filtered_A = A.filter(num => !isNaN(num));
    if(filtered_A.length === 0) {
      this.jsl.env.error('@maxi: '+language.string(191));
    }

    let max = filtered_A[0];
    let index = A.indexOf(max);

    for(let i = 1; i < A.length; i++) {
      const current = A[i];
      if(!isNaN(current) && current > max) {
        max = current;
        index = i;
      }
    }

    return [max, index];
  }

  /**
   * Finds the minimum element in the array and its index, excluding NaN values.
   * @param {number[]} A - The array to search.
   * @returns {Array} An array containing the min value and its index.
   * @throws {TypeError} If the input is not an array.
   * @throws {Error} If the array is empty or only contains NaN values.
   */
  mini(A) {
    if(!Array.isArray(A)) {
      this.jsl.env.error('@mini: '+language.string(190));
    }

    const filtered_A = A.filter(num => !isNaN(num));
    if(filtered_A.length === 0) {
      this.jsl.env.error('@mini: '+language.string(191));
    }

    let min = filtered_A[0];
    let index = A.indexOf(min);

    for(let i = 1; i < A.length; i++) {
      const current = A[i];
      if(!isNaN(current) && current < min) {
        min = current;
        index = i;
      }
    }

    return [min, index];
  }

  /**
   * Sorts the array in ascending order with indices, excluding NaN values.
   * @param {number[]} A - The array to sort.
   * @returns {Array} An array containing the sorted values and their original indices.
   * @throws {TypeError} If the input is not an array.
   */
  sorti(A) {
    if(!Array.isArray(A)) {
      this.jsl.env.error('@sorti: '+language.string(190));
    }

    // Create an array of indices and sort based on values in A,
    // with NaNs sorted to the end.
    const indices = A.map((_, idx) => idx);
    indices.sort((i, j) => {
      if(isNaN(A[i]) && isNaN(A[j])) return 0;
      if(isNaN(A[i])) return 1;
      if(isNaN(A[j])) return -1;
      return A[i] - A[j];
    });

    // Map the sorted indices to the sorted values
    const sorted_scores = indices.map(i => A[i]);
    return [sorted_scores, indices];
  }

  /**
   * Computes the weighted sum of two vectors and stores the result in the `ret` array.
   * @param {number[]} ret - The array to store the result.
   * @param {number} w1 - Weight for the first vector.
   * @param {number[]} v1 - The first vector.
   * @param {number} w2 - Weight for the second vector.
   * @param {number[]} v2 - The second vector.
   */
  weightedSum(ret, w1, v1, w2, v2) {
    for(let j = 0; j < ret.length; ++j) {
      ret[j] = w1 * v1[j] + w2 * v2[j];
    }
  }

  /**
   * Computes the consecutive differences of elements in an array.
   * @param {number[]} A - The input array of numbers.
   * @returns {number[]} An array containing the differences between consecutive elements of the input array.
   */
  condiff(A) {
    return A.slice(1).map((num, i) => num - A[i]);
  }
  
  /**
   * Generates an array with random floating-point numbers within a specified range.
   * @param {number} l - The lower bound of the range.
   * @param {number} u - The upper bound of the range.
   * @param {number} rows - The number of rows.
   * @param {number} cols - The number of columns.
   * @param {Function} [randFun=Math.random] - The random function to use.
   * @returns {Array<number>} An array filled with random numbers within the specified range.
   */
  arrayRand(l, u, rows, cols, randFun) {
    if(!this.jsl.format.isFunction(randFun)) {
      randFun = Math.random;
    }
    return this.plus(this.repCol(l, cols), this.multiplyEl(repCol(minus(u, l), cols), Array.from({ length: rows * cols }, () => randFun())));
  }
  
  /**
   * Generates an array with random integer numbers within a specified range.
   * @param {number[]} lu - An array containing the lower and upper bounds [lower, upper].
   * @param {number} rows - The number of rows.
   * @param {number} cols - The number of columns.
   * @param {Function} [randFun=Math.random] - The random function to use.
   * @returns {Array<number>} An array filled with random integers within the specified range.
   */
  arrayRandi(lu, rows, cols, randFun) {
    if(!this.jsl.format.isFunction(randFun)) {
      randFun = Math.random;
    }
    return Array.from({ length: rows * cols }, () => Math.floor(randFun() * (lu[1] - lu[0] + 1) + lu[0]));
  }
  
  /**
   * Normalizes a 3D vector.
   * @param {number[]} v - The vector to normalize.
   * @returns {number[]} The normalized vector.
   */
  normalizeVector(v) {
    var len = this.jsl.env.math.norm(v);
    if(len === 0) return [0, 0, 0];
    return [v[0]/len, v[1]/len, v[2]/len];
  }

  /**
   * Computes the dot product of two 3D vectors.
   * @param {number[]} a - The first vector.
   * @param {number[]} b - The second vector.
   * @returns {number} The dot product of the vectors.
   */
  dotVector(a, b) {
    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
  }

  /**
   * Calculates the angle between two vectors.
   * @param {number[]} a - The first vector.
   * @param {number[]} b - The second vector.
   * @returns {number} The angle in radians between vectors a and b.
   */
  angleVectors(a, b) {
    return acos(dotVector(a, b)/(norm(a)*norm(b))); 
  }
  
  /**
   * Creates a skew-symmetric matrix from a 3D vector.
   * @param {number[]} v - The vector to skew.
   * @returns {number[]} The skew-symmetric matrix as a 1D array.
   */
  skewVector(v) {
    return [
      0, v[2], -v[1],
      -v[2], 0, v[0],
      v[1], -v[0], 0
    ];
  }

  /**
   * Generates coordinate matrices from coordinate vectors for N dimensions.
   * @param {...number[]} args - The coordinate vectors.
   * @returns {Array} The coordinate grids for each dimension.
   */
  meshgrid(...args) {
    var obj = this;
    const ndim = args.length;
    const sizes = args.map(a => a.length);
    const grids = [];

    // Initialize the grids with N-dimensional arrays
    for(let k = 0; k < ndim; k++) {
      grids[k] = this.createArray(...sizes);
    }

    // Recursive function to fill in the grids
    function fillGrid(indices, dim) {
      if(dim === ndim) {
        for(let k = 0; k < ndim; k++) {
          obj.setValueAt(grids[k], indices, args[k][indices[(k + 1) % ndim]]);
        }
      } else {
        for(let i = 0; i < sizes[dim]; i++) {
          indices[dim] = i;
          fillGrid(indices, dim + 1);
        }
      }
    }

    fillGrid(new Array(ndim), 0);

    return grids;
  }

  /**
   * Determines if two arrays are equal by comparing each element.
   * @param {Array} A1 - The first array to compare.
   * @param {Array} A2 - The second array to compare.
   * @returns {boolean} True if the arrays are equal, otherwise false.
   */
  areEqual(A1, A2) {
    let n;
    if((n = A1.length) != A2.length) return false;
    for(let i = 0; i < n; i++) if(A1[i] !== A2[i]) return false;
    return true;
  }

  /**
   * Displays a matrix with a variable name.
   * @param {string} varname - The name of the variable.
   * @param {number[]} A - The matrix array.
   * @param {number} rows - The number of rows in the matrix.
   * @param {number} cols - The number of columns in the matrix.
   * @returns {string} The string representation of the matrix.
   */
  dispMatrix(varname, A, rows, cols) {
    var str = ' ' + varname + ' = [\n';
    for(var i = 0; i < rows; i++) {
      str += '  ';
      for(var j = 0; j < cols; j++) {
        str += num2str(A[j * rows + i], 8) + ' ';
      }
      str += '\n';
    }
    str += ' ]';
    this.jsl.env.disp(str);
    return str+"\n";
  }

  /**
   * Displays a row vector with a variable name.
   * @param {string} varname - The name of the variable.
   * @param {number[]} A - The row vector array.
   * @param {number} length - The length of the row vector.
   * @returns {string} The string representation of the row vector.
   */
  dispRowVector(varname, A, length) {
    var str = ' ' + varname + ' = [ ';
    for(var i = 0; i < length; i++) {
      str += num2str(A[i], 8) + ' ';
    }
    str += ']';
    this.jsl.env.disp(str);
    return str+"\n";
  }

  /**
   * Displays a column vector with a variable name.
   * @param {string} varname - The name of the variable.
   * @param {number[]} A - The column vector array.
   * @param {number} length - The length of the column vector.
   * @returns {string} The string representation of the column vector.
   */
  dispColumnVector(varname, A, length) {
    var str = ' ' + varname + ' = [\n';
    for(var j = 0; j < length; j++) {
      str += '  ' + num2str(A[j], 8) + '\n';
    }
    str += ' ]';
    this.jsl.env.disp(str);
    return str+"\n";
  }
}

exports.PRDC_JSLAB_LIB_ARRAY = PRDC_JSLAB_LIB_ARRAY;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={basic.js}]
/**
 * @file JSLAB library basic submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB basic submodule.
 */
class PRDC_JSLAB_LIB_BASIC {
  
  /**
   * Initializes a new instance of the PRDC_JSLAB_LIB_BASIC class.
   * @param {Object} jsl The JSLAB application instance this submodule is part of.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;

    this._docs = JSON.parse(this.jsl.env.readFileSync(app_path + '/docs/documentation.json', 'utf8'));
    
    /**
     * Stores the result of the last evaluated expression.
     * @type {any}
     */
    this.ans;
    
    /**
     * Clears all defined variables in the current context.
     * @name clear
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'clear', { configurable: true, get: this._clear });

    /**
     * Clears the console screen.
     * @name clc
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'clc', { configurable: true, get: this._clc });

    /**
     * Clears the console screen. Alias for `clc`.
     * @name cls
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'cls', { configurable: true, get: this._clc });

    /**
     * Returns the current version of the JSLAB.
     * @name version
     * @kind member
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'version', { configurable: true, get: this._version });

    /**
     * Returns the platform on which JSLAB is running.
     * @name platform
     * @kind member
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'platform', { configurable: true, get: this._platform });

    /**
     * Returns the file name of the current JSLAB script.
     * @name jsl_file_name
     * @kind member
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'jsl_file_name', { configurable: true, get: this.jslFileName });

    /**
     * Provides information about the current environment.
     * @name info
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'info', { configurable: true, get: this._info });

    /**
     * Accesses or modifies the user settings for JSLAB.
     * @name settings
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'settings', { configurable: true, get: this._settings });

    /**
     * Provides help information for JSLAB commands.
     * @name cmd_help
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'cmd_help', { configurable: true, get: this._cmd_help });

    /**
     * Accesses the code editor interface within JSLAB.
     * @name editor
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'editor', { configurable: true, get: this._editor });

    /**
     * Returns the current working directory.
     * @name pwd
     * @kind member
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'pwd', { configurable: true, get: this._pwd });

    /**
     * Sets a breakpoint in the code for debugging.
     * @name breakpoint
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'breakpoint', { configurable: true, get: this._breakpoint });

    /**
     * Returns the current debug flag status.
     * @name debug_flag
     * @kind member
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'debug_flag', { configurable: true, get: this._debug_flag });

    /**
     * Enables or disables debug mode.
     * @name debug
     * @kind member
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'debug', { configurable: true, get: this._debug });

    /**
     * Pauses the execution of the current script.
     * @name pause
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'pause', { configurable: true, get: this._pause });

    /**
     * Sets a stop point in the script execution.
     * @name stoppoint
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'stoppoint', { configurable: true, get: this._stoppoint });

    /**
     * Sets a log point to record information during execution.
     * @name logpoint
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'logpoint', { configurable: true, get: this._logpoint });

    /**
     * Updates specific points in the script during execution.
     * @name updatepoint
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'updatepoint', { configurable: true, get: this._updatepoint });

    /**
     * Checks if the execution should stop based on conditions.
     * @name checkStop
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'checkStop', { configurable: true, get: this._checkStop });

    /**
     * Marks the endpoint of a script or process.
     * @name endPoint
     * @kind function
     * @memberof PRDC_JSLAB_LIB_BASIC
     */
    Object.defineProperty(this.jsl.context, 'endPoint', { configurable: true, get: this._endPoint });
  }

  /**
   * Runs a script from a specified path, optionally focusing on specific lines and controlling output visibility.
   * @param {string} script_path The path to the script to run.
   * @param {Array<number>} lines An array of line numbers to run or focus on within the script.
   * @param {boolean} [silent=false] Whether to suppress output from the script execution.
   * @param {Boolean} [force_run=false] If true, forces the script to run even if stop conditions are met.
   */
  async run(script_path, lines, silent = false, force_run = false) {
    if(this.jsl.env.pathIsAbsolute(script_path)) {
      this.jsl.last_script_path = script_path;
      this.jsl.last_script_lines = lines;
      this.jsl.last_script_silent = silent;
      if(!force_run && this.jsl.env.checkScriptDir(script_path)) {
        return;
      }
    }
    return await this.jsl.eval.runScript(script_path, lines, silent, force_run);
  }
  
  /**
   * Retrieves documentation in JSON format based on the provided name and type.
   * @param {string} [name] - The name of the documentation item.
   * @param {string} [type] - The type of the documentation (e.g., 'category').
   * @returns {string|undefined} The JSON string of the documentation or undefined if not found.
   */
  helpToJSON(name, type) {
    if(!name) {
      return this.jsl.setDepthSafeStringify(this._docs, 4);
    }
    
    const parts = name.split(".");
    if(parts.length === 2) {
      const [libName, itemName] = parts;
      const data = this._docs.lib[libName];
      if(data.hasOwnProperty(itemName)) {
        const result = data[itemName];
        if(result) {
          result.type = 'lib';
          result.category = libName;
          return this.jsl.setDepthSafeStringify(result, Infinity);
        }
      }
    } else {
      if(type == 'category') {
        for(const category in this._docs) {
          const categoryData = this._docs[category];
          if(categoryData.hasOwnProperty(name)) {
            return this.jsl.setDepthSafeStringify(categoryData[name], 4);
          }
        }
      } else {
        for(const category in this._docs.global) {
          const categoryData = this._docs.global[category];
          if(categoryData.hasOwnProperty(name)) {
            const result = categoryData[name];
            if(result) {
              result.type = 'global';
              result.category = category;
              return this.jsl.setDepthSafeStringify(result, Infinity);
            }
          }
        }
      }
    }
    this.jsl.env.error('@help: ' + language.string(218) + name);
  }
  
  /**
   * Retrieves documentation based on the provided name and type.
   * @param {string} name - The name of the documentation item.
   * @param {string} type - The type of the documentation.
   * @returns {string|undefined} The JSON string of the documentation or undefined if not found.
   */
  help(name, type) {
    return this.helpToJSON(name, type);
  }
  
  /**
   * Retrieves documentation based on the provided name and type.
   * @param {string} name - The name of the documentation item.
   * @param {string} type - The type of the documentation.
   * @returns {string|undefined} The JSON string of the documentation or undefined if not found.
   */
  doc(name, type) {
    return this.help(name, type);
  }
  
  /**
   * Retrieves documentation based on the provided name and type.
   * @param {string} name - The name of the documentation item.
   * @param {string} type - The type of the documentation.
   * @returns {string|undefined} The JSON string of the documentation or undefined if not found.
   */
  documentation(name, type) {
    return this.help(name, type);
  }
  
  /**
   * Searches the documentation for methods that match all words in the given query, regardless of order.
   * @param {string} query - The search query containing keywords to match within the documentation.
   * @returns {Array<Object>} Array of matching documentation entries, each entry containing `type` and `category` properties.
   */
  helpSearch(query) {
    var obj = this;
    var query_words = query.toLowerCase().split(' ');
    var results = {};
    Object.keys(this._docs).forEach(function(type) {
      Object.keys(obj._docs[type]).forEach(function(category) {
        Object.keys(obj._docs[type][category]).forEach(function(member) {
          var member_obj = obj._docs[type][category][member];
          var str = JSON.stringify(member_obj).toLowerCase();
          var match = query_words.every((word) => str.includes(word));
          if(match) {
            member_obj.type = type;
            member_obj.category = category;
            results[member] = member_obj;
          }
        });
      });
    });
    return results;
  }
  
  /**
   * Searches the documentation for methods that match all words in the given query, regardless of order.
   * @param {string} query - The search query containing keywords to match within the documentation.
   * @returns {Array<Object>} Array of matching documentation entries, each entry containing `type` and `category` properties.
   */
  docSearch(query) {
    return this.helpSearch(query);
  }
  
  /**
   * Searches the documentation for methods that match all words in the given query, regardless of order.
   * @param {string} query - The search query containing keywords to match within the documentation.
   * @returns {Array<Object>} Array of matching documentation entries, each entry containing `type` and `category` properties.
   */
  documentationSearch(query) {
    return this.helpSearch(query);
  }
  
  /**
   * Opens the source file and navigates to the specified line based on the provided name.
   * @param {string} name - The name of the source to locate.
   */
  source(name) {
    const parts = name.split(".");
    if(parts.length === 2) {
      const [libName, itemName] = parts;
      const data = this._docs.lib[libName];
      if(data.hasOwnProperty(itemName)) {
        const result = data[itemName];
        if(result) {
          this.jsl.env.editor(app_path + '/js/sandbox/' + result.source_filename, result.source_lineno);
          return;
        }
      }
    } else {
      for(const category in this._docs.global) {
        const categoryData = this._docs.global[category];
        if(categoryData.hasOwnProperty(name)) {
          const result = categoryData[name];
          if(result) {
            this.jsl.env.editor(app_path + '/js/sandbox/' + result.source_filename, result.source_lineno);
            return;
          }
        }
      }
    }
    this.jsl.env.error('@source: ' + language.string(220) + name);
  }

  /**
   * Showing graph of function.
   * @param {string} name - The name of the function.
   */
  async docGraph(name) {
    var obj = this;
    function _docGraph(name) {
      var result;
      const parts = name.split(".");
      if(parts.length === 2) {
        const [libName, itemName] = parts;
        const data = obj._docs.lib[libName];
        if(data.hasOwnProperty(itemName)) {
          result = data[itemName];
        }
      } else {
        for(const category in obj._docs.global) {
          const categoryData = obj._docs.global[category];
          if(categoryData.hasOwnProperty(name)) {
            result = categoryData[name];
          }
        }
      }
      
      var source;
      var called = new Set();
      if(result) {
        if(result.source_range && result.kind == 'function') {
          source = obj.jsl.file_system.getContentFromCharRange(
            app_path + '/js/sandbox/' + result.source_filename, result.source_range);
            
          var ast = obj.jsl.env.recast.parse('function ' + source, {
            parser: {
              parse(src) {
                return obj.jsl.env.babel_parser.parse(src, {
                  sourceType: 'module',
                  allowReturnOutsideFunction: true,
                  plugins: [
                    'jsx',
                    'typescript',
                    'classProperties',
                    'dynamicImport',
                    'optionalChaining',
                    'nullishCoalescingOperator',
                  ],
                });
              },
            },
          });

          obj.jsl.env.recast.visit(ast, {
            visitCallExpression(path) {
              var { callee } = path.node;
              var name;

              if(callee.type === 'Identifier') {
                name = callee.name;
              } else if(
                callee.type === 'MemberExpression' &&
                callee.property.type === 'Identifier'
              ) {
                name = callee.property.name;
              }

              if(name) called.add(name);
              this.traverse(path);
            },
          });
        }

        var lines = [`graph TD`, `  root["${name}"]`];
        var id = 0;
        for(var fn of called) {
          id = id + 1;
          lines.push(`  root --> id${id}["${fn}"]`);
        }
        return lines.join('\n');
      }
      obj.jsl.env.error('@docGraph: ' + language.string(218) + name);
      return false;
    }
    
    var graph = _docGraph(name);
    if(graph) {
      var graph_win = await this.jsl.windows.showMermaidGraph(graph);
      graph_win.document.custom_style.textContent += '.node { cursor: pointer; }';
      graph_win.document.addEventListener('click', async (e) => {
        var node = e.target.closest('.node');
        if(!node) return;
        const labelEl = node.querySelector('.nodeLabel');
        if(!labelEl) return;
        const new_graph = _docGraph(labelEl.textContent.trim());
        if(new_graph) await graph_win.showGraph(new_graph);
      });
    }
  }
  
  /**
   * Retrieves the file name of the currently active JSL script.
   * @returns {string} The file name of the JSL script.
   */
  jslFileName() {
    return this.jsl.jsl_file_name;
  }

  /**
   * Clears the application's local storage.
   */
  clearStorage() {
    return this.jsl.env.clearStorage();
  }

  /**
   * Saves a path to the application's list of saved paths.
   * @param {string} new_path The path to save.
   */
  savePath(new_path) {
    new_path = this.jsl.env.addPathSep(new_path);
    var i = this.jsl.saved_paths.indexOf(new_path);
    if(i < 0) {
      this.jsl.saved_paths.push(new_path);
    }
    this.jsl.env.savePath(new_path);
  }

  /**
   * Removes a previously saved path from the application's list of saved paths.
   * @param {string} saved_path The path to remove.
   */
  removePath(saved_path) {
    saved_path = this.jsl.env.addPathSep(saved_path);
    var i = this.jsl.saved_paths.indexOf(saved_path);
    if(i >= 0) {
      this.jsl.saved_paths.splice(i, 1);
    }
    this.jsl.env.removePath(saved_path);
  }

  /**
   * Opens the help documentation for CMD window.
   */
  _cmd_help() {
    this.jsl.env.cmd_help();
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Displays application info.
   */
  _info() {
    this.jsl.env.info();
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Opens the settings menu.
   */
  _settings() {
    this.jsl.env.settings();
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Retrieves the current working directory.
   * @returns {string} The current working directory.
   */
  _pwd() {
    return this.jsl.current_path;
  }

  /**
   * Changes the current working directory to the specified path.
   * @param {string} new_path The new path to set as the current working directory.
   */
  cd(new_path) {
    this.jsl.setPath(new_path);
    this.jsl.env.cd(new_path);
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Lists the contents of the current directory.
   * @returns {Array<string>} An array of filenames in the current directory.
   */
  _ls() {
    return this.jsl.env.listFolderContents();
  }

  /**
   * Retrieves the application version.
   * @returns {string} The application version.
   */
  _version() {
    return this.jsl.env.version;
  }
  
  /**
   * Retrieves the operating system platform.
   * @returns {string} The OS platform.
   */
  _platform() {
    return this.jsl.env.platform;
  }
  
  /**
   * Retrieves if the JSLAB application is currently in debug mode.
   * @returns {boolean} True if the application is in debug mode; otherwise, false.
   */
  _debug_flag() {
    return this.jsl.env.debug;
  }
  
  /**
   * Retrieves the current workspace.
   * @returns {Object} The current workspace object.
   */
  workspace() {
    return this.jsl.getWorkspace();
  }

  /**
   * Updates the workspace display based on the current state.
   */
  updateWorkspace() {
    this.jsl.env.updateWorkspace();
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Updates the file browser display based on the current state.
   */
  updateFileBrowser() {
    this.jsl.env.updateFileBrowser();
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Clears the workspace.
   */
  _clear() {
    this.jsl.clear();
  }

  /**
   * Clears the command window.
   */
  _clc() {
    this.jsl.env.clc();
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Displays an error message.
   * @param {string} msg The error message to display.
   */
  error(msg) {
    this.jsl.env.error(msg);
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Displays a general message.
   * @param {string} msg The message to display.
   */
  disp(msg) {
    this.jsl.env.disp(msg);
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
    return msg+"\n";
  }

  /**
   * Displays a general message with monospaced font.
   * @param {string} msg The message to display.
   */
  dispMonospaced(msg) {
    this.jsl.env.dispMonospaced(msg);
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
    return msg+"\n";
  }
  
  /**
   * Displays a warning message.
   * @param {string} msg The warning message to display.
   */
  warn(msg) {
    this.jsl.env.warn(msg);
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Opens a specified file in the editor or just opens the editor if no file is specified.
   * @param {string} [filepath] The path to the file to open in the editor.
   */
  _editor(filepath) {
    this.jsl.env.editor(filepath);
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Logs a point in the script for debugging purposes.
   */
  _logpoint() {
    this.jsl.env.setWorkspace();
    this.checkStopLoop();
    this.jsl.onStopLoop();
  }

  /**
   * Updates the workspace or environment at a specific point during script execution.
   */
  _updatepoint() {
    this._logpoint();
  } 

  /**
   * Checks whether script execution should be stopped at the current point.
   */
  _checkStop() {
    this._logpoint();
  }
  
  /**
   * Introduces a breakpoint in the script, pausing execution and potentially allowing the user to continue based on their input.
   */
  _breakpoint() {
    this._logpoint();
    
    var [line, column, script] = this.jsl.eval.getExpressionPosition();
    var ret = this.jsl.env.showMessageBox({title: language.currentString(15), message: language.currentString(216)+': '+line+', '+language.currentString(113)+': '+column+' ('+script+'). '+language.currentString(213), buttons: [language.currentString(214), language.currentString(215)], cancelId: 0});
    if(ret == 1) {
      this.jsl.stop_loop = true;
      this.jsl.onStopLoop();
    }
  }
  
  /**
   * Introduces a breakpoint in the script, pausing execution and potentially allowing the user to continue based on their input.
   */
  _debug() {
    this._breakpoint();
  }

  /**
   * Pauses script execution, providing an opportunity to inspect the current state or continue execution based on user input.
   */
  _pause() {
    this._logpoint();
    
    var [line, column, script] = this.jsl.eval.getExpressionPosition();
    var ret = this.jsl.env.showMessageBox({title: language.currentString(15), message: language.currentString(217)+': '+line+', '+language.currentString(113)+': '+column+' ('+script+'). '+language.currentString(213), buttons: [language.currentString(214), language.currentString(215)], cancelId: 0});
    
    if(ret == 1) {
      this.jsl.stop_loop = true;
      this.jsl.onStopLoop();
    }
  }
  
  /**
   * Forces the script execution to stop at a designated point.
   */
  _stoppoint() {
    this.jsl.stop_loop = true;
    this.jsl.onStopLoop();
  }
  
  /**
   * Marks an endpoint in the script, throwing an error to signify a critical stop or exit point in execution.
   */
  _endPoint() {
    var [line, column, script] = this.jsl.eval.getExpressionPosition();
    throw {name: 'JslabError', message: language.string(116)+': '+line+', '+language.string(113)+': '+column+' ('+script+').'};
  }
  
  /**
   * Verifies if a loop within the script execution should be terminated, typically used to avoid infinite or lengthy unnecessary execution.
   */
  checkStopLoop() {
    if(!this.jsl.stop_loop) {
      this.jsl.stop_loop = this.jsl.env.checkStopLoop();
    }
    return this.jsl.stop_loop;
  }
  
  /**
   * Opens a specified file in an editor or opens the editor to a default or previously specified file.
   * @param {string} [filepath] - Path to the file to be opened in the editor.
   */
  edit(filepath) {
    _editor(filepath);
  }

  /**
   * Returns a list of all example scripts available within a predefined directory.
   * @return {Array<string>} An array of paths to the example scripts.
   */
  getExamples() {
    var obj = this;
    return this.jsl.env.readDir(app_path + '/examples')
        .filter(function(file) { return file.match(new RegExp('\.jsl

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document})); }).map(function(i) { return folder + '\\' + i; });
  }

  /**
   * Opens a specified example script in the editor window.
   * @param {string} filename - Name of the example file to open.
   */
  openExample(filename) {
    if(!this.jsl.env.pathIsAbsolute(filename)) {
      filename = app_path + '\\examples\\' + filename;
    }
    this.edit(filename);
  }

  /**
   * Opens examples folder in File Explorer
   */
  openExamplesFolder() {
    this.jsl.env.openFolder(app_path + '\\examples');
  }

  /**
   * Opens examples folder in File Explorer
   */
  goToExamplesFolder() {
    this.jsl.env.cd(app_path + '\\examples');
  }
  
  /**
   * Displays a synchronous message box to the user and waits for their response.
   * @param {Object} options - Configuration options for the message box.
   * @return {number} The index of the button clicked by the user.
   */
  showMessageBox(options) {
    return this.jsl.env.showMessageBox(options);
  }

  /**
   * Saves specified variables to a JSON file.
   * @param {string} file_path - Path where the JSON file will be saved.
   * @param {...string} args - Variables to save. If 'all' is specified, saves all available variables.
   */
  save(file_path, ...args) {
    var obj = this;
    var vars = {};
    if(args.length == 0 || (args.length == 1 && args[0] == 'all')) {
      var properties = this.jsl.getWorkspaceProperties();
      properties.forEach(function(property) {
        vars[property] = obj.jsl.context[property];
      });
    } else {
      args.forEach(function(property) {
        if(obj.jsl.context.hasOwnProperty(property)) {
          vars[property] = obj.jsl.context[property];
        }
      });
    }
    if(!this.jsl.env.pathIsAbsolute(file_path)) {
      file_path = this.jsl.env.pathJoin(this.jsl.current_path, file_path);
    }
    var flag = this.jsl.env.writeFileSync(file_path, JSON.stringify(vars));
    if(flag === false) {
      this.jsl.env.error('@save: '+language.string(117)+': ' + file_path);
    }
  }

  /**
   * Loads variables from a specified JSON file into the specified scope or the default script context.
   * If an error occurs during file reading or parsing, it logs an error message.
   * @param {...*} args - A single filename or a scope and filename to specify where to load the variables.
   */
  load(...args) {
    var obj = this;
    var scope = obj.jsl.context;
    var file_path;
    if(args.length > 1) {
      scope = args[0];
      file_path = args[1];
    } else {
      file_path = args[0];
    }
    
    file_path = this.jsl.pathResolve(file_path);
    if(file_path) {
      try {
        var vars = JSON.parse(readFile(file_path));
        Object.keys(vars).forEach(function(property) {
          scope[property] = vars[property];
        });
      } catch(err) {
        this.jsl.env.error('@load: '+language.string(118)+'.');
      }
    }
  }

  /**
   * Executes a system shell command.
   * @param {...*} arg - The command and its arguments to be executed.
   * @return {string} The output of the executed command.
   */
  system(...arg) {
    try {
      return this.jsl.env.execSync(...arg).toString();
    } catch(err) {
      return err.message + ', command output: \n' + err.stdout.toString();
    }
  }

  /**
   * Retrieves completion suggestions based on the current context and input.
   * @param {Array} data - Data containing the start of the string to complete, context, and keywords.
   * @return {Array<string>} An array of completion suggestions.
   */
  getCompletions(data) {
    var start = data[0];
    var context = data[1];
    var keywords = data[2];  
    var found = [], global = window;
    
    function maybeAdd(str) {
      if(str.lastIndexOf(start, 0) == 0 && !arrayContains(found, str)) found.push(str);
    }
    function gatherCompletions(obj) {
      if(typeof obj == "string") forEach(("charAt charCodeAt indexOf lastIndexOf substring substr slice trim trimLeft trimRight " +
                     "toUpperCase toLowerCase split concat match replace search").split(" "), maybeAdd);
      else if(obj instanceof Array) forEach(("length concat join splice push pop shift unshift slice reverse sort indexOf " +
                    "lastIndexOf every some filter forEach map reduce reduceRight ").split(" "), maybeAdd);
      else if(obj instanceof Function) forEach("prototype apply call bind".split(" "), maybeAdd);
      if(!Object.getOwnPropertyNames || !Object.getPrototypeOf) {
        for(var name in obj) maybeAdd(name);
      } else {
        for(var o = obj; o; o = Object.getPrototypeOf(o))
          Object.getOwnPropertyNames(o).forEach(maybeAdd);
      }
    }

    if(context && context.length) {
      context = JSON.parse(context);
      // If this is a property, see if it belongs to some object we can
      // find in the current environment.
      var obj = context.pop(), base;
      if(obj.type && obj.type.indexOf("variable") === 0) {
        base = base || global[obj.string];
      } else if(obj.type == "string") {
        base = "";
      } else if(obj.type == "atom") {
        base = 1;
      } else if(obj.type == "function") {
        if(global.jQuery != null && (obj.string == '

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document} || obj.string == 'jQuery') &&
            (typeof global.jQuery == 'function')) {
            base = global.jQuery();
          } else if(global._ != null && (obj.string == '_') && (typeof global._ == 'function')) {
            base = global._();
          }
      }
      while(base != null && context.length)
        base = base[context.pop().string]; // switch base to variable
      if(base != null) gatherCompletions(base);
    } else {
       gatherCompletions(global);
      forEach(keywords, maybeAdd);
    }
    if(found.length) {
      found.sort(function(a, b) {
        return a.length - b.length || a.localeCompare(b);
      });
    }
    return found;
  }    

  /**
   * Retrieves an object by matching a specific property value.
   * @param {Object} obj - The object to search through.
   * @param {string} prop - The property name to match.
   * @param {*} val - The value to match against the property.
   * @returns {Object|null} The found object with key and value, or null if not found.
   */
  getObjectByProp(obj, prop, val) {
    const key = Object.keys(obj).find(function(key) { return obj[key][prop] === val; });
    return key ? { key, value: obj[key] } : null;
  }

  /**
   * Retrieves multiple objects from a parent object by matching a specific property value.
   * @param {Object} obj - The parent object to search through.
   * @param {string} prop - The property name to match.
   * @param {*} val - The value to match against the property.
   * @returns {Object} An object containing all matched key-value pairs.
   */
  getObjectsByProp(obj, prop, val) {
    return Object.fromEntries(Object.entries(obj)
      .filter(function([key, value]) { return value[prop] === val; }));
  }

  /**
   * Compares two strings lexicographically.
   * @param {string} x - The first string.
   * @param {string} y - The second string.
   * @return {number} The result of the comparison.
   */
  strcmp(x, y) {
    return this.jsl.env.math.compareText(x, y);
  }
    
  /**
   * Compare two version strings (e.g. "1.4.2", "v2.0.0-beta.1").
   * @param {string} a First version.
   * @param {string} b Second version.
   * @returns {number} -1 if a < b, 0 if equal, 1 if a > b.
   */
  compareVersions(a, b) {
    var clean = v => v.replace(/^v/i, '').split(/[-+]/)[0];
    var toNums = v => clean(v).split('.').map(Number);

    var x = toNums(a);
    var y = toNums(b);
    const len = Math.max(x.length, y.length);

    for(let i = 0; i < len; i++) {
      var xi = x[i] ?? 0;
      var yi = y[i] ?? 0;
      if (xi > yi) return 1;
      if (xi < yi) return -1;
    }
    return 0;
  }
  
  /**
   * Checks if there is available update
   * @returns {boolean} True if there is available update; otherwise, false.
   */
  async checkForUpdate() {
    if(this.jsl.networking.isOnline()) {
      try {
        var api_base = 'https://api.github.com/repos/PR-DC/JSLAB';

        const rel = await fetch(`${api_base}/releases/latest`, {
          headers: { 'Accept': 'application/vnd.github+json' }
        });
        
        var latest_version;
        if(rel.ok) {
          const { tag_name } = await rel.json();   // e.g. "v1.5.0"
          latest_version = tag_name;
        } else if (rel.status === 404) {
          const tagRes = await fetch(`${api_base}/tags?per_page=1`);
          const [ { name } ] = await tagRes.json(); // e.g. "v1.5.0-beta.1"
          latest_version = name;
        } else {
          this.jsl._console.log(rel);
          this.jsl.env.error('@checkForUpdate: '+language.string(237));
        }

        var check = this.compareVersions(this.jsl.env.version, latest_version) === -1;
        if(check) {
          this.jsl.env.disp('@checkForUpdate: '+language.string(238) + '<a href="https://github.com/PR-DC/JSLAB/releases" class="external-link">https://github.com/PR-DC/JSLAB/releases</a>');
        }
        return check;
      } catch(err) {
        this.jsl._console.log(err);
        this.jsl.env.error('@checkForUpdate: '+language.string(237));
      }
    } else {
      this.jsl.env.error('@checkForUpdate: '+language.string(237));
    }
  }

  /**
   * Unloads a previously required module from the cache.
   * @param {string} module - The module to unrequire.
   */
  unrequire(module) {
    module = this.jsl.pathResolve(module);
    if(this.jsl.required_modules.includes(module)) {
      var name = require.resolve(module);
      if(name) {
        delete require.cache[name];    
      }
      this.jsl.array.removeElementByValue(this.jsl.required_modules, module);
    }
  }
  
  /**
   * Resets app.
   */
  resetApp() {
    this.jsl.env.resetApp();
  }
  
  /**
   * Resets the sandbox environment to its initial state.
   */
  resetSandbox() {
    this.jsl.env.resetSandbox();
  }

  /**
   * Opens the developer tools for the sandbox environment in the current context.
   * @returns {void}
   */
  openDevTools() {
    this.jsl.env.openSandboxDevTools();
  }
  
  /**
   * Compiles a N-API module located at the specified path.
   * @param {string} path - The path to the N-API module.
   * @param {boolean} [show_output=true] - Whether to show output in the command window.
   * @return {Array} An array containing the result of the compilation and targets.
   */
  compileNapi(path, show_output = false) {
    var result = false;
    var obj = this;
    if(typeof path == 'string') {
      path = this.jsl.pathResolve(path);
    }
    if(!path) {
      var options = {
        title: language.currentString(141),
        buttonLabel: language.currentString(142),
        properties: ['openDirectory'],
      };
      path = this.jsl.env.showOpenDialogSync(options);
      if(path === undefined) {
        this.jsl.env.error('@compileNapi: '+language.string(119)+'.');
        return false;
      } else {
        path = path[0];
      }
    }
    path = this.jsl.env.addPathSep(path);
 
    if(this.jsl.env.rmSync(path+'build/Release/', false) === false) {
      this.jsl.env.error('@compileNapi: '+language.string(171));
    }
    
    var binding_file_path = path + 'binding.gyp';
    if(this.jsl.env.checkFile(binding_file_path)) {
      var targets = [];
      try {
        var binding_file_data = JSON.parse(this.jsl.env.readFileSync(binding_file_path).toString());
      } catch(err) {
        this.jsl.env.error('@compileNapi: '+language.string(120)+'.');
        return false;
      }
      binding_file_data.targets.forEach(function(target) {
        targets.push(path + 'build/Release/' + target.target_name + '.node');
      });
      if(targets.length > 0) {
        var exe = this.jsl.env.exe_path;
        var node_gyp_path = app_path + '/node_modules/node-gyp/bin/node-gyp.js';
        var npm_path = this.jsl.env.pathJoin(app_path, 'node_modules', 'npm', 'bin', 'npm-cli.js');
        var msg = this.system('set ELECTRON_RUN_AS_NODE=1 & "' + exe + '" "' + npm_path + '" cache clean --force & "' + exe + '" "' + npm_path + '" install --build-from-source=false & "' + exe + '" "' + node_gyp_path + '" rebuild --target='+process.version+' 2>&1', {cwd: path, shell: false});
        
        if(msg.endsWith('gyp info ok \n')) {
          if(show_output) {
            this.jsl.env.disp(msg.replaceAll('\n', '<br>'));
          }
          result = true;
        } else if(!msg.endsWith('gyp ERR! not ok \n')) {
          this.jsl.env.error('@compileNapi: '+language.string(121)+'. '+msg.replaceAll('\n', '<br>'));
        } else {
          this.jsl.env.error('@compileNapi: '+language.string(170)+'. '+msg.replaceAll('\n', '<br>'));
        }

        if(result) {
          return [result, targets];
        } else {
          return [result, undefined];
        }
      } else {
        this.jsl.env.error('@compileNapi: '+language.string(122)+'. '+msg.replaceAll('\n', '<br>'));
        return [result, undefined];
      }
    } else {
      this.jsl.env.error('@compileNapi: '+language.string(123)+'. '+msg.replaceAll('\n', '<br>'));
      return [result, undefined];
    }
  }
  
  /**
   * Installs a module located at the specified path.
   * @param {string} path - The path to the module.
   * @param {boolean} [show_output=true] - Whether to show output in the command window.
   */
  installModule(path, show_output = false) {
    if(typeof path == 'string') {
      path = this.jsl.pathResolve(path);
    }
    if(!path) {
      var options = {
        title: language.currentString(141),
        buttonLabel: language.currentString(142),
        properties: ['openDirectory'],
      };
      path = this.jsl.env.showOpenDialogSync(options);
      if(path === undefined) {
        this.jsl.env.error('@installModule: '+language.string(119)+'.');
      } else {
        path = path[0];
      }
    }
    path = this.jsl.env.addPathSep(path);
    
    var exe = this.jsl.env.exe_path;
    var npm_path = this.jsl.env.pathJoin(app_path, 'node_modules', 'npm', 'bin', 'npm-cli.js');
    var msg = this.system('set ELECTRON_RUN_AS_NODE=1 & "' + exe + '" "' + npm_path + '" install 2>&1', {cwd: path, shell: false});
    
    if(!msg.includes('\nnpm error')) {
      if(show_output) {
        this.jsl.env.disp(msg);
      }
    } else {
      this.jsl.env.error('@installModule: '+msg.replaceAll('\n', '<br>'));
    }
  }
  
  /**
   * Registers an object for cleanup with a specified cleanup function.
   * @param {Object} obj - The object to be registered for cleanup.
   * @param {Function} fun - The function to execute during cleanup.
   */
  addForCleanup(...args) {
    this.jsl.addForCleanup(...args);
  }
}

exports.PRDC_JSLAB_LIB_BASIC = PRDC_JSLAB_LIB_BASIC;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={color.js}]
/**
 * @file JSLAB library color submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB color submodule.
 */
class PRDC_JSLAB_LIB_COLOR {
  
  /**
   * Constructs a color submodule object with access to JSLAB's color functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;

    /**
     * Color order
     * @type {Array}
     */
    this.colororder = ['#0072BD', '#D95319', '#EDB120', '#7E2F8E', '#77AC30', '#4DBEEE', '#A2142F'];
  
    var colors = {
      aliceblue: 'rgb(240, 248, 255)',
      antiquewhite: 'rgb(250, 235, 215)',
      aqua: 'rgb(0, 255, 255)',
      aquamarine: 'rgb(127, 255, 212)',
      azure: 'rgb(240, 255, 255)',
      beige: 'rgb(245, 245, 220)',
      bisque: 'rgb(255, 228, 196)',
      black: 'rgb(0, 0, 0)',
      blanchedalmond: 'rgb(255, 235, 205)',
      blue: 'rgb(0, 0, 255)',
      blueviolet: 'rgb(138, 43, 226)',
      brown: 'rgb(165, 42, 42)',
      burlywood: 'rgb(222, 184, 135)',
      cadetblue: 'rgb(95, 158, 160)',
      chartreuse: 'rgb(127, 255, 0)',
      chocolate: 'rgb(210, 105, 30)',
      coral: 'rgb(255, 127, 80)',
      cornflowerblue: 'rgb(100, 149, 237)',
      cornsilk: 'rgb(255, 248, 220)',
      crimson: 'rgb(220, 20, 60)',
      cyan: 'rgb(0, 255, 255)',
      darkblue: 'rgb(0, 0, 139)',
      darkcyan: 'rgb(0, 139, 139)',
      darkgoldenrod: 'rgb(184, 134, 11)',
      darkgray: 'rgb(169, 169, 169)',
      darkgreen: 'rgb(0, 100, 0)',
      darkgrey: 'rgb(169, 169, 169)',
      darkkhaki: 'rgb(189, 183, 107)',
      darkmagenta: 'rgb(139, 0, 139)',
      darkolivegreen: 'rgb(85, 107, 47)',
      darkorange: 'rgb(255, 140, 0)',
      darkorchid: 'rgb(153, 50, 204)',
      darkred: 'rgb(139, 0, 0)',
      darksalmon: 'rgb(233, 150, 122)',
      darkseagreen: 'rgb(143, 188, 143)',
      darkslateblue: 'rgb(72, 61, 139)',
      darkslategray: 'rgb(47, 79, 79)',
      darkslategrey: 'rgb(47, 79, 79)',
      darkturquoise: 'rgb(0, 206, 209)',
      darkviolet: 'rgb(148, 0, 211)',
      deeppink: 'rgb(255, 20, 147)',
      deepskyblue: 'rgb(0, 191, 255)',
      dimgray: 'rgb(105, 105, 105)',
      dimgrey: 'rgb(105, 105, 105)',
      dodgerblue: 'rgb(30, 144, 255)',
      firebrick: 'rgb(178, 34, 34)',
      floralwhite: 'rgb(255, 250, 240)',
      forestgreen: 'rgb(34, 139, 34)',
      fuchsia: 'rgb(255, 0, 255)',
      gainsboro: 'rgb(220, 220, 220)',
      ghostwhite: 'rgb(248, 248, 255)',
      gold: 'rgb(255, 215, 0)',
      goldenrod: 'rgb(218, 165, 32)',
      gray: 'rgb(128, 128, 128)',
      green: 'rgb(0, 128, 0)',
      greenyellow: 'rgb(173, 255, 47)',
      grey: 'rgb(128, 128, 128)',
      honeydew: 'rgb(240, 255, 240)',
      hotpink: 'rgb(255, 105, 180)',
      indianred: 'rgb(205, 92, 92)',
      indigo: 'rgb(75, 0, 130)',
      ivory: 'rgb(255, 255, 240)',
      khaki: 'rgb(240, 230, 140)',
      lavender: 'rgb(230, 230, 250)',
      lavenderblush: 'rgb(255, 240, 245)',
      lawngreen: 'rgb(124, 252, 0)',
      lemonchiffon: 'rgb(255, 250, 205)',
      lightblue: 'rgb(173, 216, 230)',
      lightcoral: 'rgb(240, 128, 128)',
      lightcyan: 'rgb(224, 255, 255)',
      lightgoldenrodyellow: 'rgb(250, 250, 210)',
      lightgray: 'rgb(211, 211, 211)',
      lightgreen: 'rgb(144, 238, 144)',
      lightgrey: 'rgb(211, 211, 211)',
      lightpink: 'rgb(255, 182, 193)',
      lightsalmon: 'rgb(255, 160, 122)',
      lightseagreen: 'rgb(32, 178, 170)',
      lightskyblue: 'rgb(135, 206, 250)',
      lightslategray: 'rgb(119, 136, 153)',
      lightslategrey: 'rgb(119, 136, 153)',
      lightsteelblue: 'rgb(176, 196, 222)',
      lightyellow: 'rgb(255, 255, 224)',
      lime: 'rgb(0, 255, 0)',
      limegreen: 'rgb(50, 205, 50)',
      linen: 'rgb(250, 240, 230)',
      magenta: 'rgb(255, 0, 255)',
      maroon: 'rgb(128, 0, 0)',
      mediumaquamarine: 'rgb(102, 205, 170)',
      mediumblue: 'rgb(0, 0, 205)',
      mediumorchid: 'rgb(186, 85, 211)',
      mediumpurple: 'rgb(147, 112, 219)',
      mediumseagreen: 'rgb(60, 179, 113)',
      mediumslateblue: 'rgb(123, 104, 238)',
      mediumspringgreen: 'rgb(0, 250, 154)',
      mediumturquoise: 'rgb(72, 209, 204)',
      mediumvioletred: 'rgb(199, 21, 133)',
      midnightblue: 'rgb(25, 25, 112)',
      mintcream: 'rgb(245, 255, 250)',
      mistyrose: 'rgb(255, 228, 225)',
      moccasin: 'rgb(255, 228, 181)',
      navajowhite: 'rgb(255, 222, 173)',
      navy: 'rgb(0, 0, 128)',
      oldlace: 'rgb(253, 245, 230)',
      olive: 'rgb(128, 128, 0)',
      olivedrab: 'rgb(107, 142, 35)',
      orange: 'rgb(255, 165, 0)',
      orangered: 'rgb(255, 69, 0)',
      orchid: 'rgb(218, 112, 214)',
      palegoldenrod: 'rgb(238, 232, 170)',
      palegreen: 'rgb(152, 251, 152)',
      paleturquoise: 'rgb(175, 238, 238)',
      palevioletred: 'rgb(219, 112, 147)',
      papayawhip: 'rgb(255, 239, 213)',
      peachpuff: 'rgb(255, 218, 185)',
      peru: 'rgb(205, 133, 63)',
      pink: 'rgb(255, 192, 203)',
      plum: 'rgb(221, 160, 221)',
      powderblue: 'rgb(176, 224, 230)',
      purple: 'rgb(128, 0, 128)',
      red: 'rgb(255, 0, 0)',
      rosybrown: 'rgb(188, 143, 143)',
      royalblue: 'rgb(65, 105, 225)',
      saddlebrown: 'rgb(139, 69, 19)',
      salmon: 'rgb(250, 128, 114)',
      sandybrown: 'rgb(244, 164, 96)',
      seagreen: 'rgb(46, 139, 87)',
      seashell: 'rgb(255, 245, 238)',
      sienna: 'rgb(160, 82, 45)',
      silver: 'rgb(192, 192, 192)',
      skyblue: 'rgb(135, 206, 235)',
      slateblue: 'rgb(106, 90, 205)',
      slategray: 'rgb(112, 128, 144)',
      slategrey: 'rgb(112, 128, 144)',
      snow: 'rgb(255, 250, 250)',
      springgreen: 'rgb(0, 255, 127)',
      steelblue: 'rgb(70, 130, 180)',
      tan: 'rgb(210, 180, 140)',
      teal: 'rgb(0, 128, 128)',
      thistle: 'rgb(216, 191, 216)',
      tomato: 'rgb(255, 99, 71)',
      turquoise: 'rgb(64, 224, 208)',
      violet: 'rgb(238, 130, 238)',
      wheat: 'rgb(245, 222, 179)',
      white: 'rgb(255, 255, 255)',
      whitesmoke: 'rgb(245, 245, 245)',
      yellow: 'rgb(255, 255, 0)',
      yellowgreen: 'rgb(154, 205, 50)'
    };

    this.RE_RGB = /^rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/;
    this.RE_RGBA = /^rgba\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)$/;
    this.RE_HSL = /^hsl\(\s*([\d\.]+)\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*\)$/;
    this.RE_HSLA = /^hsla\(\s*([\d\.]+)\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)%\s*,\s*([\d\.]+)\s*\)$/;
    this.RE_HEX = /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/; // 6 digit
    
    // Global object
    var Color = {
      create: function(str) {
        str = str.replace(/^\s*#|\s*$/g, '');
        str = str.toLowerCase();
        if(KEYWORDS[str]) str = KEYWORDS[str];

        var match;

        // RGB(A)
        if((match = str.match(RE_RGB) || str.match(RE_RGBA))) {
          return new Color.RGBA(
            parseInt(match[1], 10),
            parseInt(match[2], 10),
            parseInt(match[3], 10),
            parseFloat(match.length === 4 ? 1 : match[4])
          );
        }

        // HSL(A)
        if((match = str.match(RE_HSL) || str.match(RE_HSLA))) {
          return new Color.HSLA(
            parseFloat(match[1]),
            parseFloat(match[2]),
            parseFloat(match[3]),
            parseFloat(match.length === 4 ? 1 : match[4])
          );
        }

        // Hex
        if(str.length === 3) {
          // Hex 3 digit -> 6 digit
          str = str.replace(/(.)/g, '$1$1');
        }
        if((match = str.match(RE_HEX))) {
          return new Color.RGBA(
            parseInt(match[1], 16),
            parseInt(match[2], 16),
            parseInt(match[3], 16),
            1
          );
        }

        return null;
      },
      
      luminance: function(color) {
        if(color instanceof Color.HSLA) color = color.toRGBA();
        return 0.298912 * color.r + 0.586611 * color.g + 0.114478 * color.b;
      },

      greyscale: function(color) {
        var lum = Color.luminance(color);
        return new Color.RGBA(lum, lum, lum, this.a);
      },

      nagate: function(color) {
        if(color instanceof Color.HSLA) color = color.toRGBA();
        return new Color.RGBA(255 - color.r, 255 - color.g, 255 - color.b, color.a);
      },

      /**
       * @see http://sass-lang.com/docs/yardoc/Sass/Script/Functions.html#mix-instance_method
       */
      mix: function(color1, color2, weight) {
        if(color1 instanceof Color.HSLA) color1 = color1.toRGBA();
        if(color2 instanceof Color.HSLA) color2 = color2.toRGBA();
        if(isNull(weight) || obj.jsl.format.isUndefined(weight)) weight = 0.5;

        var w0 = 1 - weight;
        var w = w0 * 2 - 1;
        var a = color1.a - color2.a;
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;

        return new Color.RGBA(
          Math.round(color1.r * w1 + color2.r * w2),
          Math.round(color1.g * w1 + color2.g * w2),
          Math.round(color1.b * w1 + color2.b * w2),
          Math.round(color1.a * w0 + color2.a * weight)
        );
      }
    };

    /**
     * Color.RGBA
     */
    Color.RGBA = function(r, g, b, a) {
      if(isArray(r)) {
        g = r[1];
        b = r[2];
        a = r[3];
        r = r[0];
      } else if(isObject(r)) {
        g = r.g;
        b = r.b;
        a = r.a;
        r = r.r;
      }
      
      this.r = r || 0;
      this.g = g || 0;
      this.b = b || 0;
      this.a = !isNumber(a) ? 1 : a;
    };

    Color.RGBA.prototype = {        
      toHSLA: function() {
        var hsl = rgbToHsl(Math.round(this.r), Math.round(this.g), Math.round(this.b));
        return new Hsla(hsl[0], hsl[1], hsl[2], this.a);
      },
      
      toArray: function() {
        return [Math.round(this.r), Math.round(this.g), Math.round(this.b), this.a];
      },
      
      clone: function() {
        return new Color.RGBA(this);
      },
      
      toString: function() {
        return 'rgba(' + Math.round(this.r) + ', ' + Math.round(this.g) + ', ' + Math.round(this.b) + ', ' + this.a + ')';
      }
    };


    /**
     * Color.HSLA
     */
    Color.HSLA = function(h, s, l, a) {
      if(isArray(h)) {
        s = h[1];
        l = h[2];
        a = h[3];
        h = h[0];
      } else if(isObject(h)) {
        s = h.s;
        l = h.l;
        a = h.a;
        h = h.h;
      }
      
      this.h = h || 0;
      this.s = s || 0;
      this.l = l || 0;
      this.a = !isNumber(a) ? 1 : a;
    };

    Color.HSLA.prototype = {
      toRGBA: function() {
        var rgb = this.hslToRgb(this.h, this.s, this.l);
        return new Rgba(rgb[0], rgb[1], rgb[2], this.a);
      },
      
      toArray: function() {
        return [this.h, this.s, this.l, this.a];
      },
      
      clone: function() {
        return new Color.HSLA(this);
      },
      
      toString: function() {
        return 'hsla(' + this.h + ', ' + this.s + '%, ' + this.l + '%, ' + this.a + ')';
      }
    };
  }
 
  /**
   * Returns a color code based on the provided identifier.
   * @param {number|string|Array<number>} id - Identifier for the color. Can be a numeric index, a predefined color name, or an RGB array.
   * @return {string} The hex code of the color.
   */
  color(id) {
    var c = '#0072BD';
    if(typeof id == 'number') {
      c = colororder[id % 7];
    } else if(Array.isArray(id)) {
      if(id.length == 3) {
        c = rgb2hex(id);
      }
    } else {
      switch(id) {
        case 'y':
        case 'yellow':
          c = '#FFFF00';
          break;
        case 'm':
        case 'magenta':
          c = '#FF00FF';
          break;
        case 'c':
        case 'cyan':
          c = '#00FFFF';
          break;
        case 'r':
        case 'red':
          c = '#FF0000';
          break;
        case 'g':
        case 'green':
          c = '#00FF00';
          break;
        case 'b':
        case 'blue':
          c = '#0000FF';
          break;
        case 'w':
        case 'white':
          c = '#FFFFFF';
          break;
        case 'k':
        case 'black':
          c = '#000000';
          break;
      }
    }
    return c;
  }

  /**
   * Calculates a color on a gradient from green to red based on a value.
   * @param {number} value - A number between 0 and 1 indicating position on the gradient.
   * @param {number} [k=0.3] - A scaling factor to adjust the gradient effect.
   * @return {string} The hsl color string.
   */
  getColorG2R(value, k = 0.3){
    if(value < 0) {
      value = 0;
    } else if(value < k) {
      value = value/k;
    } else {
      value = 1;
    }
    var hue=(120*value).toString(10);
    return ["hsl(",hue,",100%,50%)"].join("");
  }

  /**
   * Calculates the gradient color between two colors based on a percentage.
   * @param {number} p - The percentage (0 to 1) between the two colors.
   * @param {Array<number>} rgb_beginning - The RGB values of the start color.
   * @param {Array<number>} rgb_end - The RGB values of the end color.
   * @return {Array<number>} The RGB values of the calculated gradient color.
   */
  colourGradientor(p, rgb_beginning, rgb_end){
    var w = p * 2 - 1;
    var w1 = (w + 1) / 2.0;
    var w2 = 1 - w1;

    var rgb = [parseInt(rgb_beginning[0] * w1 + rgb_end[0] * w2),
      parseInt(rgb_beginning[1] * w1 + rgb_end[1] * w2),
      parseInt(rgb_beginning[2] * w1 + rgb_end[2] * w2)];
    return rgb;
  }

  /**
   * Converts RGB color values to HEX.
   * @param {number} r - The red color value (0-255).
   * @param {number} g - The green color value (0-255).
   * @param {number} b - The blue color value (0-255).
   * @return {Array<number>} The HEX representation of the color.
   */
  rgb2hex(r, g, b) {
    // If the first argument is an array, unpack its values
    if(Array.isArray(r)) {
      [r, g, b] = r;
    }
    
    function toHex(c) {
      // Scale to 0-255 if the value is between 0 and 1
      c = (c <= 1) ? Math.round(c * 255) : Math.round(c);
      // Clamp the value between 0 and 255
      c = Math.min(255, Math.max(0, c));
      // Convert to hexadecimal and pad with zeros if necessary
      return c.toString(16).padStart(2, '0').toUpperCase();
    }
    return '#' + toHex(r) + toHex(g) + toHex(b);
  }
  
  /**
   * Converts RGB color values to HSL (Hue, Saturation, Lightness).
   * @param {number} r - The red color value (0-255).
   * @param {number} g - The green color value (0-255).
   * @param {number} b - The blue color value (0-255).
   * @return {Array<number>} The HSL representation of the color.
   */
  rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;

    var max = Math.max(r, g, b);
    var min = Math.min(r, g, b);
    var h, s, l;

    l = (max + min) / 2;

    if(max === min) {
      h = s = 0;
    } else {
      var d = max - min;
      switch (max) {
        case r: h = ((g - b) / d * 60 + 360) % 360; break;
        case g: h = (b - r) / d * 60 + 120; break;
        case b: h = (r - g) / d * 60 + 240; break;
      }
      s = l <= 0.5 ? d / (max + min) : d / (2 - max  - min);
    }

    return [h, s * 100, l * 100];
  }

  /**
   * Converts HSL color values to RGB.
   * @param {number} h - The hue value (0-360).
   * @param {number} s - The saturation value (0-100).
   * @param {number} l - The lightness value (0-100).
   * @return {Array<number>} The RGB representation of the color.
   */
  hslToRgb(h, s, l) {
    s /= 100;
    l /= 100;

    var r, g, b;

    if(s === 0){
      r = g = b = l * 255;
    } else {
      var v2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var v1 = 2 * l - v2;
      r = Math.round(this.hueToRgb(v1, v2, h + 120) * 255);
      g = Math.round(this.hueToRgb(v1, v2, h) * 255);
      b = Math.round(this.hueToRgb(v1, v2, h - 120) * 255);
    }

    return [r, g, b];
  }

  /**
   * Helper function for converting a hue to RGB.
   * @param {number} v1 - Helper value 1.
   * @param {number} v2 - Helper value 2.
   * @param {number} vh - The hue value to convert.
   * @return {number} The RGB value for the hue.
   */
  hueToRgb(v1, v2, vh) {
    vh /= 360;
    if(vh < 0) vh++;
    if(vh > 1) vh--;
    if(vh < 1 / 6) return v1 + (v2 - v1) * 6 * vh;
    if(vh < 1 / 2) return v2;
    if(vh < 2 / 3) return v1 + (v2 - v1) * (2 / 3 - vh) * 6;
    return v1;
  }
}
    
exports.PRDC_JSLAB_LIB_COLOR = PRDC_JSLAB_LIB_COLOR;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={control.js}]
/**
 * @file JSLAB library control submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB control submodule.
 */
class PRDC_JSLAB_LIB_CONTROL {
  
  /**
   * Initializes the control submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }

  /**
   * Create a transfer function representation.
   * @param {number[]} num - Numerator coefficients of the transfer function.
   * @param {number[]} den - Denominator coefficients of the transfer function.
   * @param {number} [Ts=0] - Sampling time, defaults to 0 for continuous-time systems.
   * @returns {object} An object representing the transfer function { num, den, Ts }.
   */
  tf(num, den, Ts = 0) {
    return { num, den, Ts };
  }

  /**
   * Create a state-space representation.
   * @param {number[][]} A - System matrix.
   * @param {number[][]} B - Input matrix.
   * @param {number[][]} C - Output matrix.
   * @param {number[][]} D - Feedthrough matrix.
   * @param {number} [Ts=0] - Sampling time, defaults to 0 for continuous-time systems.
   * @returns {object} An object representing the state-space system { A, B, C, D, Ts }.
   */
  ss(A, B, C, D, Ts = 0) {
    return { A, B, C, D, Ts };
  }

  /**
   * Convert a transfer function to a state-space representation.
   * @param {number[]} num - Numerator coefficients of the transfer function.
   * @param {number[]} den - Denominator coefficients of the transfer function.
   * @returns {object} State-space representation of the system.
   */
  tf2ss(num, den) {
    const n = den.length;
    num = [...zeros(n - num.length), ...num];

    let A = zeros(n-1).map(() => zeros(n-1));
    for(let i = 1; i < n - 1; i++) A[i-1][i] = 1;
    A[n - 2] = fliplr(den.slice(1).map(d => -d));

    const C = fliplr(num.map((c, i) => c - den[i] * num[0]).slice(1));
    const B = zeros(n - 2).concat([1]);
    const D = num[0];

    return this.ss(A, B, C, D);
  }

  /**
   * Convert a state-space representation to a transfer function.
   * @param {object} sys - State-space system { A, B, C, D }.
   * @returns {object} Transfer function representation { num, den }.
   */
  ss2tf(sys) {
    const { A, B, C, D } = sys;
  
    const den = charpoly(A);
    const num = plus(charpoly(minus(A, this.jsl.env.math.multiply(B, [C]))),
      scale(den, D-1));

    var p = den.length - num.length;
    if(p > 0) {
      num = [...zeros(p), ...num];
    }
    return { num, den };
  }

  /**
   * Convert a continuous-time transfer function to discrete-time.
   * @param {number[]} numc - Continuous-time numerator coefficients.
   * @param {number[]} denc - Continuous-time denominator coefficients.
   * @param {number} Ts - Sampling time.
   * @returns {object} Discrete-time transfer function representation { num, den }.
   */
  c2d(numc, denc, Ts) {
    const sysc = this.tf2ss(numc, denc);
    const sysd = this._c2dZOH(sysc, Ts);
    return this.ss2tf(sysd);
  }

  /**
   * Convert a continuous-time state-space system to discrete-time using Zero-Order Hold.
   * @param {object} sysc - Continuous-time state-space system { A, B, C, D }.
   * @param {number} Ts - Sampling time.
   * @returns {object} Discrete-time state-space system { A, B, C, D, Ts }.
   */
  _c2dZOH(sysc, Ts) {
    const { A, B, C, D } = sysc;
    const n = A.length;

    const M = A.map((row, i) => [...row, B[i]]);
    M.push(zeros(n + 1));
    const M_exp = jsl.env.math.expm(jsl.env.math.multiply(M, Ts))._data.slice(0, n);

    const Ad = M_exp.map(row => row.slice(0, n));
    const Bd = M_exp.map(row => row.slice(n));

    return this.ss(Ad, Bd, C, D, Ts);
  }
  
  /**
   * Simulate the time response of a discrete-time linear system.
   * @param {number[]} sys - transfer function of system.
   * @param {number[]} u - Input signal array.
   * @param {number[]} t - Time vector array.
   * @returns {object} An object containing the response:
   *                   - y: Output signal array.
   *                   - t: Time vector array (same as input).
   */
  lsim(sys, u, t, Ts) {
    var sysd = sys;
    if(!sys.Ts && Ts) {
      sysd = this.c2d(sys.num, sys.den, Ts);
    }
    var num = sysd.num;
    var den = sysd.den;

    // Normalize the denominator coefficients so that den[0] = 1
    if(den[0] !== 1) {
      const den0 = den[0];
      for(let i = 0; i < den.length; i++) {
        den[i] /= den0;
      }
      for(let i = 0; i < num.length; i++) {
        num[i] /= den0;
      }
    }

    const N = u.length;
    var y = zeros(N); // Initialize output array with zeros

    // Iterate over each time step starting from n=1
    for(let n = 0; n < N; n++) {
      // Compute feedforward terms: sum(num[k] * u[n - k}) for k =0 to M
      for(let k = 0; k < num.length; k++) {
        const idx = n - k;
        if(idx >= 0) {
          y[n] += num[k] * u[idx];
        }
      }

      // Compute feedback terms: sum(den[k} * y[n - k}) for k =1 to N
      for(let k = 1; k < den.length; k++) {
        const idx = n - k;
        if(idx >= 0) {
          y[n] -= den[k] * y[idx];
        }
      }
    }
    
    if(num.length < den.length) {
      var n = den.length - num.length;
      y = [...zeros(n), ...y.slice(0, y.length - n)];
    }
    
    return { y, t };
  }
  
  /**
   * Simulates the system response over a specified time period.
   * @param {Object} sys - The system to simulate.
   * @param {number} Tfinal - The final time for the simulation.
   * @returns {Object} The simulation result.
   */
  step(sys, Tfinal) {
    var u = ones(101);
    var t = linspace(0, Tfinal, 101);
    var Ts = Tfinal/100;
    return this.lsim(sys, u, t, Ts);
  }
  
  /**
   * Estimates a transfer function model using numerical optimization.
   * @param {Array<number>} t - Time vector.
   * @param {Array<number>} u - Input signal vector.
   * @param {Array<number>} y - Output signal vector.
   * @param {number} np - Number of poles.
   * @param {number} nz - Number of zeros.
   * @param {string} [method='NelderMead'] - Optimization method ('NelderMead' or 'Powell').
   * @returns {{sys: object, error: number}} Estimated transfer function and mean squared error.
   */
  tfest(t, u, y, np, nz, method = 'NelderMead') {
    var obj = this;
    var Ts = mean(diff(t));
    var N = np+nz+1;
    var f = (x) => { // funkcija prilagodjenosti
      try {
        var den = [1, ...x.slice(0, np)];
        var num = x.slice(np);
        var sys = tf(num, den);
        var r = obj.lsim(sys, u, t, Ts);
        var mse = obj.jsl.math.mse(y, r.y);
        return mse;
      } catch(err) {
        return Infinity;
      }
    };
    var r;
    if(method == 'NelderMead') {
      r = this.jsl.optim.optimNelderMead(f, zeros(N));
    } else if(method == 'Powell') {
      r = this.jsl.optim.optimPowell(f, zeros(N));
    }
    var den = [1, ...r.x.slice(0, np)];
    var num = r.x.slice(np);
    return {sys: tf(num, den), error: r.fx};
  }
}

exports.PRDC_JSLAB_LIB_CONTROL = PRDC_JSLAB_LIB_CONTROL;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={conversion.js}]
/**
 * @file JSLAB library conversion submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB conversion submodule.
 */
class PRDC_JSLAB_LIB_CONVERSION {
  
  /**
   * Constructs a conversion submodule object with access to JSLAB's conversion functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
    
    this.speech = this.jsl.env.speech;
    
    /**
     * Serializes BigInt values to JSON by converting them to strings.
     */
    BigInt.prototype.toJSON = function() { return this.toString(); };
  }

  /**
   * Converts text to speech using the Web Speech API.
   * @param {string} msg - The text message to be spoken.
   */
  speak(msg) {
    if(!global.is_worker) {
      this.speech.text = msg;
      speechSynthesis.speak(this.speech);
    }
  }
  
  /**
   * Converts a number to a string with specified precision.
   * @param {number} num - The number to convert.
   * @param {number} precision - The number of digits after the decimal point.
   * @returns {string} The formatted string.
   */
  num2str(num, precision = 2) {
    if(isNumber(precision)) {
      return num.toFixed(precision);
    } else {
      return sprintf(precision, num);
    }
  }

  /**
   * Changes the extension of a file path.
   * @param {string} path - The original file path.
   * @param {string} ext_new - The new extension without the dot.
   * @returns {string} The file path with the new extension.
   */
  changeExtension(path, ext_new) {
    var pos = path.lastIndexOf('.');
    return path.substr(0, pos < 0 ? path.length : pos) + '.' + ext_new;
  }

  /**
   * Remove the extension of a file path.
   * @param {string} path - The original file path.
   * @returns {string} The file path without extension.
   */
  removeExtension(path) {
    var pos = path.lastIndexOf('.');
    return path.substr(0, pos < 0 ? path.length : pos);
  }
  
  /**
   * Transforms coordinates from NED (North, East, Down) frame to RPY (Roll, Pitch, Yaw) frame.
   * @param {number} roll - The roll angle in radians.
   * @param {number} pitch - The pitch angle in radians.
   * @param {number} yaw - The yaw angle in radians.
   * @param {Array<number>} [A] - Optional matrix to apply transformation to.
   * @returns {Array<Array<number>>} The transformation matrix.
   */
  ned2rpy(roll, pitch, yaw, A) {
    T = [
      [Math.cos(yaw)*Math.cos(pitch), 
        Math.sin(yaw)*Math.cos(pitch), 
        -Math.sin(pitch)], 
      [Math.cos(yaw)*Math.sin(pitch)*Math.sin(roll)-Math.sin(yaw)*Math.cos(roll), 
        Math.sin(yaw)*Math.sin(pitch)*Math.sin(roll)+Math.cos(yaw)*Math.cos(roll), 
        Math.cos(pitch)*Math.sin(roll)],
      [Math.cos(yaw)*Math.sin(pitch)*Math.cos(roll)+Math.sin(yaw)*Math.sin(roll), 
        Math.sin(yaw)*Math.sin(pitch)*Math.cos(roll)-Math.cos(yaw)*Math.sin(roll), 
        Math.cos(pitch)*Math.cos(roll)]
    ];

    if(A != undefined) {
      return this.jsl.env.math.multiply(T, A);
    } else {
      return T;
    }
  }

  /**
   * Converts an array of uint8 numbers to a string.
   * @param {Uint8Array} data - The array of uint8 numbers.
   * @returns {string} The converted string.
   */
  uint8ToString(data) {
    return String.fromCharCode(...data);
  }

  /**
   * Converts an array of hexadecimal strings to an array of decimal numbers.
   * @param {Array<string>} hex - The array of hexadecimal strings.
   * @returns {Array<number>} The array of decimal numbers.
   */
  hex2dec(hex) {
    return hex.map(function(e) { 
      return parseInt(e, 16); 
    });  
  }

  /**
   * Converts a number to its ASCII character equivalent.
   * @param {number} num - The number to convert.
   * @returns {string} The ASCII character.
   */
  numToASCII(num) {
    return (''+num).charCodeAt(0);
  }

  /**
   * Converts a number to a hexadecimal string with a fixed number of digits.
   * @param {number} num - The number to convert.
   * @param {number} dig - The number of digits in the resulting string.
   * @param {boolean} prefix - Whether to add a '0x' prefix.
   * @returns {string} The hexadecimal string.
   */
  numToHexStr(num, dig = 4, prefix = false) {
    var str = ('0000'.repeat(dig) + num.toString(16).toUpperCase()).slice(-dig);
    if(prefix) {
      return '0x'+str;
    } 
    return str;
  }

  /**
   * Converts an int8 number to two ASCII characters.
   * @param {number} num - The int8 number.
   * @returns {string} The two ASCII characters.
   */
  int8To2ASCII(num) {
    var data = ("0" + (Uint8Array.from([num])[0]).toString(16)).substr(-2);
    return [data[0].charCodeAt(0), data[1].charCodeAt(0)];
  }

  /**
   * Converts an int16 number to four ASCII characters representing its hexadecimal value.
   * @param {number} num - The int16 number to convert.
   * @returns {string} A string of four ASCII characters.
   */
  int16To4ASCII(num) {
    var data = ("000" + (Uint16Array.from([num])[0]).toString(16).toUpperCase()).substr(-4);
    return [data[0].charCodeAt(0), data[1].charCodeAt(0), data[2].charCodeAt(0), data[3].charCodeAt(0)];
  }

  /**
   * Combines two uint8 values into an int16 value.
   * @param {number} part1 - The first uint8 value.
   * @param {number} part2 - The second uint8 value.
   * @returns {number} The combined int16 value.
   */
  uint8sToInt16(part1, part2) {
      part1 &= 0xFF;
      part2 &= 0xFF;
      
      let result = (part1 << 8) | part2;
      return (result & 0x8000) ? -((result ^ 0xFFFF) + 1) : result;
  }

  /**
   * Combines four uint8 values into an int32 value.
   * @param {number} part1 - The first uint8 value.
   * @param {number} part2 - The second uint8 value.
   * @param {number} part3 - The third uint8 value.
   * @param {number} part4 - The fourth uint8 value.
   * @returns {number} The combined int32 value.
   */
  uint8sToInt32(part1, part2, part3, part4) {
      part1 &= 0xFF;
      part2 &= 0xFF;
      part3 &= 0xFF;
      part4 &= 0xFF;
      
      let result = (part1 << 24) | (part2 << 16) | (part3 << 8) | part4;
      return (result & 0x80000000) ? -((result ^ 0xFFFFFFFF) + 1) : result;
  }

  /**
   * Converts four uint8 values into a floating-point number.
   * @param {number} part1 - The first uint8 value.
   * @param {number} part2 - The second uint8 value.
   * @param {number} part3 - The third uint8 value.
   * @param {number} part4 - The fourth uint8 value.
   * @returns {number} The floating-point number.
   */
  uint8sToFloat(part1, part2, part3, part4) {
    // Combine the Uint8 values into a 32-bit integer
    let combinedValue = (part4 << 24) | (part3 << 16) | (part2 << 8) | part1;

    // Interpret the integer as a float without using Math.pow
    let sign = (combinedValue & 0x80000000) ? -1 : 1;
    let exponent = ((combinedValue >> 23) & 0xFF) - 127;
    let mantissa = (combinedValue & 0x7FFFFF | 0x800000) / (1 << 23); 

    return sign * mantissa * (2 ** exponent);
  }

  /**
   * Converts a uint16 value to an int16 value.
   * @param {number} num - The uint16 value to convert.
   * @returns {number} The converted int16 value.
   */
  uint16ToInt16(num) {
      return (num & 0x8000) ? -((num ^ 0xFFFF) + 1) : num;
  }

  /**
   * Converts a uint8 number to two ASCII characters.
   * @param {number} num - The uint8 number to convert.
   * @returns {string} A string containing two ASCII characters representing the hexadecimal value.
   */
  uint8To2ASCII(num) {
    var data = ("0" + (num % 256).toString(16).toUpperCase()).substr(-2);
    return [data[0].charCodeAt(0), data[1].charCodeAt(0)];
  }

  /**
   * Converts milliseconds to a time string in mm:ss format.
   * @param {number} ms - The time in milliseconds.
   * @returns {string} The time string.
   */
  ms2time(ms){
    min = Math.floor((ms/1000/60) << 0),
    sec = Math.floor((ms/1000) % 60);
    return ('0' + min).slice(-2) + ':' + ('0' + sec).slice(-2);
  }
  
  /**
   * Converts a decimal number to a binary string.
   * @param {number} x - The decimal number.
   * @returns {string} The binary string.
   */
  dec2bin(x) {
    return this.jsl.env.math.bin(x);
  }
  
  /**
   * Converts a decimal number to a hexadecimal string.
   * @param {number} x - The decimal number.
   * @returns {string} The hexadecimal string.
   */
  dec2hex(x) {
    return this.jsl.env.math.hex(x);
  }
  
  /**
   * Converts a decimal number to an octal string.
   * @param {number} x - The decimal number.
   * @returns {string} The octal string.
   */
  dec2oct(x) {
    return this.jsl.env.math.oct(x);
  }
  
  /**
   * Rounds a number to a specified number of decimal places.
   * @param {number} number - The number to round.
   * @param {number} [decimals=2] - The number of decimal places.
   * @param {boolean} [string=false] - Whether to return the result as a string.
   * @returns {number|string} The rounded number.
   */
  round(number, decimals = 2, string = false) {
    var result;
    if(typeof value === 'number') {
      result = number.toFixed(decimals);
    } else {
      result = Number(number).toFixed(decimals);
    }
    if(result == 0) {
      result = '0'; // removes -0
    }   
    if(string) {
      return result;
    } else {
      return Number(result);
    }
  }

  /**
   * Rounds a number to a fixed number of decimal places if it is a number.
   * @param {number} value - The value to round.
   * @param {number} p - The number of digits after the decimal point.
   * @returns {number} The rounded number with a fixed number of decimal places, or the original value if it is not a number.
   */
  roundIf(value, p) {
    if(typeof value === 'number') {
      return Number(value.toFixed(p));
    } else {
      return value;
    }
  }
  
  /**
   * Rounds a number to a fixed number of decimal places if it is a number.
   * @param {number} value - The value to round.
   * @param {number} p - The number of digits after the decimal point.
   * @returns {number} The rounded number with a fixed number of decimal places, or the original value if it is not a number.
   */
  roundIfPrec(value, p) {
    if(typeof p === 'number') {
      return round(value, p);
    } else {
      return value;
    }
  }

  /**
   * Converts a uint8_t number to a bit string.
   * @param {number} n - The number to convert.
   * @returns {string} A bit string representing the number.
   */
  bitString(n) {
    return ("000000000" + n.toString(2)).substr(-8);
  }

  /**
   * Generates a set of flags from a bitfield based on a mapping.
   * @param {Object} map - The mapping of bit positions to flag names.
   * @param {string} name_column - The column name in the mapping that contains the flag names.
   * @param {number} val - The bitfield value.
   * @returns {Object} An object with keys as flag names and values indicating the presence (1) or absence (0) of each flag.
   */
  getBitFlags(map, name_column, val) {
    var flags = {};
    var keys = Object.keys(map);
    var bits = [...Array(keys.length)].map(function(x, i) {
      return val >> i & 1;
    });
    keys.forEach(function(key) {
      flags[map[key][name_column]] = bits[key];
    });
    return flags;
  }

  /**
   * Retrieves the enumeration value based on a property match.
   * @param {Object} enum_object - The enumeration object to search.
   * @param {string} prop - The property name to match.
   * @param {*} val - The property value to match.
   * @returns {number} The enumeration key as a number, or the index if not found.
   */
  getEnumVal(enum_object, prop, val) {
    var enteries = Object.entries(enum_object);
    var idx = enteries.findIndex(function(f) {
        return f[1][prop] == val;
    });
    if(idx > 0) {
      return Number(enteries[idx][0]);
    }
    return idx;
  }

  /**
   * Inverts an enumeration, swapping keys and values, optionally based on a specific property of the enumeration values.
   * @param {Object} enum_object - The enumeration object to invert.
   * @param {string} [prop] - An optional property name to use from the enumeration values.
   * @returns {Object} The inverted enumeration object.
   */
  invertEnum(enum_object, prop) {
    var enum_object_inv = {};
    Object.entries(enum_object).forEach(function([key, value]) {
      var ind = value;
      if(prop) {
        ind = value[prop];
      }
      var num_key = Number(key);
      if(num_key == key) {
        enum_object_inv[ind] = num_key;
      } else {
        enum_object_inv[ind] = key;
      }
    });
    return enum_object_inv;
  }
  
  /**
   * Converts an array of numbers to a string of hexadecimal values, optionally prefixed with "0x".
   * @param {Array<number>} A - The array to convert.
   * @param {boolean} [prefix=true] - Whether to add a "0x" prefix to each hex value.
   * @returns {string} A string of hexadecimal values.
   */
  arrayToHexStr(A, prefix = true) {
    var A_uint8 = new Uint8Array(A);
    var len = A.length;
    var A_hex = Array(len);
    for(let i = 0; i < len; i++) {
      A_hex[i] = A_uint8[i].toString(16).toUpperCase().padStart(2, '0');
    }
    if(prefix) {
      return '0x' + A_hex.join(' 0x');
    } else {
      return A_hex.join(' ');
    }
  }

  /**
   * Converts an array of numbers to an ASCII string.
   * @param {Array<number>} array - The array of numbers to convert.
   * @returns {string} The ASCII string representation of the array.
   */
  arrayToASCII(A) {
    return String.fromCharCode(...A);
  }

  /**
   * Extends an object with properties from additional objects.
   * @param {...Object} objects - The objects to merge into the target object.
   * @returns {Object} The extended object.
   */
  extend() {
    var target = arguments[0] || {}, o, p;

    for(var i = 1, len = arguments.length; i < len; i++) {
      o = arguments[i];

      if(!this.isObject(o)) continue;

      for(p in o) {
        target[p] = o[p];
      }
    }

    return target;
  }
  
  /**
   * Normalizes the value of a radio control (RC) input.
   * @param {number} rc - The RC input value.
   * @param {number} [deadzone=0] - The deadzone value below which the output is set to zero.
   * @returns {number} The normalized value.
   */
  normalizeRC(rc, deadzone = 0) {
    var val = rc-1500;
    if(Math.abs(val) < deadzone) {
      return 0;
    }
    return (val-Math.sign(val)*deadzone)/(500-deadzone);
  }

  /**
   * Checks if a value has been updated and updates the last value if it has.
   * @param {Object} data - An object containing the current value and the last value.
   * @returns {boolean} True if the value has been updated; false otherwise.
   */
  checkValueUpdate(data) {
    if(data.value != data.last_value) {
      data.last_value = data.value;
      return true;
    } else {
      return false;
    }
  }

  /**
   * Resets the value and last value properties of an object.
   * @param {Object} data - The object whose value and last value properties will be reset.
   */
  resetValue(data) {
    data.last_value = undefined;
    data.value = undefined;
  }

  /**
   * Converts an ADC count to force in Newtons.
   * @param {number} adc_count - The raw ADC count value.
   * @param {number} load_cell_capacity - The capacity of the load cell in Newtons.
   * @param {number} [adc_resolution=24] - The ADC resolution in bits.
   * @param {number} [adc_gain=128] - The gain applied to the ADC.
   * @param {number} [adc_sensitivity=2] - The ADC sensitivity in mV/V.
   * @param {boolean} [adc_bipolar=true] - Indicates if the ADC is bipolar.
   * @returns {number} The calculated force in Newtons.
   */
  adcToNewtons(adc_count, load_cell_capacity, 
      adc_resolution = 24, adc_gain = 128,  
      adc_sensitivity = 2, adc_bipolar = true) {
    if(adc_bipolar) {
      adc_resolution = adc_resolution - 1;
    }
    adc_sensitivity = adc_sensitivity / 1000;
    const max_adc_count = Math.pow(2, adc_resolution) - 1;
    const measured_adc = (adc_count / max_adc_count) / adc_gain;
    const force = (measured_adc / adc_sensitivity) * load_cell_capacity;
    return force;
  }
  
  /**
   * Converts file data from a given path to a blob URL.
   * @param {string} path - Relative path from the application's base path to the file.
   * @returns {string} A blob URL representing the file's data.
   */
  data2blobUrl(path) {
    return URL.createObjectURL(new Blob([fs.readFileSync(app_path+'\\'+path)]));
  }
  
  /**
   * Converts top, right, bottom, and left margins into x and y coordinates.
   * @param {number} cont_width - Container width.
   * @param {number} cont_height - Container height.
   * @param {number} width - Element width.
   * @param {number} height - Element height.
   * @param {number} top - Top margin.
   * @param {number} right - Right margin.
   * @param {number} bottom - Bottom margin.
   * @param {number} left - Left margin.
   * @returns {Array} Array containing x and y coordinates.
   */
  trbl2xy(cont_width, cont_height, width, height, top, right, bottom, left) {
    var x = 0;
    var y = 0;

    if(!isUndefined(left)) {
      x = left;
    } else if(!isUndefined(right)) {
      x = cont_width - width - right;
    }
    if(!isUndefined(top)) {
      y = top;
    } else if(!isUndefined(bottom)) {
      y = cont_height - height - bottom;
    }
    return [x, y];
  }

  /**
   * Generates a CSV string from an simple object containing arrays of values.
   * Each key in the object represents a column in the CSV. This function handles uneven array lengths by filling missing values with an empty string.
   * @param {Object} data - The object containing arrays of data. Each key will be a column header.
   * @param {string} [delimiter=','] - The delimiter to use for separating entries in the CSV (defaults to a comma).
   * @returns {string} The generated CSV as a string, with each row representing an entry and each column representing data from the corresponding key in the input object.
   */
  simpleObj2Csv(data, delimiter = ',') {
    const keys = Object.keys(data);
    let csv_content = keys.join(delimiter) + '\n';

    const maxEntries = Math.max(...keys.map(function(key) {return data[key].length;} ));
    for(let i = 0; i < maxEntries; i++) {
      let row = keys.map(function(key) { return (i < data[key].length) ? data[key][i] : ''; }).join(delimiter);
      csv_content += row + '\n';
    }

    return csv_content;
  }
  
  /**
   * Converts a 2D array into a CSV string format.
   * @param {Array} data - An array of arrays to be converted into CSV format.
   * @param {string} [delimiter=','] - The delimiter to separate the values in the CSV.
   * @returns {string} The formatted CSV string.
   */
  simpleArray2Csv(data, delimiter = ',') {
    let csv_content = '';
    const maxEntries = Math.max(...data.map(function(e) {return e.length;} ));
    for(let i = 0; i < maxEntries; i++) {
      let row = data.map(function(e) { return (i < e.length) ? e[i] : ''; }).join(delimiter);
      csv_content += row + '\n';
    }

    return csv_content;
  }
}

exports.PRDC_JSLAB_LIB_CONVERSION = PRDC_JSLAB_LIB_CONVERSION;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={device-gamepad.js}]
/**
 * @file JSLAB library device gamepad submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for gamepad.
 */
class PRDC_JSLAB_DEVICE_GAMEPAD {
  
  /**
   * Initializes the gamepad device instance.
   * @param {Object} jsl - Reference to the main JSLAB object.
   * @param {string} id - Unique identifier for the gamepad.
   * @param {number} [dt=10] - Data reading interval in milliseconds.
   */
  constructor(jsl, id, dt = 10) {
    var obj = this;
    this.jsl = jsl;
    this.id = id;
    this.active = false;
    this.data;
    
    this.read_gamepad_loop;
    this.read_gamepad_dt = dt;
    
    this._checkGamepadFun = function() {
      obj._checkGamepad();
    };
    this.jsl.context.addEventListener("gamepadconnected", obj._checkGamepadFun);
    
    this.jsl.addForCleanup(this, function() {
      obj.close();
    });
    
    this._checkGamepad();
  }

  /**
   * Checks if the gamepad is connected and updates its state.
   */
  _checkGamepad() {
    var gamepad = this._getGamepad();
    if(gamepad) {
      if(!this.active) {
        this._onConnect();
      }
    }
  }


  /**
   * Retrieves the gamepad object if available.
   * @returns {Gamepad|boolean} The gamepad object if found, otherwise false.
   */
  _getGamepad() {
    var gamepads = this.jsl.env.navigator.getGamepads();
    for(let i = 0; i < gamepads.length; i++) {
      var gamepad = gamepads[i];
      if(gamepad != null) {
        if(gamepad.id == this.id) {
          return gamepad.toJSON();
        }
      }
    }
    return false;
  }
  
  /**
   * Handles gamepad connection events.
   */
  _onConnect() {
    var obj = this;
    
    // Read loop
    this.detect_gamepad_loop = clearIntervalIf(this.detect_gamepad_loop);
    this.active = true;
    clearIntervalIf(this.read_gamepad_loop);
    this.read_gamepad_loop = setInterval(function() {
      var gamepad = obj._getGamepad();
      if(gamepad) {
        if(gamepad.connected) {
          obj._onData(gamepad);
        } else {
          obj._onDisconnect();
        }
      } else {
        obj._onDisconnect();
      }
    }, this.read_gamepad_dt);
    
    if(this.jsl.format.isFunction(this.onConnectCallback)) {
      this.onConnectCallback();
    }
  }

  /**
   * Handles gamepad disconnection events.
   */
  _onDisconnect() {
    this.read_gamepad_loop = clearIntervalIf(this.read_gamepad_loop);
    this.active = false;
    this._checkGamepad();
    if(this.jsl.format.isFunction(this.onDisconnectCallback)) {
      this.onDisconnectCallback();
    }
  }

  /**
   * Handles incoming gamepad data.
   * @param {Gamepad} gamepad - The connected gamepad object.
   */
  _onData(gamepad) {
    this.data = gamepad;
    if(this.jsl.format.isFunction(this.onDataCallback)) {
      this.onDataCallback(gamepad);
    }
  }

  /**
   * Sets the callback function to handle incoming gamepad data.
   * @param {Function} callback - Function to execute when data is received.
   */
  setOnData(callback) {
    if(this.jsl.format.isFunction(callback)) {
      this.onDataCallback = callback;
    }
  }
  
  /**
   * Sets the callback function for gamepad connection events.
   * @param {Function} callback - Function to execute on connection.
   */
  setOnConnect(callback) {
    if(this.jsl.format.isFunction(callback)) {
      this.onConnectCallback = callback;
      if(this.active) {
        this.onConnectCallback();
      }
    }
  }
  
  /**
   * Sets the callback function for gamepad disconnection events.
   * @param {Function} callback - Function to execute on disconnection.
   */
  setOnDisconnect(callback) {
    if(this.jsl.format.isFunction(callback)) {
      this.onDisconnectCallback = callback;
    }
  }

  /**
   * Cleans up the gamepad instance and stops data reading.
   */
  close() {
    this.active = false;
    this.read_gamepad_loop = clearIntervalIf(this.read_gamepad_loop);
    this.jsl.context.removeEventListener("gamepadconnected", this._checkGamepadFun);
  }
}

exports.PRDC_JSLAB_DEVICE_GAMEPAD = PRDC_JSLAB_DEVICE_GAMEPAD;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={device.js}]
/**
 * @file JSLAB library device submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */


var { PRDC_JSLAB_DEVICE_GAMEPAD } = require('./device-gamepad');
 
/**
 * Class for JSLAB device submodule.
 */
class PRDC_JSLAB_LIB_DEVICE {
  
  /**
   * Constructs a device submodule object with access to JSLAB's device functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
    
    this._camera_resolutions = [
      { "label": "4K (UHD)", "width": 3840, "height": 2160, "ratio": "16:9" },
      { "label": "1080p (FHD)", "width": 1920, "height": 1080, "ratio": "16:9" },
      { "label": "720p (HD)", "width": 1280, "height": 720, "ratio": "16:9" },
      { "label": "480p (VGA)", "width": 640, "height": 480, "ratio": "4:3" },
      { "label": "360p (nHD)", "width": 640, "height": 360, " ratio": "16:9" },
      { "label": "240p (QVGA)", "width": 320, "height": 240, "ratio": "4:3" },
      { "label": "144p (QCIF)", "width": 176, "height": 144, "ratio": "4:3" },
    ];
  }

  /**
   * Checks if a specific driver is installed on the system.
   * @param {string} driver_name - Name of the driver to check.
   * @returns {boolean} True if the driver is found, false otherwise.
   */
  checkDriver(driver_name){
    var val = this.jsl.env.execSync('driverquery');
    if(val.state == 'success') {
      var output = val.data.split(/[\r\n]+/);
      var output_lc = output.map(function(x) { return x.toLowerCase(); });
      if(!Array.isArray(driver_name)) {
       driver_name = [driver_name];
      }
      driver_name = driver_name.map(function(x) { return x.toLowerCase(); });
      var data_out = [];
      for(var i = 0; i < driver_name.length; i++) {
        var idx = output_lc.map(function(x) { return x.startsWith(driver_name[i]); }).findIndex(function(x) { return x == true; });
        if(idx >= 0) {
          data_out[i] = output[idx];
        } else {
          data_out[i] = '';
        }
      }
      if(data_out.every(function(x) { return x.length; })) {
        if(this.jsl.debug) {
          this.jsl.env.disp('@checkDriver: ' + data_out);
        }
        return true; 
      } else {
        return false; 
      }
    } else {
      if(this.jsl.debug) {
        this.jsl.env.error('@checkDriver: ' + val.data);
      }
      return false; 
    }
  }

  /**
   * Checks if the drivers for FTDI devices are installed.
   * @returns {boolean} True if the drivers are found, false otherwise.
   */
  checkDriverFTDI() {
    return this.checkDriver(['FTDIBUS', 'FTSER2K']);
  }
 
  /**
   * Checks if the drivers for Silicon Labs CP210x USB to UART bridge are installed.
   * @returns {boolean} True if the drivers are found, false otherwise.
   */
  checkDriverCP210x() {
    return this.checkDriver('silabser');
  }
 
  /**
   * Checks if the drivers for CH340 USB to serial converter are installed.
   * @returns {boolean} True if the drivers are found, false otherwise.
   */
  checkDriverCH340() {
    return this.checkDriver('CH341SER_A64');
  }

  /**
   * Check if Arduino CLI is available.
   * @returns {boolean} True if available.
   */
  checkArduino() {
    try {
      var output = this.jsl.env.execSync('arduino-cli -h', { stdio: 'pipe' });
      return true;
    } catch(err) {
      this.jsl.env.error('@checkArduino: '+language.string(224));
    }
  }
  
  /**
   * Compile Arduino project.
   * @param {string} dir - Project directory.
   * @returns {Object|boolean} Compilation result or false on error.
   */
  compileArduino(dir) {
    var config_file = this.jsl.env.pathJoin(dir, 'config.json');
    if(!this.jsl.env.checkFile(config_file)) {
      this.jsl.env.error('@compileArduino: '+language.string(225));
      return false;
    }
    
    this.checkArduino();
    try {
      var config = JSON.parse(this.jsl.env.readFileSync(config_file))
      var build_property_str = '';
      if(config.build_property) {
        build_property_str = `--build-property "${config.build_property}"`;
      }
      var output = this.jsl.env.spawnSync(`arduino-cli compile --json -b "${config.b}" ${build_property_str} "${dir}"`, {
        shell: true,
        encoding: 'utf8',
        stdio: 'pipe'
      });
      return this.parseArduinoOtuput(output);
    } catch(err) {
      this.jsl.env.error('@compileArduino: Error: '+err.toString());
    }
  }
 
  /**
   * Upload Arduino project.
   * @param {string} dir - Project directory.
   * @param {string} [port] - Optional port.
   * @returns {Object|boolean} Upload result or false on error.
   */
  uploadArduino(dir, port) {
    var config_file = this.jsl.env.pathJoin(dir, 'config.json');
    if(!this.jsl.env.checkFile(config_file)) {
      this.jsl.env.error('@uploadArduino: '+language.string(225));
      return false;
    }
    
    this.checkArduino();
    try {
      var config = JSON.parse(this.jsl.env.readFileSync(config_file));
      var build_property_str = '';
      if(config.build_property) {
        build_property_str = `--build-property "${config.build_property}"`;
      }
      var port_str = '';
      if(port) {
        port_str = `-p "${port}"`;
      } else if(config.port) {
        port_str = `-p "${config.port}"`;
      }
      var output = this.jsl.env.spawnSync(`arduino-cli compile --json -u -t -b "${config.b}" ${build_property_str} ${port_str} "${dir}"`, {
        shell: true,
        encoding: 'utf8',
        stdio: 'pipe'
      });
      return this.parseArduinoOtuput(output);
    } catch(err) {
      this.jsl.env.error('@uploadArduino: Error: '+err.toString());
    }
  }
  
  /**
   * Parses Arduino output from stdout or stderr.
   * @param {object} output
   * @returns {object}
   */
  parseArduinoOtuput(output) {
    var data_string;
    if(output.stdout) {
      data_string = output.stdout;
    } else if(output.stderr) {
      data_string = output.stderr;
    }
    
    var data = JSON.parse(data_string);
    if(!data.success) {
      this.jsl.env.warn('@parseArduinoOtuput: Compile failed!');
      this.jsl.env.disp(`@parseArduinoOtuput: Compiler error:
${this.jsl.format.replaceEditorLinks(data.compiler_err)}`);
    }
    return data;
  }
  
  /**
   * Retrieves the current state of all connected gamepads.
   * @returns {Object[]} An array of connected gamepad objects.
   */
  getGamepads() {
    return this.jsl.env.navigator.getGamepads()
      .filter((g) => !isNull(g))
      .map(g => g.toJSON());
  }
 
  /**
   * Registers a callback function to be called when a gamepad is connected.
   * @param {Function} callback - The function to execute when a gamepad connects.
   */
  onGamepadConnected(callback) {
    var obj = this;
    var listener = function(e) {
      if(e.gamepad) {
        e.gamepad = e.gamepad.map(g => g.toJSON());
      }
      callback(e);
    };
    this.jsl.env.context.addEventListener("gamepadconnected", listener);
    this.jsl.addForCleanup(this, function() {
      obj.jsl.env.context.removeEventListener("gamepadconnected", listener);
    });
  }
 
  /**
   * Registers a callback function to be called when a gamepad is disconnected.
   * @param {Function} callback - The function to execute when a gamepad disconnects.
   */
  onGamepadDisconnected(callback) {
    var obj = this;
    var listener = function(e) {
      if(e.gamepad) {
        e.gamepad = e.gamepad.map(g => g.toJSON());
      }
      callback(e);
    };
    this.jsl.env.context.addEventListener("gamepaddisconnected", listener);
    this.jsl.addForCleanup(this, function() {
      obj.jsl.env.context.removeEventListener("gamepaddisconnected", listener);
    });
  }
 
  /**
   * Retrieves a specific gamepad by its ID.
   * @param {number} id - The index of the gamepad to retrieve.
   * @param {number} dt - Data reading interval in milliseconds.
   * @returns {PRDC_JSLAB_DEVICE_GAMEPAD} The corresponding gamepad object.
   */
  getGamepad(id, dt) {
    return new PRDC_JSLAB_DEVICE_GAMEPAD(this.jsl, id, dt);
  }
   
  /**
   * Retrieves a list of available webcam (video input) devices.
   * @returns {Object[]} A promise that resolves to an array of video input devices.
   */
  async getWebcams() {
    var devices = await this.jsl.env.navigator.mediaDevices.enumerateDevices();
    return devices
      .filter(device => device.kind === 'videoinput')
      .map(device => device.toJSON());
  }

  /**
   * Retrieves a list of available microphone (audio input) devices.
   * @returns {Object[]} A promise that resolves to an array of audio input devices.
   */
  async getMicrophones() {
    var devices = await this.jsl.env.navigator.mediaDevices.enumerateDevices();
    return devices
      .filter(device => device.kind === 'audioinput')
      .map(device => device.toJSON());
  }
 
  /**
   * Retrieves a list of available audio output devices.
   * @returns {Object[]} A promise that resolves to an array of audio output devices.
   */
  async getAudioOutputs() {
    var devices = await this.jsl.env.navigator.mediaDevices.enumerateDevices();
    return devices
      .filter(device => device.kind === 'audiooutput')
      .map(device => device.toJSON());
  }
 
  /**
   * Opens a new window to display the webcam feed from the specified device.
   * @param {string} device_id - The unique identifier of the webcam device to use.
   * @returns {Promise<WebcamResult>} An object containing the window instance, video element, and media stream.
   */
  async webcam(device_id) {
    var win = await openWindowBlank();
    win.setTitle('Webcam');
    win.document.body.innerHTML += '<video id="video"></video>';
    var dom = win.document.getElementById('video');
    Object.assign(dom.style, {
      position: 'absolute',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      width: '100%',
      height: '100%',
      objectFit: 'contain'
    });
    try {
      var constraints = {
        video: { deviceId: { exact: device_id } },
        audio: false
      };
      var stream = await this.jsl.env.navigator.mediaDevices.getUserMedia(constraints);
    } catch(err) {
      this.jsl._console.log(err, constraints);
      this.jsl.env.error('@capture: '+language.string(222));
    }
    dom.srcObject = stream;
    dom.play();
    this.jsl.addForCleanup(this, function() {
      stream.getTracks().forEach(track => track.stop());
      dom.srcObject = null;
    });
    return { win, dom, stream };
  }
  
   
  /**
   * Initiates webcam video capture.
   * @param {Object} opts - Configuration options for webcam capture.
   * @param {function} frameCallback - Callback invoked with each frame's image data buffer.
   * @param {function} [editCallback] - Optional callback to edit each frame before processing.
   */
  webcamCapture(opts, frameCallback, editCallback) {
    opts.type = 'webcam';
    this.capture(opts, frameCallback, editCallback);
  }
   
  /**
   * Retrieves desktop sources from the current environment.
   * @returns {DesktopSource[]} An array of desktop sources.
   */
  getDesktopSources() {
    return this.jsl.env.getDesktopSources();
  }
   
  /**
   * Displays the available desktop sources by generating and injecting HTML elements for each source.
   * @returns {void}
   */
  showDesktopSources() {
    var html = '';
    var sources = this.jsl.env.getDesktopSources();
    for(source of sources) {
      var { width, height } = source.thumbnail.getSize();
      html += '<div style="padding:10px; margin: 10px; border: #ccc 1px solid; border-radius: 5px;"><div><b>Name:</b> '+source.name+'</div><div><b>Id:</b> '+source.id+'</div><div><b>DisplayId:</b> '+source.display_id+'</div><img style="padding-top: 10px; width:'+width+'px; height:'+height+'px;" src="'+source.thumbnail.toDataURL()+'"></img></div>';
    }
    this.jsl.env.disp(html);
  }
  
  /**
   * Initiates desktop screen capture.
   * @param {Object} opts - Configuration options for desktop capture.
   * @param {function} frameCallback - Callback invoked with each frame's image data buffer.
   * @param {function} [editCallback] - Optional callback to edit each frame before processing.
   */
  desktopCapture(opts, frameCallback, editCallback) {
    opts.type = 'desktop';
    this.capture(opts, frameCallback, editCallback);
  }
  
  /**
   * Captures media frames based on the provided options.
   * @param {Object} opts - Configuration options for capturing.
   * @param {string} opts.id - The ID of the media source.
   * @param {string} opts.type - Type of capture ('webcam' or 'desktop').
   * @param {function} frameCallback - Callback invoked with each frame's image data buffer.
   * @param {function} [editCallback] - Optional callback to edit each frame before processing.
   * @returns {Object} An object containing control functions and resources for the capture session.
   * @returns {function} return.stop - Function to stop the capture.
   * @returns {CanvasRenderingContext2D} return.ctx - The 2D rendering context of the OffscreenCanvas.
   * @returns {OffscreenCanvas} return.offscreenCanvas - The OffscreenCanvas used for rendering frames.
   * @returns {MediaStreamTrack} return.videoTrack - The video track being captured.
   * @returns {MediaStreamTrackProcessor} return.trackProcessor - The processor for the video track.
   * @returns {ReadableStreamDefaultReader} return.reader - Reader for the media stream.
   */
  async capture(opts, frameCallback, editCallback) {
    var { id, type, ...otherOpts } = opts;

    var active = true;
    var constraints;

    // Define media constraints based on capture type
    if(type === 'webcam') {
      constraints = {
        video: { 
          deviceId: { exact: id },
          ...otherOpts
        },
        audio: false
      };
    } else if(type === 'desktop') {
      constraints = {
        video: {
          mandatory: {
            chromeMediaSource: 'desktop',
            chromeMediaSourceId: id,
            ...otherOpts
          }
        },
        audio: false
      };
    }

    // Obtain media stream
    if(isEmptyString(id)) {
      this.jsl.env.error('@capture: '+language.string(222));
    }
    
    try {
      var stream = await this.jsl.env.navigator.mediaDevices.getUserMedia(constraints);
    } catch(err) {
      this.jsl._console.log(err);
      this.jsl._console.log(constraints);
      this.jsl.env.error('@capture: '+language.string(222));
    }

    var videoTrack = stream.getVideoTracks()[0];
    var settings = videoTrack.getSettings();

    var width = settings.width || 1280;
    var height = settings.height || 720;

    // Initialize OffscreenCanvas with retrieved width and height
    var offscreenCanvas = new OffscreenCanvas(width, height);
    var ctx = offscreenCanvas.getContext('2d', {willReadFrequently: true});

    /**
     * Stops the frame capture by setting active to false.
     */
    function stop() {
      active = false;
    }

    /**
     * Continuously reads frames from the media stream, processes them, and invokes callbacks.
     */
    async function getFrames() {
      while(active) {
        var { value, done } = await reader.read();
        if(done) {
          break;
        }

        var frame = value;
        ctx.drawImage(frame, 0, 0, width, height);

        if(typeof editCallback === 'function') {
          editCallback(frame, width, height);
        }

        var imageData = ctx.getImageData(0, 0, width, height);
        frameCallback(imageData.data.buffer, width, height, frame);
        frame.close();
      }

      // Cleanup after capturing frames
      videoTrack.stop();
      reader.releaseLock();
      stream.getTracks().forEach(track => track.stop());
    }

    // Initialize MediaStreamTrackProcessor and reader
    var trackProcessor = new MediaStreamTrackProcessor({ track: videoTrack });
    var reader = trackProcessor.readable.getReader();

    this.jsl.addForCleanup(this, stop);

    // Start processing frames
    getFrames();

    // Return control functions and resources
    return { stop, ctx, offscreenCanvas, videoTrack, trackProcessor, reader };
  }
  
  /**
   * Gets supported camera resolutions for a specific device.
   * @param {string} device_id - The camera device ID.
   * @returns {Promise<Array<Object>>} Supported resolutions.
   */
  async getCameraResolutions(device_id) {
    const resolutions = [];
    for(const resolution of this._camera_resolutions) {
      var constraints = {
        audio: false,
        video: {
          deviceId: { exact: device_id },
          width: { exact: resolution.width },
          height: { exact: resolution.height }
        }
      };
      try {
        const stream = await this.jsl.env.navigator.mediaDevices.getUserMedia(constraints);
        stream.getTracks().forEach(track => track.stop());
        resolutions.push(resolution);
      } catch(err) {
        this.jsl._console.log(err);
      };
    }
    return resolutions;
  }
  
  /**
   * Displays an audio waveform on the canvas.
   * @param {string} device_id - The microphone device ID.
   * @param {number} [fftSize=2048] - FFT size for analysis.
   * @returns {Object} Controls to stop or reset the waveform.
   */
  async showAudioWaveform(device_id, fftSize =  2048) {
    var obj = this;

    var win = await openCanvas();
    win.setTitle('Audio Waveform');
    var draw_loop;
    var audio_ctx = new AudioContext();
    var analyser = audio_ctx.createAnalyser();
    analyser.fftSize = fftSize;
    var buffer_length = analyser.frequencyBinCount;
    var data = new Uint8Array(buffer_length);

    var canvas = win.canvas;
    var canvas_ctx = canvas.getContext("2d");
    var canvas_width = 1000;
    var canvas_height = 500;
    canvas.width = canvas_width;
    canvas.height = canvas_height;
    canvas.style.width = '100vw';
    canvas.style.height = '100vh';
    
    canvas_ctx.lineWidth = 1;
    canvas_ctx.strokeStyle = "#000";
    var slice_width = canvas_width / buffer_length;
    reset();
    
    var constraints = {
      audio: {
        deviceId: { exact: device_id }
      }
    };
    var stream = await this.jsl.env.navigator.mediaDevices.getUserMedia(constraints);
    var source = audio_ctx.createMediaStreamSource(stream);
    source.connect(analyser);
    
    _update();

    function _update() {
      draw_loop = obj.jsl.context.requestAnimationFrame(function() {
        _update();
      });

      analyser.getByteTimeDomainData(data);

      canvas_ctx.clearRect(0, 0, canvas_width, canvas_height);
      canvas_ctx.beginPath();

      let x = 0;
      for(let i = 0; i < buffer_length; i++) {
        const v = data[i] / 128.0;
        const y = v * (canvas_height / 2);

        if(i === 0) {
          canvas_ctx.moveTo(x, y);
        } else {
          canvas_ctx.lineTo(x, y);
        }

        x += slice_width;
      }
      
      canvas_ctx.lineTo(canvas_width, canvas_height / 2);
      canvas_ctx.stroke();
    }

    function stop() {
      obj.jsl.context.cancelAnimationFrame(draw_loop);
      reset();
    }

    function reset() {
      canvas_ctx.clearRect(0, 0, canvas_width, canvas_height);
      canvas_ctx.beginPath();
      canvas_ctx.moveTo(0, canvas_height/2);
      canvas_ctx.lineTo(canvas_width, canvas_height / 2);
      canvas_ctx.stroke();
    }
    
    this.jsl.addForCleanup(this, stop);
    
    return { win, stop, reset };
  }
  
  /**
   * Records video from the specified canvas element, webcam deviceId, or desktop sourceId and returns a MediaRecorder augmented with an async stopRecording() that finalizes and saves the file. 
   * @param {(HTMLCanvasElement|string)} source - Canvas element, webcam deviceId, or desktop sourceId to capture. 
   * @param {Object} [opts={}] - Optional settings: type ('canvas' | 'webcam' | 'desktop'), fps, mimeType, and videoBitsPerSecond. 
   * @returns {MediaRecorder} - MediaRecorder that streams the capture and provides a helper to stop and save.
   */
  async startVideoRecording(source, opts = {}) {
    var obj = this;
    var preferredMime = 'video/mp4;codecs="avc1.640028"';
    var fallbackMime  = 'video/webm;codecs=vp9,opus';

    var standardMimeType = MediaRecorder.isTypeSupported(preferredMime) ? 
      preferredMime : fallbackMime;
    
    var stream;
    if(opts.type == 'canvas') {
      stream = source.captureStream(opts.fps);
    } else {
      var constraints;
      if(opts.type === 'webcam') {
        constraints = {
          video: { 
            deviceId: { exact: source },
            ...opts.constrains_opts
          },
          audio: false
        };
      } else {
        constraints = {
          video: {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: source
            },
            ...opts.constrains_opts
          },
          audio: false
        };
      }
      try {
        stream = await this.jsl.env.navigator.mediaDevices.getUserMedia(constraints);
      } catch(err) {
        this.jsl._console.log(err);
        this.jsl._console.log(constraints);
        this.jsl.env.error('@startVideoRecording: '+language.string(222));
      }
    }

    var mimeType = opts.mimeType || standardMimeType;
    var ext = mimeType.includes('mp4') ? 'mp4' : 'webm';
    var recorder = new MediaRecorder(stream, {
      mimeType: mimeType,
      videoBitsPerSecond: opts.videoBitsPerSecond || 8_000_000
    });
    
    var chunks = [];
    recorder.ondataavailable = function(e) {
      chunks.push(e.data)
    }
    
    recorder.onstop = async function() {
      var blob = new Blob(chunks, { type: mimeType });
      var buffer = Buffer.from(await blob.arrayBuffer());

      var options = {
       title: language.currentString(236),
       buttonLabel: language.currentString(236),
       filters :[
        {name: ext, extensions: [ext]},
       ]
      };
      var video_path = obj.jsl.env.showSaveDialogSync(options);
      if(video_path) {
        obj.jsl.env.writeFileSync(video_path, buffer);
      }
    }
    
    var recording = true;
    recorder.start(1000);
    
    recorder.stopRecording = async function() {
      if(recording) {
        recording = false;
        recorder.stop();
      }
    }
    return recorder;
  }
}

exports.PRDC_JSLAB_LIB_DEVICE = PRDC_JSLAB_LIB_DEVICE;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={figures.js}]
/**
 * @file JSLAB library figures submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB figures submodule.
 */
class PRDC_JSLAB_LIB_FIGURES {
  
  /**
   * Initializes a new instance of the figures submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
    
    this._fonts_registred = false;
    this._fonts = [];
    this._fid = 0;
    this._pid = 0;
    this._html_figure = this.jsl.env.readFileSync(app_path + '/html/html_figure.html').toString();
    this._i_html_figure = this.jsl.env.readFileSync(app_path + '/html/i_html_figure.html').toString();
    this._io_html_figure = this.jsl.env.readFileSync(app_path + '/html/io_html_figure.html').toString();

    /**
     * Array of open figures.
     * @type {Array}
     */    
    this.open_figures = {};
    
    /**
     * Current active figure ID.
     * @type {Number}
     */
    this.active_figure = -1;
  }

  /**
   * Opens or updates a figure with specified options.
   * @param {Number} id Identifier for the figure.
   * @returns {Number} The identifier of the opened or updated figure.
   */
  figure(fid) {
    if(!(fid >= 0) || !this.open_figures.hasOwnProperty(fid)) {
      if(!(fid >= 0)) {
        this._fid += 1;
        fid = this._fid;
      }
      this.open_figures[fid] = new PRDC_JSLAB_FIGURE(this.jsl, fid);
      this.open_figures[fid].init();
    } else {
      this.open_figures[fid].focus();
    }
    this._setActiveFigure(fid);
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
    return fid;
  }

  /**
   * Retrieves the figure object associated with the specified figure ID.
   * @param {string} fid - The identifier of the figure to retrieve.
   * @returns {(Object|boolean)} The figure object if found, otherwise `false`.
   */
  getFigure(fid) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid];
    } else {
      return false;
    }
  }

  /**
   * Retrieves the window of the figure object associated with the specified figure ID.
   * @param {string} fid - The identifier of the figure to retrieve.
   * @returns {(Object|boolean)} The figure object if found, otherwise `false`.
   */
  getFigureWindow(fid) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].win;
    } else {
      return false;
    }
  }
  
  /**
   * Retrieves current active figure object.
   * @returns {(Object|boolean)} The figure object if found, otherwise `false`.
   */
  getCurrentFigure() {
    if(this.open_figures.hasOwnProperty(this.active_figure)) {
      return this.open_figures[this.active_figure];
    } else {
      return false;
    }
  }

  /**
   * Retrieves current active figure object.
   * @returns {(Object|boolean)} The figure object if found, otherwise `false`.
   */
  gcf() {
    return this.getCurrentFigure();
  }
  
  /**
   * Retrieves the plot object for a specified figure ID.
   * @param {string} fid - The identifier of the figure to retrieve the plot for.
   * @returns {(Object|boolean)} The plot object if it exists, otherwise `false`.
   */
  getPlot(fid) {
    if(this.open_figures.hasOwnProperty(fid) && this.open_figures[fid].plot) {
      return this.open_figures[fid].plot;
    } else {
      return false;
    }
  }
  
  /**
   * Retrieves the plot object for a specified figure ID.
   * @param {string} fid - The identifier of the figure to retrieve the plot for.
   * @returns {(Object|boolean)} The plot object if it exists, otherwise `false`.
   */
  getAxes(fid) {
    return this.getPlot(fid);
  }
  
  /**
   * Retrieves plot from current active figure object.
   * @returns {(Object|boolean)} The figure object if found, otherwise `false`.
   */
  getCurrentPlot() {
    if(this.open_figures.hasOwnProperty(this.active_figure)) {
      return this.open_figures[this.active_figure].plot;
    } else {
      return false;
    }
  }

  /**
   * Retrieves plot from current active figure object.
   * @returns {(Object|boolean)} The figure object if found, otherwise `false`.
   */
  gcp() {
    return this.getCurrentPlot();
  }
  
  /**
   * Retrieves plot from current active figure object.
   * @returns {(Object|boolean)} The figure object if found, otherwise `false`.
   */
  getCurrentAxes() {
    return this.getCurrentPlot();
  }

  /**
   * Retrieves plot from current active figure object.
   * @returns {(Object|boolean)} The figure object if found, otherwise `false`.
   */
  gca() {
    return this.getCurrentPlot();
  }
  
  /**
   * Brings the specified figure to the foreground.
   * @param {number} fid - The ID of the figure to focus.
   * @returns {boolean|undefined} - Returns false if the figure ID is invalid.
   */
  focusFigure(fid) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].focus();
    } else {
      return false;
    }
  }
  
  /**
   * Sets the size of a specified figure.
   * @param {number} fid - The ID of the figure.
   * @param {number} width - The new width of the figure.
   * @param {number} height - The new height of the figure.
   * @returns {boolean|undefined} - Returns false if the figure ID is invalid.
   */
  setFigureSize(fid, width, height) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].setSize(width, height);
    } else {
      return false;
    }
  }
  
  /**
   * Sets the position of a specified figure.
   * @param {number} fid - The ID of the figure.
   * @param {number} left - The new left position of the figure.
   * @param {number} top - The new top position of the figure.
   * @returns {boolean|undefined} - Returns false if the figure ID is invalid.
   */
  setFigurePos(fid, left, top) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].setPos(left, top);
    } else {
      return false;
    }
  }
  
  /**
   * Sets the title of the specified figure.
   * @param {string} fid - The figure ID.
   * @param {string} title - The new title for the figure.
   * @returns {boolean|*} The result of setting the title, or false if the figure does not exist.
   */
  setFigureTitle(fid, title) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].setTitle(title);
    } else {
      return false;
    }
  }
  
  /**
   * Retrieves the size of a specified figure.
   * @param {number} fid - The ID of the figure.
   * @returns {Array|boolean} - Returns an array [width, height] or false if the figure ID is invalid.
   */
  getFigureSize(fid) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].getSize();
    } else {
      return false;
    }
  }
  
  /**
   * Retrieves the position of a specified figure.
   * @param {number} fid - The ID of the figure.
   * @returns {Array|boolean} - Returns an array [left, top] or false if the figure ID is invalid.
   */
  getFigurePos(fid) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].getPos();
    } else {
      return false;
    }
  }
  
  /**
   * Retrieves the media source id of a specified figure.
   * @param {number} fid - The ID of the figure.
   * @returns {String|boolean} - Returns Media soruce id or false if the figure ID is invalid.
   */
  getFigureMediaSourceId(fid) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].getMediaSourceId();
    } else {
      return false;
    }
  }

  /**
   * Starts video recording of a specified figure.
   * @param {number} fid - The ID of the figure.
   * @param {Object} - Optional settings. 
   * @returns {Object|boolean} - Returns recorder object or false if the figure ID is invalid.
   */
  startFigureVideoRecording(fid, opts) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].startVideoRecording(opts);
    } else {
      return false;
    }
  }
  
  /**
   * Closes a specified figure.
   * @param {number} fid - The ID of the figure to close.
   * @returns {boolean|undefined} - Returns false if the figure ID is invalid.
   */
  closeFigure(fid) {
    if(this.open_figures.hasOwnProperty(fid)) {
      return this.open_figures[fid].close();
    } else {
      return false;
    }
  }
  
  /**
   * Closes a figure or window by its identifier.
   * @param {number|string} id - The identifier of the figure or window to close. Use "all" to close all.
   * @param {string} [type='figure'] - The type of object to close ('figure' or 'window').
   */
  close(id, type = 'figure') {
    if(id == "all") {
      this.jsl.env.closeWindow(id);
    } else {
      if(type == 'window') {
        this.jsl.env.closeWindow(id);
      } else if(type == 'figure') {
        this.jsl.env.closeFigure(id);
      } 
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Opens a dialog for saving a figure in various formats.
   * @param {String} fid - The figure identifier.
   */
  async saveFigureDialog(fid) {
    let options = {
     title: language.currentString(143),
     defaultPath: fid + '.svg',
     buttonLabel: language.currentString(143),
     filters :[
      {name: 'svg', extensions: ['svg']},
      {name: 'pdf', extensions: ['pdf']},
      {name: 'png', extensions: ['png']},
      {name: 'jpg', extensions: ['jpg', 'jpeg']},
      {name: 'webp', extensions: ['webp']},
      {name: 'json', extensions: ['json']},
      {name: 'static html', extensions: ['html']},
      {name: 'interactive html', extensions: ['i.html']},
      {name: 'interactive offline html', extensions: ['io.html']}
     ]
    };
    var figure_path = this.jsl.env.showSaveDialogSync(options);
    if(figure_path) {
      await this.saveFigure(fid, figure_path);
    }
  }
  
  /**
   * Saves a figure to a specified path in various formats.
   * @param {String} fid - The figure identifier.
   * @param {String} figure_path - The path where the figure should be saved.
   * @param {Array} size - Optional dimensions [width, height] to use if saving as a PDF.
   */
  async saveFigure(fid, figure_path, size) {
    var pdf_flag = false;
    var html_flag = false;
    var ext = figure_path.split('.').pop();
    if(['svg', 'pdf', 'png', 'jpg', 'jpeg', 'webp', 'html', 'json'].includes(ext)) {
      if(ext == 'json' || figure_path.endsWith('.i.html') || figure_path.endsWith('.io.html')) {
        var data = this.open_figures[fid].context.plot.toJSON();
        if(figure_path.endsWith('.i.html')) {
          var html = this._i_html_figure.replaceAll('%title%', this.open_figures[fid].dom.title);
          data = html.replace('%figure_data%', data);
        } else if(figure_path.endsWith('.io.html')) {
          var html = this._io_html_figure.replaceAll('%title%', this.open_figures[fid].dom.title);
          data = html.replace('%figure_data%', data);
        }
        this.jsl.env.writeFileSync(figure_path, data);
        return;
      } else if(ext == 'jpg') {
        ext = 'jpeg';
      } else if(ext == 'pdf') {
        pdf_flag = true;
        ext = 'svg';
      } else if(ext == 'html') {
        html_flag = true;
        ext = 'svg';
      }
      
      var data_url = await this.open_figures[fid].context.plot.toImage(ext, size);
      var data;
      if(ext == 'svg') {
        if(html_flag) {
          var html = this._html_figure.replaceAll('%title%', this.open_figures[fid].dom.title);
          data = html.replace('%image_source%', data_url);
        } else {
          data = decodeURIComponent(data_url.replace('data:image/svg+xml,',''));
        }
        data = data.replace(/\bLatinModern\b/g, "LatinModernMath");
      } else {
        data_url = data_url.replace('data:image/png;base64,','');
        data_url = data_url.replace('data:image/jpeg;base64,','');
        data_url = data_url.replace('data:image/webp;base64,','');
        data = new Buffer(data_url, 'base64');
      }
      if(pdf_flag) {
        var pdf_data = await this._svg2pdf(fid, data, size);
        try {
          this.jsl.env.writeFileSync(figure_path, pdf_data);
        } catch(err) {
          this.jsl.env.error('@saveFigure: '+err.stack);
        }
      } else {
        try {
          this.jsl.env.writeFileSync(figure_path, data);
        } catch(err) {
          this.jsl.env.error('@saveFigure: '+err.stack);
        }
      }
    } else {
      this.jsl.env.error('@saveFigure: '+language.string(124));
    }
  }
  
  /**
   * Sets the label for the x-axis of the active figure.
   * @param {String} label - The label for the x-axis.
   */
  legend(state) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.legend(state);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Sets the label for the x-axis of the active figure.
   * @param {String} label - The label for the x-axis.
   */
  xlabel(label) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.xlabel(label);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Sets the label for the y-axis of the active figure.
   * @param {String} label - The label for the y-axis.
   */
  ylabel(label) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.ylabel(label);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Sets the label for the z-axis of the active figure.
   * @param {String} label - The label for the z-axis.
   */
  zlabel(label) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.zlabel(label);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Sets the title of the active figure.
   * @param {String} label - The title text.
   */
  title(label) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.title(label);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Sets the xlim of the active figure.
   * @param {String} lim - x limits.
   */
  xlim(lim) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.xlim(lim);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Sets the ylim of the active figure.
   * @param {String} lim - y limits.
   */
  ylim(lim) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.ylim(lim);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Sets the zlim of the active figure.
   * @param {String} lim - z limits.
   */
  zlim(lim) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.zlim(lim);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Adjusts the view based on azimuth and elevation angles.
   * @param {number} azimuth - The azimuth angle.
   * @param {number} elevation - The elevation angle.
   */
  view(azimuth, elevation) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.view(azimuth, elevation);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }

  /**
   * Adjusts the zoom based on zoom factor.
   * @param {number} factor - The zoom factor.
   */
  zoom(factor) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.zoom(factor);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Applies the specified style to the active figure's plot axis.
   * @param {Object} style - The style configuration to apply to the axis.
   */
  axis(style) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.axis(style);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Prints the currently active figure to a file.
   * @param {String} filename - The name of the file where the figure should be printed.
   * @param {Object} options - Printing options.
   */
  async printFigure(filename, options) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      await this.open_figures[this.active_figure].plot.print(filename, options);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Plots data on the active figure.
   * @param {Array} traces - Data traces to plot.
   * @param {Object} options - Configuration options for plotting.
   * @returns {Number} The plot identifier.
   */
  plot(traces, options) {
    var fid = this.active_figure;
    if(options == undefined) {
      options = {};
    } else {
      if(options.hasOwnProperty(fid)) {
        fid = options.fid;
      }
    }
    this._pid += 1;
    var id = this._pid;
    
    fid = this.figure(fid);
    this.open_figures[fid]._newPlot(id, traces, options);
    
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
    return this.open_figures[fid].plot;
  }

  /**
   * Updates plot data by delegating to the `update` method.
   * @param {Object} traces - The trace data to be updated in the plot.
   * @param {number} N - The data length or index for updating the plot.
   */
  updatePlot(traces, N) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.update(data);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Updates plot data by id by delegating to the `updateById` method.
   * @param {Object|Object[]} data - Trace update object(s) to apply to the active plot.
   */
  updatePlotById(data) {
    if(this.active_figure >= 0 && this.open_figures[this.active_figure].plot) {
      this.open_figures[this.active_figure].plot.updateById(data);
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Hides figure menu.
   */
  hideFigureMenu() {
    if(this.active_figure >= 0) {
      this.open_figures[this.active_figure].hideMenu();
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  
  /**
   * Shows figure menu.
   */
  showFigureMenu() {
    if(this.active_figure >= 0) {
      this.open_figures[this.active_figure].showMenu();
    }
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Loads figure from JSON file
   * @param {String} file_path - Absolute or relative path to the JSON file of figure.
   * @param {Number} id Identifier for the figure.
   * @returns {Number} The identifier of the opened or updated figure.
   */
  loadJsonFigure(fid, file_path) {
    if(!file_path) {
      var options = {
        title: language.currentString(247),
        buttonLabel: language.currentString(231)
      };
      file_path = this.jsl.env.showOpenDialogSync(options);
      if(file_path === undefined) {
        this.jsl.env.error('loadJsonFigure: '+language.string(132)+'.');
        return false;
      } else {
        file_path = file_path[0];
      }
    }    
    if(!this.jsl.file_system.existFile(file_path)) {
      this.jsl.env.error('@loadJsonFigure: '+language.string(248));
      return false;
    }
    var data = JSON.parse(this.jsl.env.readFileSync(file_path).toString());

    this._pid += 1;

    fid = this.figure(fid);
    this.open_figures[fid]._fromJSON(this._pid, data);
    return fid;
  }
  
  /**
   * Updates the language of the text elements within all open figures.
   */
  _updateLanguage() {
    Object.values(this.open_figures).forEach(function(figure) {
      figure._updateLanguage(false);
    });
  }
  
  /**
   * Sets the specified figure as the active figure.
   * @param {string} fid - The identifier of the figure to set as active.
   */
  _setActiveFigure(fid) {
    if(this.open_figures.hasOwnProperty(fid)) {
      this.active_figure = fid;
    } else {
      this.active_figure = -1;
    }
  }

  /**
   * Closes a figure identified by the given ID and updates the active figure if needed.
   * @param {string} id - The identifier of the figure to close.
   */
  _closedFigure(fid) {
    if(this.open_figures.hasOwnProperty(fid)) {
      var new_fid = -1;
      if(this.active_figure == fid) {
        var fids = Object.keys(this.open_figures);
        var N = fids.length;
        if(N > 1) {
          if(fids[N-1] !== fid) {
            new_fid = fids[N-1];
          } else {
            new_fid = fids[N-2];
          }
        }
        this._setActiveFigure(new_fid);
      }
      delete this.open_figures[fid];
    }
  }
  
  /**
   * Reads and returns font data from a specified path.
   * @param {String} font_path Path to the font file.
   * @returns {Buffer} The font data.
   */
  _getFontData(font_path) {
    try {
      return this.jsl.env.readFileSync(font_path);
    } catch(err) {
      this.jsl.env.error('@getFontData: '+err.stack);
    }
    return false;
  }
  /**
   * Registers fonts for use in figures.
   */
  _registerFonts() {
    if(!this._fonts_registred) {
      this._fonts.push(this._getFontData(
        app_path+'/font/roboto-v20-latin-ext_latin_greek-ext_greek_cyrillic-ext_cyrillic-regular.ttf'
      ));
      this._fonts.push(this._getFontData(
        app_path+'/font/latinmodern-math.otf'
      ));
      this._fonts_registred = true;
    }
  }

  /**
   * Converts SVG data to PDF format.
   * @param {String} fid - The figure identifier.
   * @param {String} data - The SVG data to convert.
   * @param {Array} size - The dimensions [width, height] to use for the PDF.
   * @returns {Promise<Buffer>} A promise that resolves with the generated PDF data.
   */
  _svg2pdf(fid, data, size) {
    var obj = this;
    this._registerFonts();
    var plot_cont = this.open_figures[fid].dom.querySelector('#figure-content .plot-cont');
    var width = plot_cont.clientWidth;
    var height = plot_cont.clientHeight;
    if(typeof size != 'undefined') {
      width = size[0];
      height = size[1];
    }
    
    return new Promise(function(resolve) {
      var doc = new obj.jsl.env.PDFDocument({
        size: [width, height]
      });
      doc.registerFont('Roboto', obj._fonts[0]);
      doc.registerFont('LatinModernMath', obj._fonts[1]);
      obj.jsl.env.SVGtoPDF(doc, data, 0, 0, {
        width: width,
        height: height,
        assumePt: true
      });
      var buf = [];
      doc.on('data', buf.push.bind(buf));
      doc.on('end', function() {
        var pdfData = Buffer.concat(buf);
        resolve(pdfData);
      });
      doc.end();
    });
  }
}

exports.PRDC_JSLAB_LIB_FIGURES = PRDC_JSLAB_LIB_FIGURES;

/**
 * Represents an individual figure within the JSLAB environment, providing detailed configuration and interaction capabilities.
 */
class PRDC_JSLAB_FIGURE {
  
  #jsl;
  
  /**
   * Initializes a new instance of a JSLAB figure.
   * @param {Object} jsl Reference to the main JSLAB object.
   * @param {Number} id Identifier for the figure.
   * @param {Object} options Configuration options for the figure.
   */
  constructor(jsl, fid) {
    var obj = this;
    
    this.#jsl = jsl;
    this.fid = fid;
    
    this.wid;
    
    this.context;
    this.dom;
    this.fig_ready = false;
    this.opened = false;
    
    this.plot = undefined;

    this.ready = new Promise((resolve) => {
      obj._readyResolve = resolve;
    });
    
    this.wid = this.#jsl.windows.openWindow('figure.html');
    this.#jsl.windows.open_windows[this.wid].onClosed = function() {
      obj.#jsl.figures._closedFigure(obj.fid);
    }
  }
  
  /**
   * Initializes figure.
   */
  async init() {
    if(!this.opened) {
      await this.#jsl.windows.open_windows[this.wid].ready;
      await this._onReady();
      this.opened = true;
    }
  }
  
  /**
   * Brings the figure window to the foreground.
   */
  async focus() {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.windows.open_windows[this.wid].focus();
  }

  /**
   * Sets the size of the window.
   * @param {number} width - The desired width of the window.
   * @param {number} height - The desired height of the window.
   * @returns {Promise} - Resolves when the window size is set.
   */
  async setSize(width, height) {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.windows.open_windows[this.wid].setSize(width, height);
  }
  
  /**
   * Sets the position of the window.
   * @param {number} left - The desired left position of the window.
   * @param {number} top - The desired top position of the window.
   * @returns {Promise} - Resolves when the window position is set.
   */
  async setPos(left, top) {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.windows.open_windows[this.wid].setPos(left, top);
  }
  
  /**
   * Sets the title of the current window.
   * @param {string} title - The new title for the window.
   * @returns {Promise<*>} A promise that resolves when the title is set.
   */
  async setTitle(title) {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.windows.open_windows[this.wid].setTitle(title);
  }
  
  /**
   * Retrieves the size of the window.
   * @returns {Promise<Array>} - Resolves with an array [width, height].
   */
  async getSize() {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.windows.open_windows[this.wid].getSize();
  }
  
  /**
   * Retrieves the position of the window.
   * @returns {Promise<Array>} - Resolves with an array [left, top].
   */
  async getPos() {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.windows.open_windows[this.wid].getPos();
  }

  /**
   * Retrieves the media source id of the figure.
   * @returns {String} - Media source id.
   */
  async getMediaSourceId() {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.windows.open_windows[this.wid].getMediaSourceId();
  }

  /**
   * Starts video recording of the figure.
   * @param {Object} - Optional settings. 
   * @returns {Object|boolean} - Returns recorder object.
   */
  async startVideoRecording(opts) {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.windows.open_windows[this.wid].startVideoRecording(opts);
  }
  
  /**
   * Closes the window.
   * @returns {Promise} - Resolves when the window is closed.
   */
  async close() {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.windows.open_windows[this.wid].close();
  }
  
  /**
   * Hides figure menu.
   */
  hideMenu() {
    if(this.dom) {
      this.dom.getElementById('figure-menu-button').style.display = 'none';
      this.dom.getElementById('figure-menu-container').style.display = 'none';
    }
  }
  
  /**
   * Shows figure menu.
   */
  showMenu() {
    if(this.dom) {
      this.dom.getElementById('figure-menu-button').style.display = ''; 
      this.dom.getElementById('figure-menu-container').style.display = ''; 
    }
  }
  
  /**
   * Creates a new plot in the figure.
   * @param {Number} id Identifier for the new plot.
   * @param {Array} traces Data traces for the plot.
   * @param {Object} options Plot configuration options.
   */
  _newPlot(id, traces, options) {
    if(this.plot) {
      this.plot.remove();
    }
    this.plot = new PRDC_JSLAB_PLOT(this.#jsl, this.fid, id, traces, options);
    if(this.fig_ready) {
      this.plot._onFigureReady();
    }
  }
  
  /**
   * Creates a new plot in the figure based on JSON file data.
   * @param {Number} id Identifier for the new plot.
   * @param {Array} data Data for the plot.
   */
  async _fromJSON(id, data) {
    if(this.plot) {
      this.plot.remove();
    }
    this.plot = new PRDC_JSLAB_PLOT(this.#jsl, this.fid, id);
    this.plot.fromJSON(data);
    if(this.fig_ready) {
      this.plot._onFigureReady();
    }
  }
  
  /**
   * Method called when the figure is ready. Initializes interactive elements within the figure's DOM.
   * @param {Element} dom The DOM element associated with the figure.
   */
  async _onReady() {
    var obj = this;
    this.fig_ready = true;
    this.win = this.#jsl.windows.open_windows[this.wid];
    this.context = this.win.context;
    
    this.dom = this.context.document;
    
    this.context.addEventListener("resize", function() {
      if(obj.#jsl.figures.open_figures.hasOwnProperty(obj.fid)) {
        obj._onResize();
      }
    });
    
    this.dom.title = "Figure " + this.fid + " - JSLAB | PR-DC";

    // Menu showing
    var menu_button = this.dom.getElementById('figure-menu-button');
    var menu = this.dom.getElementById('figure-menu-container');

    menu_button.addEventListener('click', function (e) {
      e.stopPropagation();
      menu.classList.toggle('active');
      menu_button.classList.toggle('active');
    });

    this.dom.addEventListener('click', function (e) {
      if(!menu.contains(e.target) && !menu_button.contains(e.target)) {
        menu.classList.remove('active');
        menu_button.classList.remove('active');
      }
    });
  
    var interval;
    menu.addEventListener('mouseenter', function() {
      clearInterval(interval);
      menu.classList.add('hovered');
      menu_button.classList.add('hovered');
    });

    menu.addEventListener('mouseleave', function() {
      interval = setTimeout(function() {
        menu.classList.remove('hovered');
        menu_button.classList.remove('hovered');
      }, 300);
    });

    // Menu buttons
    this.dom.getElementById('save-as-menu')
        .addEventListener('click', function() {
      obj.#jsl.figures.saveFigureDialog(obj.fid);
    });
    this.dom.getElementById('zoom-menu')
        .addEventListener('click', function() {
      var btn = obj.dom.querySelector('a[data-attr="dragmode"][data-val="zoom"]');
      if(btn) {
        btn.click();
      }
    });
    this.dom.getElementById('zoom-in-menu')
        .addEventListener('click', function() {
      var btn = obj.dom.querySelector('a[data-attr="zoom"][data-val="in"]');
      if(btn) {
        btn.click();
      }
    });
    this.dom.getElementById('zoom-out-menu')
        .addEventListener('click', function() {
      var btn = obj.dom.querySelector('a[data-attr="zoom"][data-val="out"]');
      if(btn) {
        btn.click();
      }
    });
    this.dom.getElementById('pan-menu')
        .addEventListener('click', function() {
      var btn = obj.dom.querySelector('a[data-attr="dragmode"][data-val="pan"]');
      if(btn) {
        btn.click();
      }
    });
    this.dom.getElementById('rotate-menu')
        .addEventListener('click', function() {
      var btn = obj.dom.querySelector('a[data-attr="dragmode"][data-val="orbit"]');
      if(btn) {
        btn.click();
      }
    });
    this.dom.getElementById('fit-menu')
        .addEventListener('click', function() {
      var btn = obj.dom.querySelector('a[data-attr="zoom"][data-val="auto"]');
      if(btn) {
        btn.click();
      }
    });
    this.dom.getElementById('reset-menu')
        .addEventListener('click', function() {
      obj.#jsl.ploter.updatePlotLayout(obj.plot.fid);
    });
    this.dom.getElementById('pan-menu-3d')
        .addEventListener('click', function() {
      var btn = obj.dom.querySelector('a[data-attr="scene.dragmode"][data-val="pan"]');
      if(btn) {
        btn.click();
      }
    });
    this.dom.getElementById('rotate-menu-3d')
        .addEventListener('click', function() {
      var btn = obj.dom.querySelector('a[data-attr="scene.dragmode"][data-val="orbit"]');
      if(btn) {
        btn.click();
      }
    });
    this.dom.getElementById('fit-menu-3d')
        .addEventListener('click', function() {
      var btn = obj.dom.querySelector('a[data-attr="resetDefault"]');
      if(btn) {
        btn.click();
      }
    });
    this.dom.getElementById('reset-menu-3d')
        .addEventListener('click', function() {
      obj.#jsl.ploter.updatePlotLayout(obj.plot.fid);
    });
    
    this._readyResolve(true);
    if(this.plot) {
      await this.plot._onFigureReady();   
    }
  }
 
  /**
   * Handles figure resize events by updating the plot layout to fit the new dimensions.
   */
  _onResize() {
    if(this.plot) {
      this.plot._onResize();
    }
  }
}

/**
 * Represents an individual plot within the JSLAB environment, holding configuration details and facilitating interaction with the plot.
 */
class PRDC_JSLAB_PLOT {
  
  #jsl;
  
  /**
   * Constructs a PRDC_JSLAB_PLOT instance with specified plot data and configuration.
   * @param {Object} jsl Reference to the main JSLAB object.
   * @param {Number} fid Identifier for the figure containing this plot.
   * @param {Number} id Unique identifier for this plot.
   * @param {Array} traces Data traces to be displayed in the plot.
   * @param {Object} options Configuration options for the plot.
   */
  constructor(jsl, fid, id, traces = [], options = []) {
    var obj = this;
    
    this.#jsl = jsl;
    this.fid = fid;
    this.id = id;
    this.traces = traces;
    this.options = options;
    
    this.title_val;
    this.xlabel_val;
    this.ylabel_val;
    this.zlabel_val;
    this.xlim_val;
    this.ylim_val;
    this.zlim_val;
    this.view_val = [37.5+180, 30];
    this.zoom_val = 1;
    this.axis_style_val;
    this.json_val;
    this.legend_state_val;
    
    this.plot_ready = false;
    this.lim_update = false;
    
    this.ready = new Promise((resolve) => {
      obj._readyResolve = resolve;
    });
  }

  /**
   * Sets the label for the x-axis of the plot.
   * @param {String} label Label text for the x-axis.
   */
  legend(state) {
    this.legend_state_val = state;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }
  
  /**
   * Sets the label for the x-axis of the plot.
   * @param {String} label Label text for the x-axis.
   */
  xlabel(label) {
    this.xlabel_val = label;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }

  /**
   * Sets the label for the y-axis of the plot.
   * @param {String} label Label text for the y-axis.
   */
  ylabel(label) {
    this.ylabel_val = label;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }

  /**
   * Sets the label for the z-axis of the plot.
   * @param {String} label Label text for the z-axis.
   */
  zlabel(label) {
    this.zlabel_val = label;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }
  
  /**
   * Sets the title of the plot.
   * @param {String} label Title text for the plot.
   */
  title(label) {
    this.title_val = label;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }
  
  /**
   * Sets the limits for the x-axis of the plot.
   * @param {String} lim Limits for the x-axis.
   */
  xlim(lim) {
    this.lim_update = true;
    this.xlim_val = lim;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }
  
  /**
   * Sets the limits for the y-axis of the plot.
   * @param {String} lim Limits for the y-axis.
   */
  ylim(lim) {
    this.lim_update = true;
    this.ylim_val = lim;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }
  
  /**
   * Sets the limits for the z-axis of the plot.
   * @param {String} lim Limits for the z-axis.
   */
  zlim(lim) {
    this.lim_update = true;
    this.zlim_val = lim;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }
  
  /**
   * Adjusts the view based on azimuth and elevation angles.
   * @param {number} azimuth - The azimuth angle.
   * @param {number} elevation - The elevation angle.
   */
  view(azimuth, elevation) {
    this.view_val = [azimuth, elevation];
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }
  
  /**
   * Adjusts the zoom based on factor.
   * @param {number} factor - The zoom factor.
   */
  zoom(factor) {
    this.zoom_val = factor;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }
  
  /**
   * Sets the axis style value and updates the plot layout if the plot is ready.
   * @param {Object} style - The style configuration to set for the axis.
   */
  axis(style) {
    this.axis_style_val = style;
    if(this.plot_ready) {
      this.#jsl.ploter.updatePlotLayout(this.fid);
    }
  }
  
  /**
   * Sets the plot data from JSON.
   * @param {Array} data Data for the plot.
   */
  fromJSON(data) {
    this.json_val = data;
    if(this.plot_ready) {
      this.#jsl.ploter.fromJSON(data);
    }
  }
  
  /**
   * Adds a print job to the queue and prints it if the system is ready.
   * @param {String} filename - The filename for the print job.
   * @param {Object} options - Options for the print job.
   */
  async print(filename, options) {
    await this.#jsl.promiseOrStoped(this.ready);
    var type = 'png';
    var size;
    if(options) {
      if(options.type) {
        type = options.type;
      }
      if(options.size) {
        size = options.size;
      }
    }
    await this.#jsl.figures.saveFigure(this.fid, filename+'.'+type, size);
  }
  
  /**
   * Updates plot data by delegating to the `updateData` method.
   * @param {Object} traces - The trace data to be updated in the plot.
   * @param {number} N - The data length or index for updating the plot.
   */
  update(traces, N) {
    this.#jsl.ploter.updateData(this.fid, traces, N);
  }

  /**
   * Updates plot data by delegating to the `updateDataById` method.
   * @param {Object|Object[]} data - Trace update object(s) addressed by `id`.
   */
  updateById(data) {
    this.#jsl.ploter.updateDataById(this.fid, data);
  }
  
  /**
   * Removes the plot from the figure, cleaning up any resources associated with it.
   */
  remove() {
    if(this.plot_ready) {
      this.#jsl.ploter.remove(this.fid);
    }
  }
  
  /**
   * Called when the figure containing this plot is ready, allowing for final adjustments or updates before displaying.
   */
  async _onFigureReady() {
    if(this.json_val) {
      await this.#jsl.ploter.fromJSON(this.fid, this.json_val);
      this.plot_ready = true;
      this._readyResolve(true);
    } else {
      await this.#jsl.ploter.plot(this.fid);
      this.plot_ready = true;
      this.#jsl.ploter.updatePlotLayout(this.fid);
      this._readyResolve(true);
    }
  }
  
  /**
   * Handles plot resize events, updating the plot layout to accommodate new dimensions.
   */
  _onResize() {
    this.#jsl.ploter.onResize(this.fid);
  }
}
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={file-system.js}]
/**
 * @file JSLAB library file system submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB file system submodule.
 */
class PRDC_JSLAB_LIB_FILE_SYSTEM {
  
  /**
   * Initializes a new instance of the file system submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }

  /**
   * Reads the content of a file at the specified path.
   * @param {string} file_path Path to the file.
   * @returns {(Buffer|string|false)} The content of the file or false in case of an error.
   */
  readFile(...args) {
    return this.jsl.env.readFileSync(...args);
  }

  /**
   * Extract substring from file using range
   * @param {string} filepath - Path to file
   * @param {Array} range - Character range [start, end]
   * @returns {string} - Extracted substring
   */
  getContentFromCharRange(filepath, range) {
    const fileContent = this.readFile(filepath, "utf8");
    const [start, end] = range;
    return fileContent.slice(start, end);
  }

  /**
   * Writes data to a specified file synchronously. This method should overwrite the file if it already exists.
   * @param {string} file_path The path to the file where data will be written.
   * @param {Buffer|string} data The data to write to the file.
   * @returns {boolean} Returns true if the file was written successfully, false if an error occurred.
   */
  writeFile(...args) {
    return this.jsl.env.writeFileSync(...args);
  }
  
  /**
   * Deletes a specified file synchronously.
   * @param {string} file_path The path to the file that should be deleted.
   * @returns {boolean} Returns true if the file was deleted successfully, false if an error occurred.
   */
  deleteFile(file_path) {
    return this.jsl.env.rmSync(file_path);
  }
  
  /**
   * Reads the contents of a directory synchronously.
   * @param {string} folder The path to the directory.
   * @returns {string[]|false} An array of filenames or false in case of an error.
   */
	readDir(...args) {
    return this.jsl.env.readDir(...args);
  }
  
  /**
   * Deletes a specified file synchronously.
   * @param {string} file_path The path to the file that should be deleted.
   * @returns {boolean} Returns true if the file was deleted successfully, false if an error occurred.
   */
  deleteDir(file_path) {
    return this.jsl.env.rmSync(file_path);
  }

  /**
   * Moves a file from source to destination.
   * @param {string} source - The path to the source file.
   * @param {string} destination - The path to the destination file.
   */
  moveFile(source, destination) {
    if(comparePaths(source, destination)) {
      return true;
    }
    try {
      this.jsl.env.copyFileSync(source, destination);
      this.jsl.env.rmSync(source);
      return true;
    } catch(err) {
      this.jsl.error('@moveFile: ' + err);
    }
  }

  /**
   * Copies a file from source to destination.
   * @param {string} source - The path to the source file.
   * @param {string} destination - The path to the destination file.
   */
  copyFile(source, destination) {
    if(comparePaths(source, destination)) {
      return true;
    }
    try {
      this.jsl.env.copyFileSync(source, destination);
      return true;
    } catch(err) {
      this.jsl.error('@copyFile: ' + err);
    }
  }

  /**
   * Lists files in a specified folder, optionally filtering by extension.
   * @param {string} folder Path to the folder.
   * @param {string} ext File extension filter.
   * @returns {string[]|void} Array of file paths matching the extension in the specified folder.
   */
  filesInFolder(folder, ext) {
    var obj = this;
    var files = this.jsl.env.readDir(folder);
    if(Array.isArray(files)) {
      return files
        .filter(function(file) { 
          if(!ext) return file.includes('.');
          return file.endsWith('.' + ext);
        })
        .map(function(file) { return obj.jsl.env.pathJoin(folder, file); });
    } else {
      this.jsl.env.error('@filesInFolder: '+language.string(128)+': ' + folder);
    }
    return false;
  }

  /**
   * Lists all files in a specified folder
   * @param {string} folder Path to the folder.
   * @returns {string[]|void} Array of file names.
   */
  allFilesInFolder(folder) {
    return this.jsl.env.readDir(folder).reduce((acc, file) => {
        const file_path = this.jsl.env.pathJoin(folder, file);
        return this.jsl.env.checkDirectory(file_path)
          ? acc.concat(this.allFilesInFolder(file_path))
          : acc.concat(file);
      }, []);
  }
  
  /**
   * Opens a dialog for the user to choose a file, synchronously.
   * @param {Object} options Configuration options for the dialog.
   * @returns {string|string[]} The selected file path(s) or an empty array if canceled.
   */
  chooseFile(options) {
    var file_path = this.jsl.env.showOpenDialogSync(options);
    if(file_path === undefined) {
      this.jsl.env.error('@chooseFile: '+language.string(126));
      return [];
    }
    return file_path;
  }
  
  /**
   * Opens a dialog for the user to choose a folder, synchronously.
   * @param {Object} options Configuration options for the dialog.
   * @returns {string|string[]} The selected folder path(s) or an empty array if canceled.
   */
  chooseFolder(options_in) {
    var options = {
      properties: ['openDirectory'],
      ...options_in
    };
    var file_path = this.jsl.env.showOpenDialogSync(options);
    if(file_path === undefined) {
      this.jsl.env.error('@chooseFolder: '+language.string(126));
      return [];
    }
    return file_path;
  }
  
  /**
   * Retrieves a default path based on a specified type.
   * @param {string} type Type of the default path (e.g., 'root', 'documents').
   * @returns {string} The default path for the specified type.
   */
  getDefaultPath(type) {
    return this.jsl.env.getDefaultPath(type);
  }

  /**
   * Opens the specified folder in the system's file manager.
   * @param {string} filepath Path to the folder.
   */
  openFolder(filepath) {
    this.jsl.env.openFolder(filepath);
  }

  /**
   * Creates a directory at the specified path if it does not already exist.
   * This method delegates the directory creation task to the environment's makeDirectory function.
   * @param {string} directory - The path where the directory will be created.
   * @returns {boolean} True if the directory was successfully created or already exists, false if an error occurred.
   */
  makeDirectory(directory) {
    return this.jsl.env.makeDirectory(directory);
  }
  
  /**
   * Alias for makeDirectory. Creates a directory at the specified path if it does not already exist.
   * This method delegates the directory creation task to the environment's makeDirectory function.
   * @param {string} directory - The path where the directory will be created.
   * @returns {boolean} True if the directory was successfully created or already exists, false if an error occurred.
   */
  mkdir(directory) {
    return this.jsl.env.makeDirectory(directory);
  }
  
  /**
   * Opens the specified directory in the system's file manager. Alias for `openFolder`.
   * @param {string} filepath Path to the directory.
   */
  openDir(filepath) {
    this.jsl.env.openDir(filepath);
  }

  /**
   * Shows the specified folder in the system's file manager. Alias for `openFolder`.
   * @param {string} filepath Path to the folder.
   */
  showFolder(filepath) {
    this.jsl.env.openFolder(filepath);
  }

  /**
   * Shows the specified directory in the system's file manager. Alias for `openDir`.
   * @param {string} filepath Path to the directory.
   */
  showDir(filepath) {
    this.jsl.env.openDir(filepath);
  }

  /**
   * Opens the program's root folder in the system's file manager.
   */
  openProgramFolder() {
    this.jsl.env.openFolder(this.jsl.env.getDefaultPath('root'));
  }
 
  /**
   * Shows the specified file in its containing folder within the system's file manager.
   * @param {string} filepath Path to the file.
   */
  showFileInFolder(filepath) {
    this.jsl.env.showFileInFolder(filepath);
  }

  /**
   * Shows the specified file in its containing directory within the system's file manager. Alias for `showFileInFolder`.
   * @param {string} filepath Path to the file.
   */
  showFileInDir(filepath) {
    this.jsl.env.showFileInDir(filepath);
  }
  
  /**
   * Reads a CSV file and returns a promise that resolves with the parsed data.
   * @param {string} filePath - Path to the CSV file.
   * @param {string} delimiter - Delimiter used in the CSV file (e.g., ',', ';', '\t').
   * @returns {Array<Object>} - Parsed CSV data as an array of objects.
   */
  readcsv(filePath, delimiter = ',', hasHeader = false) {
    var data = this.jsl.env.readFileSync(filePath, 'utf-8');
    var lines = data.split('\n').filter(function(line) { return line.trim() !== ''; });
    var headers = lines[0].split(delimiter).map(function(header) { return header.trim(); });
    var result = [];
    
    if(hasHeader) {
      // If there is a header, parse as objects
      var headers = lines[0].split(delimiter).map(header => header.trim());
      for(let i = 1; i < lines.length; i++) {
        var row = lines[i].split(delimiter).map(function(cell) { return cell.trim(); });
        var row_object = {};
        headers.forEach(function(header, index) {
          row_object[header] = row[index];
        });
        result.push(row_object);
      }
    } else {
      // If no header, parse as arrays
      for(let i = 0; i < lines.length; i++) {
        var row = lines[i].split(delimiter).map(function(cell) { return cell.trim(); });
        result.push(row);
      }
    }
    
    return result;
  } 
  
  /**
   * Checks if the specified file exists.
   * @param {string} file - The path to the file to check.
   */
  checkFile(file) {
    return this.jsl.env.checkFile(file);
  }
  
  /**
   * Checks if the specified file exists.
   * @param {string} file - The path to the file to check.
   */
  existFile(file) {
    return this.checkFile(file);
  }
  
  /**
   * Checks if the specified directory exists.
   * @param {string} directory - The path to the directory to check.
   */
  checkDirectory(directory) {
    return this.jsl.env.checkDirectory(directory);
  }
  
  /**
   * Checks if the specified directory exists.
   * @param {string} directory - The path to the directory to check.
   */
  existDirectory(directory) {
    return this.checkDirectory(directory);
  }
  
  /**
   * Recursively copies a directory from the source path to the destination path.
   * @param {string} src - The source directory path.
   * @param {string} dest - The destination directory path.
   */
  copyDir(src, dest) {
    // Check if the source directory exists
    if(!this.jsl.env.checkDirectory(src)) {
      this.jsl.env.error('@copyDir: '+language.string(173));
    }

    // Create the destination directory if it doesn't exist
    this.jsl.env.makeDirectory(dest);

    // Read all the files and directories in the source directory
    const entries = this.jsl.env.readDir(src, { withFileTypes: true });

    // Iterate through each entry (file or directory)
    for(const entry of entries) {
      const src_path = this.jsl.env.pathJoin(src, entry.name);
      const dest_path = this.jsl.env.pathJoin(dest, entry.name);

      if(entry.isDirectory()) {
        // Recursively copy directories
        this.copyDir(src_path, dest_path);
      } else {
        // Copy files
        this.jsl.env.copyFileSync(src_path, dest_path);
      }
    }
  }
  
  /**
   * Copies a folder from the source path to the destination path.
   * @param {string} src - The source folder path.
   * @param {string} dest - The destination folder path.
   */
  copyFolder(src, dest) {
    return this.copyDir(src, dest);
  }

  /**
   * Copies a directory from the source path to the destination path.
   * @param {string} src - The source directory path.
   * @param {string} dest - The destination directory path.
   */
  cp(src, dest) {
    return this.copyDir(src, dest);
  }

  /**
   * Copies a 7z archive from the source path to the destination path, extracts it, and removes the archive.
   * @param {string} src - The source 7z archive path.
   * @param {string} dest - The destination directory path.
   */
  copyDir7z(src, dest) {
    var name = this.jsl.path.pathFileName(src);
    var ext = this.jsl.path.pathExtName(src);
    var filePath = this.jsl.env.pathJoin(dest, name + ext);
    
    this.jsl.env.copyFileSync(src, filePath);
    this.jsl.env.execSync(`${this.jsl.env.bin7zip } x "${filePath}" -o"${dest}" -y`);
    this.jsl.env.rmSync(filePath);
  }
}

exports.PRDC_JSLAB_LIB_FILE_SYSTEM = PRDC_JSLAB_LIB_FILE_SYSTEM;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={format.js}]
/**
 * @file JSLAB library format submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB format submodule.
 */
class PRDC_JSLAB_LIB_FORMAT {
  
  /**
   * Initializes a new instance of the format submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }

  /**
   * Retrieves the MIME type based on the file extension.
   * @param {string} filePath - The path to the file.
   * @returns {string} The corresponding MIME type.
   */
  getContentType(file_path) {
    const mime_types = {
      // Text files
      '.html': 'text/html',
      '.htm': 'text/html',
      '.js': 'text/javascript',
      '.mjs': 'text/javascript',
      '.css': 'text/css',
      '.json': 'application/json',
      '.txt': 'text/plain',
      '.xml': 'application/xml',

      // Image files
      '.png': 'image/png',
      '.jpg': 'image/jpeg',
      '.jpeg': 'image/jpeg',
      '.gif': 'image/gif',
      '.bmp': 'image/bmp',
      '.webp': 'image/webp',
      '.svg': 'image/svg+xml',
      '.ico': 'image/x-icon',

      // Audio files
      '.mp3': 'audio/mpeg',
      '.wav': 'audio/wav',
      '.ogg': 'audio/ogg',
      '.m4a': 'audio/mp4',

      // Video files
      '.mp4': 'video/mp4',
      '.avi': 'video/x-msvideo',
      '.mov': 'video/quicktime',
      '.wmv': 'video/x-ms-wmv',
      '.flv': 'video/x-flv',
      '.webm': 'video/webm',
      '.mkv': 'video/x-matroska',

      // Application files
      '.pdf': 'application/pdf',
      '.zip': 'application/zip',
      '.rar': 'application/vnd.rar',
      '.7z': 'application/x-7z-compressed',
      '.tar': 'application/x-tar',
      '.gz': 'application/gzip',
      '.exe': 'application/vnd.microsoft.portable-executable',
      '.msi': 'application/x-msdownload',
      '.doc': 'application/msword',
      '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      '.xls': 'application/vnd.ms-excel',
      '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      '.ppt': 'application/vnd.ms-powerpoint',
      '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      '.eot': 'application/vnd.ms-fontobject',
      '.ttf': 'font/ttf',
      '.woff': 'font/woff',
      '.woff2': 'font/woff2',

      // Model files
      '.glb': 'model/gltf-binary',
      '.gltf': 'model/gltf+json',
      '.obj': 'application/octet-stream', // Common for OBJ, but can vary
      '.fbx': 'application/octet-stream',

      // Others
      '.csv': 'text/csv',
      '.md': 'text/markdown',
      '.apk': 'application/vnd.android.package-archive',
      '.iso': 'application/x-iso9660-image',
      '.sh': 'application/x-sh',
      '.bat': 'application/x-msdownload',
      '.php': 'application/x-httpd-php',
      '.asp': 'application/x-aspx',
      '.aspx': 'application/x-aspx',
      '.jsp': 'application/java-archive',
      '.rb': 'application/x-ruby',
      '.py': 'application/x-python-code',
      '.swift': 'application/x-swift',
      '.lua': 'application/x-lua',
    };

    const ext = String(this.jsl.env.pathExtName(file_path)).toLowerCase();
    return mime_types[ext] || 'application/octet-stream';
  }
  
  /**
   * Formats the given byte count into a readable string.
   * @param {Number} bytes Number of bytes.
   * @param {Number} [decimals=2] Number of decimal places to include in the formatted string.
   * @returns {String} Formatted bytes string with appropriate unit.
   */
  formatBytes(bytes, decimals = 2) {
    if(!+bytes) return '0 Bytes';

    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const units = ['Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(dm))} ${units[i]}`;
  }

  /**
   * Formats the given bits per second (bps) into a readable string.
   * @param {Number} bps Number of bits per second.
   * @param {Number} [decimals=2] Number of decimal places to include in the formatted string.
   * @returns {String} Formatted bits per second string with appropriate unit.
   */
  formatBPS(bps, decimals = 2) {
    if(!+bps) return '0 bps';

    const k = 1000;
    const dm = decimals < 0 ? 0 : decimals;
    const units = ["bps","kbps", "Mbps", "Gbps", "Tbps", "Pbps", "Ebps", "Zbps", "Ybps"];
    
    const i = Math.floor(Math.log(bps) / Math.log(k));

    return `${parseFloat((bps / Math.pow(k, i)).toFixed(dm))} ${units[i]}`;
  }

  /**
   * Formats a number with metric prefixes (k, M, G, etc.) based on its value.
   * @param {Number} number The number to format.
   * @param {Number} [decimals=2] Number of decimal places to include in the formatted string.
   * @returns {String} Formatted number string with metric prefix.
   */
  formatPrefix(number, decimals = 2) {
    if(!+number) return '0 ';

    const k = 1000;
    const dm = decimals < 0 ? 0 : decimals;
    const units = ["","k", "M", "G", "T", "P", "E", "Z", "Y"];
    
    const i = Math.floor(Math.log(number) / Math.log(k));

    return `${parseFloat((number / Math.pow(k, i)).toFixed(dm))} ${units[i]}`;
  }
  /**
   * Formats a number to a specified number of decimal places.
   * @param {Number} number The number to format.
   * @param {Number} [decimals=2] The number of decimal places.
   * @returns {String} The formatted number as a string.
   */
  formatNum(number, decimals = 2) {
    return Number(number).toFixed(decimals);
  }

  /**
   * Formats a floating-point number to have a fixed number of significant digits.
   * @param {number} number - The number to format.
   * @param {number} [digits=1] - The number of significant digits.
   * @returns {string} The formatted number as a string.
   */
  formatFloatDigits(number, digits = 1) {
    var precision = digits-(number.toString().split(".")[0]).length;
    if(precision < 0) {
      precision = 0;
    }
    return round(number, precision, true);
  }

  /**
   * Clips a number to a specified value based on a condition.
   * @param {number} number - The number to clip.
   * @param {number} control_number - The reference number for the clipping condition.
   * @param {number} clip_value - The value to clip to.
   * @param {boolean} [direction=true] - The direction of clipping (true for max, false for min).
   * @returns {number} The clipped number.
   */
  clip(number, control_number, clip_value, direction = true) {
    if((direction && number >= control_number) || (!direction && number <= control_number)) {
      number = clip_value;
    }
    return number;
  }

  /**
   * Clips a height value to a specified range.
   * @param {number} value - The value to clip.
   * @param {number} [min=0] - The minimum value of the range.
   * @param {number} [max=100] - The maximum value of the range.
   * @returns {number} The clipped height value.
   */
  clipHeight(value, min = 0, max = 100) {
    value = Number(value);
    if(isNaN(value)) {
      value = min;
    } else if(value > max) {
      value = max;
    } else if(value < min) {
      value = min;
    }
    return value;
  }

  /**
   * Retrieves the field names (keys) of the given object.
   * @param {Object} obj - The object from which to extract keys.
   * @returns {string[]} An array containing the keys of the object.
   */
  fieldnames(obj) {
    return Object.keys(obj);
  }

  /**
   * Replaces all occurrences of a specified substring within a string.
   * @param {string} str - The original string.
   * @param {string} old_string - The substring to be replaced.
   * @param {string} new_string - The substring to replace with.
   * @returns {string} The resulting string after replacements.
   */
  strrep(str, old_string, new_string) {
    return str.replaceAll(old_string, new_string);
  }  

  /**
   * Clips a value to a specified range.
   * @param {number} value - The value to clip.
   * @param {number} [min=0] - The minimum value of the range.
   * @param {number} [max=100] - The maximum value of the range.
   * @returns {number} The clipped value.
   */
  clipVal(value, min = 0, max = 100) {
    value = Number(value);
    if(isNaN(value)) {
      value = min;
    } else if(value > max) {
      value = max;
    } else if(value < min) {
      value = min;
    }
    return value;
  }

  /**
   * Rounds a number to a fixed number of decimal places, but only if it's a floating point number.
   * @param {Number} value The value to round.
   * @param {Number} p The number of decimal places to round to.
   * @returns {Number} The rounded number, or the original number if it wasn't a float.
   */
  toFixedIf(value, p) {
    return +parseFloat(value).toFixed(p);
  }

  /**
   * Provides a replacer function for JSON.stringify() to prevent circular references.
   * @returns {Function} A replacer function that can be used with JSON.stringify to handle circular references.
   */
  getCircularReplacer() {
    const seen = new WeakSet();
    return function(key, value) {
      if(typeof value === 'object' && value !== null) {
        if(seen.has(value)) {
          return;
        }
        seen.add(value);
      }
      return value;
    };
  }

  /**
   * Determines if the provided value is NaN.
   * @param {*} value - The value to check.
   * @returns {boolean} True if the value is NaN, false otherwise.
   */
  isNaN(value) {
    if(isArray(value)) {
      return mathjs_isNaN(value);
    } else {
      return this.jsl._isNaN(value);
    }
  }
  
  /**
   * Determines if the provided value is an object.
   * @param {*} value - The value to check.
   * @param {boolean} [ignore_array=false] - Whether to consider arrays as not objects.
   * @returns {boolean} True if the value is an object, false otherwise.
   */
  isObject(value, ignore_array) {
    if(ignore_array && Array.isArray(value)) {
      return false;
    }
    return typeof value === 'object' && value !== null;
  }
  
  /**
   * Determines if the provided value is a number.
   * @param {*} value - The value to check.
   * @returns {boolean} True if the value is a number, false otherwise.
   */
  isNumber(value) {
    return typeof value === 'number';
  }
  
  /**
   * Determines if the provided value is a string.
   * @param {*} value - The value to check.
   * @returns {boolean} True if the value is a string, false otherwise.
   */
  isString(value) {
    return typeof value === 'string';
  }
  
  /**
   * Checks if a string is empty or contains only whitespace.
   * @param {string} str - The string to check.
   * @returns {boolean} - True if the string is empty or contains only whitespace, otherwise false.
   */
  isEmptyString(str) {
    return typeof str === 'string' && str.trim().length === 0;
  }

  /**
   * Determines if the provided value is a function.
   * @param {*} value - The value to check 
   * @returns {boolean} True if the value is a function, false otherwise.
   */
  isFunction(value) {
    return typeof value === 'function';
  }
  
  /**
   * Determines if the provided value is an array.
   * @param {*} value - The value to check.
   * @returns {boolean} True if the value is an array, false otherwise.
   */
  isArray(value) {
    return Object.prototype.toString.call(value) === '[object Array]';
  }
  
  /**
   * Determines if the provided value is null.
   * @param {*} value - The value to check.
   * @returns {boolean} True if the value is null, false otherwise.
   */
  isNull(value) {
    return value === null;
  }

  /**
   * Checks if an array is empty.
   * @param {Array} array - The array to check.
   * @returns {boolean} True if the array is empty, false otherwise.
   */
  isEmpty(array) {
    return !(typeof array == 'object' && array.length != 0);
  }

  /**
   * Checks if the given value(s) are infinite.
   * @param {number|number[]} value - The value or array of values to check.
   * @returns {boolean|boolean[]} - Returns true if infinite, otherwise false. Returns an array of booleans if input is an array.
   */
  isInfinity(value) {
    if(Array.isArray(value)) {
      return value.map((v) => v === Infinity || v === -Infinity);
    } else {
      return value === Infinity || value === -Infinity;
    }
  }
  
  /**
   * Checks if a variable is numeric.
   * @param {*} variable - The variable to check.
   * @returns {boolean} True if the variable is numeric, false otherwise.
   */
  isNumeric(variable) {
    return !isNaN(parseFloat(variable)) && isFinite(variable);
  }

  /**
   * Checks if the specified object has the given key.
   * @param {Object} object - The object to check for the presence of the key.
   * @param {string} key - The key to check for in the object.
   * @returns {boolean} - True if the object has the key, false otherwise.
   */
  hasKey(object, key) {
    return object.hasOwnProperty(key);
  }

  /**
   * Determines if the provided value is undefined.
   * @param {*} value - The value to check.
   * @returns {boolean} True if the value is undefined, false otherwise.
   */
  isUndefined(value) {
    return typeof value === 'undefined';
  }
  
  /**
   * Checks if a string is a valid UUID.
   * @param {string} str The string to check.
   * @returns {boolean} True if the string is a valid UUID, false otherwise.
   */
  isUUID(str) {
    var uuid_pattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-5][0-9a-f]{3}-[089ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return uuid_pattern.test(str);
  }

  /**
   * Normalizes an angle to the range of -180 to 180 degrees.
   * @param {number} angle - The angle to normalize.
   * @returns {number} The normalized angle.
   */
  normalizeAngle(angle) {
    return ((angle + 180) % 360 + 360) % 360 - 180;
  }

  /**
   * Normalizes an angle to the range of 0 to 360 degrees.
   * @param {number} angle - The angle to normalize.
   * @returns {number} The normalized angle.
   */
  normalizeAngle360(angle) {
     return (angle % 360 + 360) % 360;
  }

  /**
   * Normalizes latitude to the range of -90 to 90 degrees with specified precision.
   * @param {number} latitude - The latitude to normalize.
   * @param {number} precision - The precision of the normalization.
   * @returns {number} The normalized latitude.
   */
  normalizeLat(latitude, precision) {
    return round(Math.max(-90, Math.min(90, latitude)), precision);
  }

  /**
   * Normalizes longitude to the range of -180 to 180 degrees with specified precision.
   * @param {number} longitude - The longitude to normalize.
   * @param {number} precision - The precision of the normalization.
   * @returns {number} The normalized longitude.
   */
  normalizeLon(longitude, precision) {
    return round(normalizeAngle(longitude), precision);
  }

  /**
   * Checks a value for undefined and returns an empty string if it is undefined, otherwise returns the value.
   * @param {*} val - The value to check.
   * @returns {*} The original value if not undefined, otherwise an empty string.
   */
  checkUndefined(val) {
    if(val == undefined) {
      return '';
    } else {
      return val;
    }
  }
  
  /**
   * Pretty-prints data, converting it into a more readable format for display. Handles strings, objects, and other data types.
   * @param {*} data The data to pretty-print.
   * @returns {Array} An array containing the pretty-printed data as a string and a boolean indicating if the data was an object.
   */
  prettyPrint(data) {
    if(Array.isArray(data)) {
      return [this.safeStringify(data, 5), true];
    } else if(typeof data == 'object' && typeof data.toPrettyString == 'function') {
      return [data.toPrettyString(), false];
    } else if(typeof data == 'object' && typeof data.toSafeJSON == 'function') {
      return [this.safeStringify(data), true];
    } else if(typeof data == 'string') {
      return ["'"+data.replace(/\n/g, '<br/>')+"'", false];
    } else if(typeof data == 'object') {
      return [this.safeStringify(data), true];
    } else {
      return [String(data), false];
    }
  }


  /**
   * Converts an object to a JSON string if it is an object, otherwise returns the object as is.
   * @param {*} object - The object to stringify.
   * @returns {string|*} The JSON string representation of the object or the object itself if not an object.
   */
  stringify(object) {
    if(typeof object.toPrettyString === 'function') {
      return object.toPrettyString();
    }
    return JSON.stringify(object);
  }
  
  /**
   * Safely serializes an object into a JSON string, handling circular references and deep structures, with depth control.
   * It also escapes strings to prevent HTML injection.
   * @param {Object} data - The object to stringify.
   * @param {number} [depth_limit=3] - The maximum depth to traverse in the object, beyond which the traversal is stopped.
   * @returns {string} A JSON string representation of the object, with special handling for deep objects, circular references, and HTML escaping of strings.
   */
  safeStringify(data, depth_limit = 3) {
    if(data == null || typeof data != 'object') {
      return data;
    }
    if(typeof data.toPrettyString === 'function') {
      return data.toPrettyString();
    }
    if(typeof data.toSafeJSON === 'function') {
      return data.toSafeJSON();
    }
    if(data.hasOwnProperty('_safeStringifyDepth')) {
      depth_limit = data._safeStringifyDepth;
      delete data._safeStringifyDepth;
    }
    
    const seen = new WeakSet();

    function escapeString(str) {
      return str.replace(/[&<>"'`=\/]/g, function (s) {
        return ({
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;',
          '`': '&#x60;',
          '=': '&#x3D;',
          '/': '&#x2F;'
        })[s];
      });
    }

    function helper(value, depth, path) {
      if(depth > depth_limit) {
        return '{...}';
      }

      if(value !== null && typeof value === 'object') {
        if(seen.has(value)) {
          return '[Circular Reference]';
        }
        seen.add(value);

        // Handle arrays separately
        if(Array.isArray(value)) {
          return value.map((item, index) => helper(item, depth + 1, path.concat(index)));
        }

        const result = {};

        // Retrieve property descriptors without invoking getters
        const descriptors = Object.getOwnPropertyDescriptors(value);
        const keys = Reflect.ownKeys(descriptors); // Includes symbol properties

        for(const key of keys) {
          const descriptor = descriptors[key];
          const newPath = path.concat(key); // Build the full path

          try {
            if('value' in descriptor) {
              // Data property; process the value
              result[key] = helper(descriptor.value, depth + 1, newPath);
            } else if(typeof descriptor.get === 'function') {
              // Accessor property with a getter
              result[key] = '[Getter]';
            } else {
              result[key] = '[Unknown Property]';
            }
          } catch(err) {
            result[key] = `[Error: ${escapeString(err.message)}]`;
          }
        }
        return result;
      } else if(typeof value === 'string') {
        // Escape strings to prevent HTML injection
        return escapeString(value);
      }
      return value;
    }

    return JSON.stringify(helper(data, 0, []), null, 2);
  }
  
  /**
   * Escapes special HTML characters in a string to prevent HTML injection.
   * @param {string} string - The string to escape.
   * @returns {string} - The escaped string with HTML characters replaced.
   */
  escapeHTML(string) {
    var escapeHtmlMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
      '/': '&#x2F;',
      '`': '&#x60;',
      '=': '&#x3D;'
    };

    return String(string).replace(/[&<>"'`=\/]/g, function(s) {
      return escapeHtmlMap[s];
    });
  }

  /**
   * Escapes special LaTeX characters in a string to prevent LaTeX injection.
   * @param {string} string - The string to escape.
   * @returns {string} - The escaped string with LaTeX characters replaced.
   */
  escapeLatex(string) {
    if(typeof string !== 'string') {
      return string;
    }
    return string
      .replace(/\\/g, '\\textbackslash{}')
      .replace(/&/g, '\\&')
      .replace(/%/g, '\\%')
      .replace(/\$/g, '\\

% ----------------------------------------
% End of document
% ----------------------------------------
\end{document})
      .replace(/#/g, '\\#')
      .replace(/_/g, '\\_')
      .replace(/{/g, '\\{')
      .replace(/}/g, '\\}')
      .replace(/~/g, '\\textasciitilde{}')
      .replace(/\^/g, '\\textasciicircum{}')
      .replace(/`/g, '\\textasciigrave{}');
  }
  
  /**
   * Generates a unique object key by appending a number to the original key if it already exists.
   * @param {string} object - Object to add unique key.
   * @param {string} key - The original object key.
   * @returns {string} A unique object key.
   */
  getUniqueKey(object, key) {
    var i = 0;
    var unique_key = key;
    while(hasKey(object, unique_key)) {
      i = i+1;
      unique_key = key+i;
    }
    return unique_key;
  }
    
  /**
   * Generates a random string of the specified length.
   * @param {number} num - The desired length of the random string.
   * @returns {string} A random string.
   */
  randomString(num) {
    return Math.random().toString(36).substr(2, num);
  }
  
  /**
   * Calculates the number of decimal places in a number.
   * @param {number} num - The number to evaluate.
   * @returns {number} The count of decimal places.
   */
  countDecimalPlaces(num) {
    return num > 1 ? 0 : (num.toString().split('.')[1] || '').match(/^0*/)[0].length+1;
  }
  
  /**
   * Replaces file links in a text with HTML span elements.
   * @param {string} text - The multiline error log text.
   * @returns {string} The updated text with file links replaced by HTML spans.
   */
  replaceEditorLinks(text) {
    var regex = /(.+?):(\d+):(\d+):/g;
    
    return text.replace(regex, (match, filePath, lineNumber, charPos) => {
      return `<span class="open-editor" file_path="${filePath}" line_number="${lineNumber}" char_pos="${charPos}">${match}</span>`;
    });
  }
  
  /**
   * Checks that an input contains a finite number
   * @param {HTMLInputElement} n  Target input element.
   * @returns {boolean} True when the value is valid.
   */
  numberValidator(n) {
    var str = n.value.trim();
    var num = Number(str);
    return str !== '' && Number.isFinite(num);
  }
  
  /**
   * Checks that an input contains a finite number
   * and—if supplied—is within the inclusive range [min, max].
   * @param {HTMLInputElement} n  Target input element.
   * @param {number} [min]        Minimum allowed value (optional).
   * @param {number} [max]        Maximum allowed value (optional).
   * @returns {boolean}           True when the value is valid.
   */
  limitedNumberValidator(n, min, max) {
    var str = n.value.trim();
    var num = Number(str);
    if(str === '' || !Number.isFinite(num)) return false;
    if(min !== undefined && num < min) return false;
    if(max !== undefined && num > max) return false;
    return true;
  }
}

exports.PRDC_JSLAB_LIB_FORMAT = PRDC_JSLAB_LIB_FORMAT;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={freecad-link.js}]
/**
 * @file JSLAB FreeCADLink submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB FreeCADLink.
 */
class PRDC_JSLAB_FREECAD_LINK {
  
  /**
   * Initializes a new instance of the FreeCADLink.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    this.jsl = jsl;
  }
  
  /**
   * Starts the FreeCAD application and establishes a TCP connection for remote procedure calls.
   * Attempts to start FreeCAD if it's not running and connects to its TCP server.
   * @param {string} exe - The executable path of FreeCAD.
   * @param {Object} options - Configuration options such as port and host.
   */
  async start(exe, options) {
    this.exe = exe;
    
    this.port = 11077;
    this.host = 'localhost';
    this.timeout = 3000; // [ms]
    this.script_timeout = 30000; // [ms]
    this.startup_timeout = 10000; // [ms]
    
    this.loaded = false;
    
    if(options.hasOwnProperty('port')) {
      this.port = options.port;
    }
    if(options.hasOwnProperty('host')) {
      this.host = options.host;
    }
    if(options.hasOwnProperty('timeout')) {
      this.timeout = options.timeout;
    }
    if(options.hasOwnProperty('script_timeout')) {
      this.script_timeout = options.script_timeout;
    }
    if(options.hasOwnProperty('startup_timeout')) {
      this.startup_timeout = options.startup_timeout;
    }
    
    var [flag, pids] = this.jsl.system.isProgramRunning('FreeCAD.exe');
    if(flag) {
      this.loaded = true;
      this.jsl.env.disp('@FreeCADLink: '+language.string(179));
      await this.findServer();
    } else {
      this.jsl.system.exec('"' + this.exe + '" --single-instance');
      var [flag, pids] = this.jsl.system.isProgramRunning('FreeCAD.exe');
      if(flag) {
        this.loaded = true;
        await this.findServer();
      } else {
        this.jsl.env.disp('@FreeCADLink: '+language.string(180));
      }
    }
  }
  
  /**
   * Attempts to locate the FreeCAD TCP server within the network, respecting the startup timeout.
   * Checks if the TCP server is reachable by sending a 'PING' command.
   */
  async findServer() {
    var t = tic;
    while(true) {
      if(await this.send('PING|', 1000)) {
        break;
      } else if(toc(t) > this.startup_timeout/1000) {
        this.loaded = false;
        this.jsl.env.disp('@FreeCADLink: '+language.string(181));
        break;
      }
      await waitSeconds(0.5);
    }
  }
  
  /**
   * Sends a message to the FreeCAD TCP server and waits for a response.
   * Manages the TCP communication by ensuring message integrity and handling timeouts.
   * @param {string} message - The message to send.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   * @returns {Buffer|boolean} - The response from the server or false if the request times out.
   */
  async send(message, timeout) {
    var obj = this;
    var buf_in = [];
    var N_in;
    var got_header = false;

    if(this.jsl.format.isUndefined(timeout)) {
      timeout = this.timeout;
    } 
    if(this.loaded) {
      var t = tic;

      this.tcp_com = this.jsl.networking.tcp(host, port, function() {
        var length = message.length;
        var buf_out = Buffer.alloc(2 + length);
        buf_out.writeUInt16BE(length, 0);
        buf_out.write(message, 2, 'utf8');
        obj.tcp_com.write(buf_out);
      });
      while(true) {
        await waitMSeconds(1);
        if(toc(t) < timeout/1000) {
          if(!got_header && this.tcp_com.availableBytes() > 2) {
            got_header = true;
            var data = this.tcp_com.read();
            var header = data.splice(0, 2);
            N_in = (header[0] << 8) | header[1];
            buf_in.push(...data);
            if(buf_in.length == N_in) {
              break;
            }
          } else if(got_header && this.tcp_com.availableBytes() > 0) {
            var data = this.tcp_com.read();
            if(data.length) {
              buf_in.push(...data);
              if(buf_in.length >= N_in) {
                buf_in = buf_in.slice(0, N_in);
                break; 
              }
            }
          }
        } else {
          break;
        }
      }

      this.tcp_com.close();
      if(buf_in.length) {
        return Buffer.from(buf_in).toString();
      }
    }
    return false;
  }
  
  /**
   * Parses the input from FreeCAD responses to identify errors and data.
   * Splits the message by '|' and checks for error or data messages.
   * @param {string} message - The message received from FreeCAD.
   * @returns {Array} - An array of parsed message components.
   */
  inputPraser(message) {
    var params = [];
    var str = message.toString();
    
    if(str.length) {
      params = str.split('|');
      if(params.length && params[0] == 'ERR') {
        disp('@FreeCADLink: Error = ' + params[1]);
      }
    }
    return params;
  }
  
  /**
   * Displays a message from FreeCAD in the JSLAB interface.
   * Parses and displays messages specifically tagged as 'MSG' from FreeCAD.
   * @param {string} message - The message received from FreeCAD.
   */
  showMessage(message) {
    var params = this.inputPraser(message);
    if(params.length && params[0] == 'MSG') {
      this.jsl.env.disp('@FreeCADLink: Message = ' + params[1]);
    }
  }
  
  /**
   * Closes the FreeCAD application gracefully.
   * Sends a quit command and handles the termination of the TCP connection.
   */
  async quit() {
    if(this.loaded) {
      var response = await this.send('CMD|QUIT', 1000);
      return this.inputPraser(response);
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Opens a specified file in FreeCAD.
   * Sends a command to open a file and handles responses to confirm file access.
   * @param {string} filePath - The path to the file to be opened.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async open(filePath, timeout) {
    if(this.loaded) {
      if(exist(filePath)) {
        var response = await this.send('CMD|OPEN|' + filePath, timeout);
        return this.inputPraser(response);
      } else {
        this.jsl.env.disp('@FreeCADLink: '+language.string(183));
      }
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Imports a file into the current FreeCAD document.
   * Sends an import command and handles responses to confirm the import operation.
   * @param {string} filePath - The path of the file to be imported.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async importFile(filePath, timeout) {
    if(this.loaded) {
      if(exist(filePath)) {
        var response = await this.send('CMD|IMPORT|' + filePath, timeout);
        return this.inputPraser(response);
      } else {
        this.jsl.env.disp('@FreeCADLink: '+language.string(183));
      }
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Creates a new document in FreeCAD, optionally specifying a filename.
   * Sends a command to create a new document and handles the document creation response.
   * @param {string} filename - Optional filename for the new document.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async newDocument(filename, timeout) {
    if(this.loaded) {
      var cmd = 'CMD|NEW';
      if(!this.jsl.format.isUndefined(filename)) {
        cmd = cmd+"|"+filename;
      }
      var response = await this.send(cmd, timeout);
      var params = this.inputPraser(response);
      var name = "";
      if(params.length && params[0] == 'DAT') {
        name = params[1];
      }
      return name;
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Saves the current document in FreeCAD.
   * Sends a save command and handles responses to confirm the save operation.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async save(timeout) {
    if(this.loaded) {
      var response = await this.send('CMD|SAVE', timeout);
      return this.inputPraser(response);
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Saves the current document in FreeCAD under a new filename.
   * Sends a save as command and handles responses to confirm the operation.
   * @param {string} filePath - The new file path for the document.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async saveAs(filePath, timeout) {
    if(this.loaded) {
      var response = await this.send('CMD|SAVEAS|' + filePath, timeout);
      return this.inputPraser(response);
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Closes the current document in FreeCAD.
   * Sends a close command and handles responses to confirm the document closure.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async close(timeout) {
    if(this.loaded) {
      var response = await this.send('CMD|CLOSE', timeout);
      return this.inputPraser(response);
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Executes a command in FreeCAD and returns the evaluation result.
   * Sends an evaluate command with the specified command string.
   * @param {string} command - The command to be evaluated in FreeCAD.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async evaluate(command, timeout) {
    if(this.loaded) {
      var response = await this.send('EVAL|' + command, timeout);
      return this.inputPraser(response);
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Runs a script in FreeCAD with optional parameters.
   * Sends a script command along with parameters and handles the script execution response.
   * @param {string} script - The script to run.
   * @param {string|array} param - Parameters to pass to the script.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async callScript(script, param, timeout) {
    if(this.loaded) {
      if(this.jsl.format.isUndefined(timeout)) {
        timeout = this.script_timeout;
      }
      if(this.jsl.format.isUndefined(param)){
        param = '';
      } else if(isArray(param)){
        param = param.join('|');
      }
      var response = await this.send('SCRIPT|' + script + '|' + param, timeout);
      return this.inputPraser(response);
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Retrieves the area of the selected object in FreeCAD.
   * Sends a measure area command and parses the response to extract the area value.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async getArea(timeout) {
    if(this.loaded) {
      var response = await this.send('MSR|A', timeout);
      var params = this.inputPraser(response);
      var area = "";
      if(params.length && params[0] == 'DAT') {
        area = params[1];
      }
      return area;
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
  
  /**
   * Retrieves the volume of the selected object in FreeCAD.
   * Sends a measure volume command and parses the response to extract the volume value.
   * @param {number} timeout - Timeout in milliseconds to wait for a response.
   */
  async getVolume(timeout) {    
    if(this.loaded) {
      var response = await this.send('MSR|V', timeout);
      var params = this.inputPraser(response);
      var vol = "";
      if(params.length && params[0] == 'DAT') {
        vol = params[1];
      }
      return vol;
    } else {
      this.jsl.env.disp('@FreeCADLink: '+language.string(182));
    }
    return false;
  }
}

exports.PRDC_JSLAB_FREECAD_LINK = PRDC_JSLAB_FREECAD_LINK;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={geography-map-3d.js}]
/**
 * @file JSLAB library geography map 3D submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for map 3D.
 */
class PRDC_JSLAB_GEOGRAPHY_MAP_3D {
  
  /**
   * Creates a new 3D map instance.
   * @param {Object} jsl - The JSLAB instance or environment reference.
   */
  constructor(jsl, token) {
    this.jsl = jsl;
    this.token = token;
    
    // Default camera parameters
    this.latitude = 44.8768331;
    this.longitude = 20.112352;
    this.height = 1000; // meters
    this.heading = 0; // degrees
    this.pitch = -30; // degrees
    
    this.wid;
    this.ready = false;
  }
  
  /**
   * Opens a window with Cesium and initializes 3D map.
   * @returns {Promise<void>}
   */
  async createWindow() {
    var wid = this.jsl.windows.openWindow('cesium.html');
    this.wid = wid;
    this.win = this.jsl.windows.open_windows[wid];
    await this.jsl.windows.open_windows[wid].ready;
    var context = this.jsl.windows.open_windows[wid].context;
    context.imports_ready = false;
    while(!context.imports_ready) {
      if(typeof context.Cesium != 'undefined') {
        context.imports_ready = true;
      }
      await this.jsl.non_blocking.waitMSeconds(1);
    }
    context.map_3d_cont = context.document.getElementById('map-3d-cont');
    context.map_3d_cont.style = 'position: absolute;top:0;left:0;right:0;bottom:0;';
    
    // Initialize Cesium Viewer
    context.Cesium.Ion.defaultAccessToken = this.token;
    this.viewer = new context.Cesium.Viewer(context.map_3d_cont, {
      terrainProvider: await context.Cesium.CesiumTerrainProvider.fromIonAssetId(1),
      timeline: false,
      sceneModePicker: false,
      baseLayerPicker: false,
      geocoder: false,
      infoBox: false,
      selectionIndicator: false
    });
    
    this.context = context;
    this.Cesium = context.Cesium;
    this.ready = true;
  }
  
  /**
   * Sets the camera view to the specified latitude, longitude, and height.
   * @param {number} lat - Latitude.
   * @param {number} lon - Longitude.
   * @param {number} height - Height in meters.
   * @param {number} [heading=0] - Heading in degrees.
   * @param {number} [pitch=-30] - Pitch in degrees.
   */
  setView(lat, lon, height, heading = 0, pitch = -30) {
    this.latitude = lat;
    this.longitude = lon;
    this.height = height;
    this.heading = heading;
    this.pitch = pitch;
    
    if(this.ready && this.viewer) {
      this.viewer.camera.flyTo({
        destination: this.context.Cesium.Cartesian3.fromDegrees(lon, lat, height),
        orientation: {
          heading: this.context.Cesium.Math.toRadians(heading),
          pitch: this.context.Cesium.Math.toRadians(pitch),
          roll: 0.0
        }
      });
    }
  }
  
  /**
   * Adds a new entity to the 3D map.
   * @param {Object} data - The data representing the entity to add.
   * @returns {PRDC_JSLAB_GEOGRAPHY_MAP_3D_ENTITY} The newly created map entity.
   */
  addEntity(data) {
    return new PRDC_JSLAB_GEOGRAPHY_MAP_3D_ENTITY(this.jsl, this, data);
  }
  
  /**
   * Removes all entities from the 3D map viewer.
   */
  removeAllEntities() {
    this.viewer.entities.removeAll();
  }
  
  /**
   * Animates the camera to fly to the specified entity.
   * @param {Object} entity - The entity to fly to.
   */
  flyTo(entity) {
    if(hasKey(entity, 'entity')) {
      this.viewer.flyTo(entity.entity);
    }
  }
}

exports.PRDC_JSLAB_GEOGRAPHY_MAP_3D = PRDC_JSLAB_GEOGRAPHY_MAP_3D;

class PRDC_JSLAB_GEOGRAPHY_MAP_3D_ENTITY {
  
  /**
   * Creates a new 3D map entity and adds it to the viewer.
   * @param {Object} jsl - The JSL environment object.
   * @param {Object} map_3d - The 3D map instance where the entity will be added.
   * @param {Object} data - The data representing the entity.
   */
  constructor(jsl, map_3d, data) {
    this.jsl = jsl;
    this.map_3d = map_3d;
    this.data = data;
    
    this.entity = this.map_3d.viewer.entities.add(data);
  }
  
  /**
   * Animates the camera to fly to this entity.
   */
  flyTo() {
    this.map_3d.viewer.flyTo(this.entity);
  }
}

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={geography-map.js}]
/**
 * @file JSLAB library geography map submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for map.
 */
class PRDC_JSLAB_GEOGRAPHY_MAP {
  
  /**
   * Creates a new map instance.
   * @param {Object} jsl - The JSLAB instance or environment reference.
   * @param {string} [tileset='OpenStreetMap'] - The name of the tileset to use.
   */
  constructor(jsl, tileset = 'OpenStreetMap') {
    this.jsl = jsl;
    
    // Default map parameters
    this.lat = 44.8768331;
    this.lon = 20.112352;
    this.zoom = 12;
    this.tileset = tileset;
    this.tileset_url;
    
    this.tilesets = {
      // OpenStreetMap Standard
      'OpenStreetMap': 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',

      // Stamen Design
      'Stamen Toner': 'https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png',
      'Stamen Watercolor': 'https://stamen-tiles.a.ssl.fastly.net/watercolor/{z}/{x}/{y}.jpg',
      'Stamen Terrain': 'https://stamen-tiles.a.ssl.fastly.net/terrain/{z}/{x}/{y}.jpg',

      // CartoDB (CARTO)
      'Carto Positron': 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
      'Carto DarkMatter': 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',

      // OpenTopoMap
      'OpenTopoMap': 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',

      // Esri
      'Esri WorldStreetMap': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}',
      'Esri WorldImagery': 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      'Esri DarkGrayCanvas': 'https://server.arcgisonline.com/ArcGIS/rest/services/Dark_Gray_Base/MapServer/tile/{z}/{y}/{x}',

      // Wikimedia Maps
      'Wikimedia Standard': 'https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png',
      'Wikimedia Cycle Map': 'https://maps.wikimedia.org/osm-intl-cycle/{z}/{x}/{y}.png',
      'Wikimedia Transport Map': 'https://maps.wikimedia.org/osm-intl-transport/{z}/{x}/{y}.png',
    };
    
    if(hasKey(this.tilesets, this.tileset)) {
      this.tileset_url = this.tilesets[this.tileset];
    } else {
      this.tileset_url = this.tileset;
    }
    
    this.wid;
    this.ready = false;
  }
  
  /**
   * Opens a window with Leaflet and initializes the map.
   * @returns {Promise<void>}
   */
  async createWindow() {
    var wid = this.jsl.windows.openWindow('leaflet.html');
    this.wid = wid;
    this.win = this.jsl.windows.open_windows[wid];
    await this.jsl.windows.open_windows[wid].ready;
    var context = this.jsl.windows.open_windows[wid].context;
    context.imports_ready = false;
    while(!context.imports_ready) {
      if(typeof context.L != 'undefined') {
        context.imports_ready = true;
      }
      await this.jsl.non_blocking.waitMSeconds(1);
    }
    this.context = context;
    context.map_cont = context.document.getElementById('map-cont');
    context.map_cont.style = 'position: absolute;top:0;left:0;right:0;bottom:0;';
    this.leaflet_obj = context.L.map('map-cont', 
      { attributionControl: false }
    ).setView([this.lat, this.lon], this.zoom);
    context.L.tileLayer(this.tileset_url).addTo(this.leaflet_obj);
    this.ready = true;
  }
  
  /**
   * Sets the center of the map to the specified latitude and longitude.
   * This will update the internal state and move the Leaflet map if it is ready.
   * @param {number} lat - Latitude.
   * @param {number} lon - Longitude.
   */
  setCenter(lat, lon) {
    this.lat = lat;
    this.lon = lon;
    if(this.ready && this.leaflet_obj) {
      this.leaflet_obj.setView([lat, lon], this.zoom);
    }
  }
  
  /**
   * Sets the zoom level of the map.
   * This will update the internal state and adjust the Leaflet map if it is ready.
   * @param {number} zoom - The zoom level.
   */
  setZoom(zoom) {
    this.zoom = zoom;
    if(this.ready && this.leaflet_obj) {
      this.leaflet_obj.setZoom(zoom);
    }
  }
  
  /**
   * Adds a marker to the map at the specified latitude and longitude.
   * @param {number} lat - Latitude.
   * @param {number} lon - Longitude.
   * @returns {PRDC_JSLAB_GEOGRAPHY_MAP_MARKER|null} - The marker instance or null if map is not ready.
   */
  addMarker(lat, lon) {
    return new PRDC_JSLAB_GEOGRAPHY_MAP_MARKER(this.jsl, this, lat, lon);
  }
}

exports.PRDC_JSLAB_GEOGRAPHY_MAP = PRDC_JSLAB_GEOGRAPHY_MAP;

class PRDC_JSLAB_GEOGRAPHY_MAP_MARKER {
  
  /**
   * Creates a new marker and adds it to the map.
   * @param {Object} jsl - The JSLAB instance or environment reference.
   * @param {PRDC_JSLAB_GEOGRAPHY_MAP} map - The map instance.
   * @param {number} lat - Latitude.
   * @param {number} lon - Longitude.
   */
  constructor(jsl, map, lat, lon) {
    this.jsl = jsl;
    this.map = map;
    
    this.leaflet_obj = this.map.context.L.marker([lat, lon]).addTo(this.map.leaflet_obj);
    this.lat = lat;
    this.lon = lon;
  }
  
  /**
   * Sets a custom icon for the marker.
   * @param {Object} iconOptions - Leaflet icon options: { iconUrl: '...', iconSize: [...], iconAnchor: [...], etc. }
   */
  setIcon(iconOptions) {
    if(this.leaflet_obj && this.map.ready) {
      let customIcon = this.map.context.L.icon(iconOptions);
      this.leaflet_obj.setIcon(customIcon);
      this.leaflet_obj.setRotationOrigin('center center');
    }
  }

  /**
   * Sets a custom icon for the marker.
   * @param {Object} iconOptions - Leaflet divIcon options: { iconUrl: '...', iconSize: [...], iconAnchor: [...], etc. }
   */
  setDivIcon(iconOptions) {
    if(this.leaflet_obj && this.map.ready) {
      let customIcon = this.map.context.L.divIcon(iconOptions);
      this.leaflet_obj.setIcon(customIcon);
      this.leaflet_obj.setRotationOrigin('center center');
    }
  }
  
  /**
   * Sets the position of the marker.
   * @param {number} lat - New latitude.
   * @param {number} lon - New longitude.
   */
  setPosition(lat, lon) {
    this.lat = lat;
    this.lon = lon;
    if(this.leaflet_obj && this.map.ready) {
      this.leaflet_obj.setLatLng([lat, lon]);
    }
  }
  
  /**
   * Sets the rotation (in degrees) of the marker.
   * Leaflet markers can be rotated via CSS transform if using a DivIcon or a custom class.
   * This example uses a simple inline style transform if the marker's icon supports it.
   * @param {number} rotation - Rotation angle in degrees.
   */
  setRotation(rotation) {
    if(this.leaflet_obj && this.map.ready) {
      this.leaflet_obj.setRotationAngle(rotation);
    }
  }
}

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={geography.js}]
/**
 * @file JSLAB library geography submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

var { PRDC_JSLAB_GEOGRAPHY_MAP } = require('./geography-map');
var { PRDC_JSLAB_GEOGRAPHY_MAP_3D } = require('./geography-map-3d');

/**
 * Class for JSLAB geography submodule.
 */
class PRDC_JSLAB_LIB_GEOGRAPHY {
  
  /**
   * Initializes the geography submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }
  
  /**
   * Initializes and returns a new 2D web map instance.
   * @param {...*} args - Arguments for configuring the web map.
   * @returns {Promise<PRDC_JSLAB_GEOGRAPHY_MAP>} The initialized 2D web map instance.
   */
  async webmap(...args) {
    var map = new PRDC_JSLAB_GEOGRAPHY_MAP(this.jsl, ...args);
    await map.createWindow();
    return map;
  }
  
  /**
   * Initializes and returns a new 3D geoglobe instance.
   * @param {...*} args - Arguments for configuring the 3D geoglobe.
   * @returns {Promise<PRDC_JSLAB_GEOGRAPHY_MAP_3D>} The initialized 3D geoglobe instance.
   */
  async geoglobe(...args) {
    var map_3d = new PRDC_JSLAB_GEOGRAPHY_MAP_3D(this.jsl, ...args);
    await map_3d.createWindow();
    return map_3d;
  }
  
  /**
   * Calculates the bounding box and center from an array of tile coordinates.
   * @param {Array<Object>} tile_coordinates - An array of objects with tile coordinates, each having properties `x`, `y`, and `z` for tile X and Y coordinates and zoom level, respectively.
   * @returns {Object} An object containing the bounds as an array of `[min_lat, min_lng]` and `[max_lat, max_lng]`, and the center as `[latitude, longitude]`.
   */
  calculateTilesBoundingBox(tile_coordinates) {
    var min_lat = Number.MAX_VALUE,
        max_lat = -Number.MAX_VALUE,
        min_lng = Number.MAX_VALUE,
        max_lng = -Number.MAX_VALUE;

    tile_coordinates.forEach(function(coord) {
        var n = Math.pow(2, coord.z);
        var tileBounds = {
            min_lat: (2 * Math.atan(Math.exp(Math.PI - (2 * Math.PI * coord.y) / n)) - Math.PI / 2) * (180 / Math.PI),
            max_lat: (2 * Math.atan(Math.exp(Math.PI - (2 * Math.PI * (coord.y + 1)) / n)) - Math.PI / 2) * (180 / Math.PI),
            min_lng: ((coord.x) / n) * 360 - 180,
            max_lng: ((coord.x + 1) / n) * 360 - 180
        };

        min_lat = Math.min(min_lat, tileBounds.min_lat);
        max_lat = Math.max(max_lat, tileBounds.max_lat);
        min_lng = Math.min(min_lng, tileBounds.min_lng);
        max_lng = Math.max(max_lng, tileBounds.max_lng);
    });

    var center = [(min_lat + max_lat) / 2, (min_lng + max_lng) / 2];
    var bounds = [[min_lat, min_lng], [max_lat, max_lng]];

    return { bounds, center };
  }

  /**
   * Calculates a new latitude and longitude based on a starting point, distance, and bearing using the Haversine formula.
   * @param {number} lat - The latitude of the starting point.
   * @param {number} lon - The longitude of the starting point.
   * @param {number} distance - The distance from the starting point in meters.
   * @param {number} bearing - The bearing in degrees from north.
   * @returns {Array<number>} An array containing the latitude and longitude of the calculated point.
   */
  offsetLatLon(lat, lon, distance, bearing) {
    var dist_rad = distance / 6371000;
    var bearing_rad = (bearing * Math.PI) / 180;
    var lat_rad = (lat * Math.PI) / 180;
    var lng_rad = (lon * Math.PI) / 180;
    var new_lat_rad = Math.asin(Math.sin(lat_rad) * Math.cos(dist_rad) +
        Math.cos(lat_rad) * Math.sin(dist_rad) * Math.cos(bearing_rad));
    var new_lng_rad = lng_rad + Math.atan2(Math.sin(bearing_rad) * Math.sin(dist_rad) * Math.cos(lat_rad),
        Math.cos(dist_rad) - Math.sin(lat_rad) * Math.sin(new_lat_rad));
    return [(new_lat_rad * 180) / Math.PI, (new_lng_rad * 180) / Math.PI];
  }

  /**
   * Calculates the distance between two points on Earth using the Haversine formula.
   * @param {number} lat1 - The latitude of the first point.
   * @param {number} lon1 - The longitude of the first point.
   * @param {number} lat2 - The latitude of the second point.
   * @param {number} lon2 - The longitude of the second point.
   * @returns {number} The distance between the two points in meters.
   */
  latLonDistance(lat1, lon1, lat2, lon2) {
    var dLat = (lat2-lat1) * Math.PI / 180;
    var dLon = (lon2-lon1) * Math.PI / 180;
    return 6371000 * 2 * Math.asin(Math.sqrt(Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(lat1 * Math.PI / 180 ) * Math.cos(lat2 * Math.PI / 180 ) *
      Math.sin(dLon/2) * Math.sin(dLon/2))); // [m]
  }

  /**
   * Calculates the distance between two points on Earth including altitude difference using the Haversine formula.
   * @param {number} lat1 - The latitude of the first point.
   * @param {number} lon1 - The longitude of the first point.
   * @param {number} alt1 - The altitude of the first point in meters.
   * @param {number} lat2 - The latitude of the second point.
   * @param {number} lon2 - The longitude of the second point.
   * @param {number} alt2 - The altitude of the second point in meters.
   * @returns {number} The 3D distance between the two points in meters.
   */
  latLonAltDistance(lat1, lon1, alt1, lat2, lon2, alt2) {
    var L = latLonDistance(lat1, lon1, lat2, lon2);
    return Math.sqrt(Math.pow(L, 2)+Math.pow(alt1-alt2, 2));
  }

  /**
   * Checks if the latitude and longitude values have been updated.
   * @param {Object} latlon - An object containing the current and last values of latitude and longitude.
   * @returns {boolean} True if the latitude and/or longitude values have been updated; false otherwise.
   */
  checkNewLatLon(latlon) {
    if(this.jsl.format.isUndefined(latlon.value)) {
      return false;
    } else if(this.jsl.format.isUndefined(latlon.last_value)) {
      return true;
    } else {
      return (latlon.value[0] != latlon.last_value[0]) || (latlon.value[1] != latlon.last_value[1]);
    }
  }

  /**
   * Converts latitude, longitude, and altitude to Cartesian coordinates.
   * @param {number|number[]} lat - Latitude in degrees or array of latitudes.
   * @param {number|number[]} lon - Longitude in degrees or array of longitudes.
   * @param {number|number[]} alt - Altitude in meters or array of altitudes.
   * @returns {Cesium.Cartesian3|Cesium.Cartesian3[]} Cartesian coordinate(s).
   */
  latLonAlt2cartesian(lat, lon, alt) {
    var isArray = Array.isArray(lat) && Array.isArray(lon) && Array.isArray(alt);

    if(isArray) {
      return lat.map((latitude, index) =>
        this.jsl.env.Cesium.Cartesian3.fromDegrees(lon[index], latitude, alt[index])
      );
    } else {
      return this.jsl.env.Cesium.Cartesian3.fromDegrees(lon, lat, alt);
    }
  }
}

exports.PRDC_JSLAB_LIB_GEOGRAPHY = PRDC_JSLAB_LIB_GEOGRAPHY;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={geometry-spacesearch.js}]
/**
 * @file JSLAB library geometry Space Search submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */

/**
 * Class for N-dimensional Space Search.
 */
class PRDC_JSLAB_GEOMETRY_SPACE_SERACH {
  
  /**
   * Displays the size of elements based on bounds and subdivisions.
   * @param {Array} bounds - Array of [min, max] for each dimension.
   * @param {Array} subdivisionPerDepth - Subdivision factors per depth and dimension.
   */
  dispElementSize(bounds, subdivisionPerDepth) {
    var numDimensions = bounds.length;
    // Calculate the initial differences between bounds for each dimension
    var dq = bounds.map((bound, index) => (bound[1] - bound[0]) / subdivisionPerDepth[0][index]);
    
    // Copy dq to dqmin for further subdivision calculations
    var dqmin = [...dq];

    // Iterate through subdivisionPerDepth starting from the second depth level
    for(var i = 1; i < subdivisionPerDepth.length; i++) {
      for(var j = 0; j < numDimensions; j++) {
        dqmin[j] /= subdivisionPerDepth[i][j];
      }
    }

    // Display the results for initial and minimal element dimensions
    disp(` Dimenzije inicijalnih elemenata: ${dq.map(val => val.toFixed(2)).join('x')}`);
    disp(` Dimenzije najmanjih elemenata: ${dqmin.map(val => val.toFixed(2)).join('x')}`);
  }
  
  /**
   * Splits the search space into smaller intervals for parallel processing.
   * @param {Array.<Array.<number>>} x_lim - The limits of the search space, where each sub-array represents [start, end] for a dimension.
   * @param {Array.<Array.<number>>} k - The parameters to optimize.
   * @param {number} N_proc - The number of processors to divide the work among.
   * @returns {Array.<Array.<number>>} An array containing the split search spaces and the adjusted parameters.
   */
  splitSearchSpace(x_lim, k, N_proc) {
    const [start, end] = x_lim[0];
    const interval = (end - start) / N_proc;
    
    var k_out = [...k];
    k_out[0][0] = k_out[0][0]/N_proc;
      
    return [Array.from({ length: N_proc }, (_, i) => [
      [start + i * interval, start + (i + 1) * interval],
      ...x_lim.slice(1)
    ]), k_out];
  }
  
  /**
   * Executes a provided function in parallel across the split search spaces.
   * @param {Array.<Array.<number>>} x_lim - The limits of the search space, where each sub-array represents [start, end] for a dimension.
   * @param {Array.<Array.<number>>} k - The parameters to optimize.
   * @param {Object} context - The execution context containing necessary configurations and states.
   * @param {Function} setup - The setup function to initialize the parallel environment.
   * @param {Function} fun - The function to execute in parallel on each split of the search space.
   * @returns {Promise<Array.<Array.<number>>>} A promise that resolves to arrays of input and output results from the parallel execution.
   */
  async runParallel(x_lim, k, context, setup, fun) {
    var N_proc = parallel.getProcessorsNum();
    
    var funStr = fun.toString();
    var funBody = funStr.slice(funStr.indexOf("{") + 1, funStr.lastIndexOf("}"));
    var funArgs = funStr.slice(funStr.indexOf("(") + 1, funStr.indexOf(")"));
    
    var [x_lim_parallel, k_parallel] = this.splitSearchSpace(x_lim, k, N_proc);
    
    var res = await parallel.parfor(0, N_proc-1, 1, N_proc, 
        Object.assign(context, {x_lim_parallel, k_parallel, 
        funArgs, funBody}), setup, function(i) {
      var new_fun = new Function(funArgs, funBody);
      return crawler.run(x_lim_parallel[i], k_parallel, new_fun);
    });
    var Nin = res.map(pair => pair[0]).flat();
    var Nout = res.map(pair => pair[1]).flat();
    return [Nin, Nout];
  }
  
  /**
   * Executes the space search algorithm.
   * @param {number[][]} bounds - Array of [min, max] for each dimension.
   * @param {number[][]} subdivisionPerDepth - Subdivision factors for each depth and dimension.
   * @param {function} conditionFunction - Function that determines if a point satisfies the condition.
   * @returns {Array<Array<number>>} - Arrays of points inside and outside the condition.
   */
  run(bounds, subdivisionPerDepth, conditionFunction) {
    var numDimensions = bounds.length;
    var maxDepth = subdivisionPerDepth.length;

    // Initial starting point
    var startCoordinates = bounds.map(([min]) => min);
    
    // Calculate initial step sizes (dq)
    var initialStepSizes = bounds.map(
      ([min, max], idx) => (max - min) / subdivisionPerDepth[0][idx]
    );
    
    // Generate step sizes for each depth
    var stepSizesPerDepth = [initialStepSizes];
    for(var depth = 1; depth < maxDepth; depth++) {
      var previousStepSizes = stepSizesPerDepth[depth - 1];
      var newStepSizes = previousStepSizes.map(
        (size, idx) => size / subdivisionPerDepth[depth][idx]
      );
      stepSizesPerDepth.push(newStepSizes);
    }

    // Compute the values at the boundary points
    var cornerShifts = this.generateCornerShifts(numDimensions);
    var boundaryPoints = cornerShifts.map(shift => {
      return shift.map((s, idx) => startCoordinates[idx] + s * (bounds[idx][1] - bounds[idx][0]));
    });
    var boundaryValues = boundaryPoints.map(point => (conditionFunction(point) ? 1 : 0));
    
    // Call makeNodesND
    var [Nin, Nout] = this.makeNodesND(
      startCoordinates,
      boundaryValues,
      0,
      stepSizesPerDepth,
      subdivisionPerDepth,
      conditionFunction
    );

    return [Nin, Nout];
  }

  /**
   * Recursively creates nodes in N dimensions based on subdivisions.
   * @param {number[]} startCoordinates - Starting coordinates for the current grid.
   * @param {number[]} boundaryValues - Values at the boundary points of the current hypercube.
   * @param {number} currentDepth - Current depth of the recursion.
   * @param {number[][]} stepSizesPerDepth - Step sizes for each depth.
   * @param {number[][]} subdivisionPerDepth - Subdivision factors for each depth.
   * @param {function} conditionFunction - User-defined condition function.
   * @returns {Array<Array<number>>} - Arrays of points inside and outside the condition.
   */
  makeNodesND(
    startCoordinates,
    boundaryValues,
    currentDepth,
    stepSizesPerDepth,
    subdivisionPerDepth,
    conditionFunction
  ) {
    var numDimensions = startCoordinates.length;
    var maxDepth = subdivisionPerDepth.length; // maximum depth
    var Nin = [];
    var Nout = [];
      
    // Generate coordinate arrays for each dimension
    var stepSizes = stepSizesPerDepth[currentDepth];
    var numSteps = subdivisionPerDepth[currentDepth];
    var coordsArray = [];
    for(var idx = 0; idx < numDimensions; idx++) {
      var steps = numSteps[idx];
      var stepSize = stepSizes[idx];
      var start = startCoordinates[idx];
      var arr = Array.from(
        { length: steps + 1 },
        (_, i) => start + i * stepSize
      );
      coordsArray.push(arr);
    }

    // Initialize N-dimensional grid
    var gridShape = coordsArray.map(A => A.length);
    var N = createFilledArray(...gridShape, null);
      
    // Mark whether a node needs to be calculated
    var nf = createFilledArray(...gridShape, 1);
      
    // Set nf to 0 for corner points (boundary points)
    var cornerIndices = this.getCornerIndices(gridShape);
    cornerIndices.forEach(indices => {
      setValueAt(nf, indices, 0);
    });

    // Set the values at the corner points and add them to Nin or Nout
    cornerIndices.forEach((indices, idx) => {
      var coords = indices.map((index, dim) => coordsArray[dim][index]);
      var value = boundaryValues[idx];
      setValueAt(N, indices, [...coords, value]);

      // On first level, add corner points to Nin or Nout
      if(currentDepth == 0) {
        if(value) {
          Nin.push(coords);
        } else {
          Nout.push(coords);
        }
      }
    });

    // Now compute the values at all nodes where nf is 1
    var indicesList = this.generateIndicesList(gridShape, nf);
    for(var indices of indicesList) {
      var coords = indices.map((index, dim) => coordsArray[dim][index]);
      var e = conditionFunction(coords) ? 1 : 0;
      setValueAt(N, indices, [...coords, e]);

      if(e) {
        Nin.push(coords);
      } else {
        Nout.push(coords);
      }
    }

    // Check for further subdivision
    if(currentDepth < maxDepth - 1) {
      var innerCubeIndicesList = this.generateInnerCubeIndicesList(gridShape);
      for(var indices of innerCubeIndicesList) {
        var cubeCorners = this.getCubeCorners(N, indices);
        var boundaryValues_sub = cubeCorners.map(corner => corner[corner.length - 1]);

        var allSame = boundaryValues_sub.every(val => val === boundaryValues_sub[0]);
        if(!allSame) {
          var startCoords_sub = cubeCorners[0].slice(0, numDimensions);
          var [Nin_sub, Nout_sub] = this.makeNodesND(
            startCoords_sub,
            boundaryValues_sub,
            currentDepth + 1,
            stepSizesPerDepth,
            subdivisionPerDepth,
            conditionFunction
          );
          Nin = Nin.concat(Nin_sub);
          Nout = Nout.concat(Nout_sub);
        }
      }
    }

    return [Nin, Nout];
  }

  /**
   * Generates all corner shifts for a hypercube in N dimensions.
   * @param {number} numDimensions - Number of dimensions.
   * @returns {number[][]} - Array of shifts for each corner.
   */
  generateCornerShifts(numDimensions) {
    var shifts = [];
    var totalCorners = 1 << numDimensions;
    for(var i = 0; i < totalCorners; i++) {
      var shift = [];
      for(var j = 0; j < numDimensions; j++) {
        shift.push((i >> j) & 1);
      }
      shifts.push(shift);
    }
    return shifts;
  }

  /**
   * Retrieves the indices of corner points in the grid.
   * @param {number[]} gridShape - Shape of the grid.
   * @returns {number[][]} - List of corner indices.
   */
  getCornerIndices(gridShape) {
    var numDimensions = gridShape.length;
    var cornerShifts = this.generateCornerShifts(numDimensions);
    return cornerShifts.map(shift => shift.map((s, idx) => s * (gridShape[idx] - 1)));
  }

  /**
   * Generates a list of indices for nodes that need to be calculated.
   * @param {number[]} gridShape - Shape of the grid.
   * @param {Array} nf - N-dimensional array indicating nodes to compute.
   * @returns {number[][]} - List of node indices where nf is 1.
   */
  generateIndicesList(gridShape, nf) {
    var indicesList = [];

    var generateIndices = (indices, dim) => {
      if(dim === gridShape.length) {
        if(getValueAt(nf, indices) === 1) {
          indicesList.push([...indices]);
        }
        return;
      }
      for(var i = 0; i < gridShape[dim]; i++) {
        indices[dim] = i;
        generateIndices(indices, dim + 1);
      }
    };
    generateIndices(new Array(gridShape.length).fill(0), 0);
    return indicesList;
  }

  /**
   * Generates a list of starting indices for inner hypercubes.
   * @param {number[]} gridShape - Shape of the grid.
   * @returns {number[][]} - List of inner cube starting indices.
   */
  generateInnerCubeIndicesList(gridShape) {
    var indicesList = [];

    var generateIndices = (indices, dim) => {
      if(dim === gridShape.length) {
        indicesList.push([...indices]);
        return;
      }
      if(gridShape[dim] <= 1) {
        // No cubes along this dimension
        return;
      }
      for(var i = 0; i < gridShape[dim] - 1; i++) {
        indices[dim] = i;
        generateIndices(indices, dim + 1);
      }
    };
    generateIndices(new Array(gridShape.length).fill(0), 0);
    return indicesList;
  }

  /**
   * Retrieves the corner coordinates and values of a hypercube.
   * @param {Array} N - N-dimensional grid.
   * @param {number[]} indices - Starting indices of the hypercube.
   * @returns {Array} - Array of corner coordinates and values.
   */
  getCubeCorners(N, indices) {
    var numDimensions = indices.length;
    var cornerShifts = this.generateCornerShifts(numDimensions);
    var cubeCorners = cornerShifts.map(shift => {
      var cornerIndices = indices.map((idx, dim) => idx + shift[dim]);
      return getValueAt(N, cornerIndices);
    });
    return cubeCorners;
  }
}

exports.PRDC_JSLAB_GEOMETRY_SPACE_SERACH = PRDC_JSLAB_GEOMETRY_SPACE_SERACH;

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={geometry.js}]
/**
 * @file JSLAB library geometry submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
var { PRDC_JSLAB_GEOMETRY_SPACE_SERACH } = require('./geometry-spacesearch');
 
/**
 * Class for JSLAB geometry submodule.
 */
class PRDC_JSLAB_LIB_GEOMETRY {
  
  /**
   * Initializes a new instance of the geometry submodule, providing access to geometry manipulation utilities.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }
  
  /**
   * Creates an instance of PRDC_JSLAB_LIB_OPTIM_SPACE_SERACH.
   */
  spaceSearch(...args) {
    return new PRDC_JSLAB_GEOMETRY_SPACE_SERACH(...args);
  }
    
  /**
   * Finds the nearest points in points2 for each point in points1.
   * @param {Array[]} points1 - Array of points.
   * @param {Array[]} points2 - Reference points.
   * @returns {number[]} Array of indices for nearest points.
   */
  findNearestPoints(points1, points2) {
    var L;
    var id = this.jsl.array.createFilledArray(points1.length, -1);
    for(var i = 0; i < points1.length; i++) {
      var L_min;
      for(var j = 0; j < points2.length; j++) {
        if(points1[0].length == 3) {
          L = Math.sqrt(Math.pow(points1[i][0] - points2[j][0], 2) + 
                        Math.pow(points1[i][1] - points2[j][1], 2) + 
                        Math.pow(points1[i][2] - points2[j][2], 2));
        } else {
          L = Math.sqrt(Math.pow(points1[i][0] - points2[j][0], 2) + 
                        Math.pow(points1[i][1] - points2[j][1], 2));
        }
        if(j == 0 || L < L_min){
          L_min = L;
          id[i] = j;
        }
      }
    }
    return id;
  }
  
  /**
   * Returns the shortest distance from point P to the line defined by (A, i)
   * and the closest point (P1) on that line.
   * @param {number[]} P  - point [Px, Py, Pz]
   * @param {number[]} A  - a point on the line
   * @param {number[]} i  - a unit direction vector of the line
   * @returns {{ d: number, P1: number[] }}
   *   d   - shortest distance
   *   P1  - point on the line with the smallest distance to P
   */
  pointLineDistance(P, A, i) {
    // P1 = A + dot(P - A, i) * i
    const PA = minus(P, A);
    const distAlongI = dot(PA, i);
    const P1 = plus(A, scale(i, distAlongI));

    // Distance = || P - P1 ||
    const d = norm(minus(P, P1));

    return { d, P1 };
  }
  /**
   * Returns the intersection points of a circle (center O, radius r) 
   * in a plane with a line passing through point P with direction i.
   * @param {number[]} P - point on the line
   * @param {number[]} i - direction vector of the line (unit)
   * @param {number[]} O - center of the circle
   * @param {number} r   - circle radius
   * @returns {{ P1: number[]|null, P2: number[]|null, flag: number }}
   *   flag = 0 -> intersection (two points)
   *   flag = 1 -> tangent (one point)
   *   flag = 2 -> no intersection
   */
  lineCircleIntersection(P, i, O, r) {
    let P1 = null;
    let P2 = null;
    let flag = 0;

    // Distance from O to line & the closest point A
    const { d, P1: A } = this.pointLineDistance(O, P, i);

    if(d < r) {
      // Two intersection points
      const h = Math.sqrt(r * r - d * d); // half of the chord length
      P1 = plus(A, scale(i, h));
      P2 = plus(A, scale(i, -h));
      flag = 0; // intersection
    } else if(Math.abs(d - r) <= EPS) {
      // Tangent
      P1 = A;
      flag = 1;
    } else {
      // No intersection
      flag = 2;
    }

    return { P1, P2, flag };
  }
  
  /**
   * Returns the line (point P, direction i) that is the intersection 
   * of two planes, or indicates if they are the same or parallel.
   * @param {number[]} P1 - a point in plane 1
   * @param {number[]} n1 - normal to plane 1
   * @param {number[]} P2 - a point in plane 2
   * @param {number[]} n2 - normal to plane 2
   * @returns {{ P: number[]|null, i: number[]|null, flag: number }}
   *   flag = 0 -> planes intersect
   *   flag = 1 -> planes are the same
   *   flag = 2 -> planes are parallel (no intersection)
   */
  planesIntersection(P1, n1, P2, n2) {
    let P = null;
    let i = null;
    let flag = 0;

    const V = cross3D(n1, n2, 1);

    const V_norm = norm(V);
    if(V_norm > EPS) {
      // planes intersect
      i = scale(V, 1.0 / V_norm); // unit direction

      // Solve for a point on the intersection line:
      // We want to solve the system:
      //   dot(n1, X) = dot(n1, P1)
      //   dot(n2, X) = dot(n2, P2)
      //
      // We'll attempt x=0, y=0, z=0 approach or check sub-determinants.
      const A = [
        [n1[0], n1[1], n1[2]],
        [n2[0], n2[1], n2[2]],
      ];
      const B = [dot(n1, P1), dot(n2, P2)];

      // We try ignoring one coordinate at a time (k=1 to 3):
      let solved = false;
      for(let k = 0; k < 3; k++) {
        // Indices [0,1,2], skip k => j
        const j = [0, 1, 2].filter(idx => idx !== k);

        // Build a 2x2 submatrix from A, using columns j[0], j[1]
        const subA = [
          [A[0][j[0]], A[0][j[1]]],
          [A[1][j[0]], A[1][j[1]]],
        ];
        const detSubA = subA[0][0] * subA[1][1] - subA[0][1] * subA[1][0];

        if(Math.abs(detSubA) > EPS) {
          // We can solve
          // subA * C = B
          // C is 2x1 => we solve by 2x2 inverse
          const invDet = 1.0 / detSubA;
          const C0 = invDet * ( B[0]*subA[1][1] - B[1]*subA[0][1] );
          const C1 = invDet * (-B[0]*subA[1][0] + B[1]*subA[0][0]);

          // Build full solution X
          const X = [0, 0, 0];
          X[j[0]] = C0;
          X[j[1]] = C1;
          P = X;
          solved = true;
          break;
        }
      }
      if(!solved) {
        // fallback: planes might be very close, etc.
        P = [0, 0, 0]; 
      }
    } else {
      // Check if they are the same plane
      // We test if P2 satisfies plane 1 => dot(n1, P1-P2)=0 (within EPS).
      const diff = minus(P1, P2);
      if(Math.abs(dot(n1, diff)) <= EPS) {
        // same plane
        flag = 1;
      } else {
        // parallel planes
        flag = 2;
      }
    }

    return { P, i, flag };
  }

  /**
   * Checks if point P lies on the line segment A-B.
   * Returns 1 if on segment, 0 otherwise.
   * @param {number[]} P 
   * @param {number[]} A 
   * @param {number[]} B 
   * @returns {number} 1 (on segment), 0 (not on segment)
   */
  isPointOnLine(P, A, B) {
    // i = (B - A) / ||B - A||
    const AB = minus(B, A);
    const i = scale(AB, 1.0 / norm(AB));

    // dot(A - P, i) and dot(B - P, i)
    const d1 = dot(minus(A, P), i);
    const d2 = dot(minus(B, P), i);

    // If both dot products have the same sign, P is outside the segment
    if((d1 > 0 && d2 > 0) || (d1 < 0 && d2 < 0)) {
      return 0;
    }
    return 1;
  }

  /**
   * Returns the overlapping segment (if any) between two segments P1-P2 and P3-P4,
   * or indicates no overlap.
   * @param {number[]} P1
   * @param {number[]} P2
   * @param {number[]} P3
   * @param {number[]} P4
   * @returns {{ A: number[]|null, B: number[]|null, flag: number, id1: number|null, id2: number|null }}
   */
  linesOverlap(P1, P2, P3, P4) {
    let A = null;
    let B = null;
    let id1 = null;
    let id2 = null;
    let flag = 0;

    // i = (P2 - P1) / ||P2 - P1||
    const v = minus(P2, P1);
    const len = norm(v);
    const i = scale(v, 1.0 / len);

    const P = [P1, P2, P3, P4];

    const tArr = [];
    tArr.push([0, 1, 1]);
    tArr.push([dot(minus(P2, P1), i), 2, 1]);
    tArr.push([dot(minus(P3, P1), i), 3, 2]);
    tArr.push([dot(minus(P4, P1), i), 4, 2]);

    // Sort rows by the first column
    tArr.sort((a, b) => a[0] - b[0]);

    if(Math.abs(tArr[0][2] - tArr[1][2]) <= EPS) {
      // no overlap
      flag = 1;
    } else {
      id1 = tArr[1][1];
      id2 = tArr[2][1];
      A = P[id1 - 1];
      B = P[id2 - 1];
      flag = 0;
    }

    return { A, B, flag, id1, id2 };
  }

  /**
   * Finds the minimal 3D distance between all pairs of points in two arrays.
   *
   * @param {number[][]} P1i - Array of 3D points (e.g. [[x1, y1, z1], [x2, y2, z2], ...]).
   * @param {number[][]} P2i - Another array of 3D points.
   * @returns {{ L: number, P1: number[], P2: number[] }}
   *   L  - The minimal distance found.
   *   P1 - The point in P1i corresponding to the minimal distance.
   *   P2 - The point in P2i corresponding to the minimal distance.
   */
  minPointsDistance3D(P1i, P2i) {
    var P1ia = P1i.flat();
    var P2ia = P2i.flat();
    
    let L = Infinity;
    let I = -1;
    let J = -1;

    for(let i = 0; i < P1ia.length; i += 3) {
      for(let j = 0; j < P2ia.length; j += 3) {
        const dx = P1ia[i]   - P2ia[j];
        const dy = P1ia[i+1] - P2ia[j+1];
        const dz = P1ia[i+2] - P2ia[j+2];

        const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

        if (dist < L) {
          L = dist;
          I = i;
          J = j;
        }
      }
    }

    const closestP1 = [P1ia[I], P1ia[I + 1], P1ia[I + 2]];
    const closestP2 = [P2ia[J], P2ia[J + 1], P2ia[J + 2]];

    return {
      L,
      P1: closestP1,
      P2: closestP2
    };
  }
  
  /**
   * Creates a new triangle instance.
   * @param {Array} p1 - First vertex.
   * @param {Array} p2 - Second vertex.
   * @param {Array} p3 - Third vertex.
   * @returns {PRDC_JSLAB_TRIANGLE} Triangle instance.
   */
  triangle(p1, p2, p3) {
    return new PRDC_JSLAB_TRIANGLE(this.jsl, p1, p2, p3);
  }
  
  /**
   * Performs Delaunay triangulation on a set of points.
   * @param {Array[]} points - Array of points.
   * @returns {PRDC_JSLAB_TRIANGLE[]} Array of triangles.
   */
  delaunayTriangulation(points) {
    var min_x = Math.min(...points.map(p => p[0]));
    var min_y = Math.min(...points.map(p => p[1]));
    var max_x = Math.max(...points.map(p => p[0]));
    var max_y = Math.max(...points.map(p => p[1]));

    var dx = max_x - min_x, dy = max_y - min_y;
    var delta_max = Math.max(dx, dy) * 2;
    var p1 = [min_x - delta_max, min_y - delta_max, 0];
    var p2 = [min_x + delta_max * 2, min_y - delta_max, 0];
    var p3 = [min_x + dx / 2, min_y + delta_max * 2, 0];

    var triangles = [this.triangle(p1, p2, p3)];
    
    for(var point of points) {
      var bad_triangles = triangles.filter(tri => tri.circumcircleContains(point));

      var edges = [];
      for(var tri of bad_triangles) {
        edges.push(...tri.edges);
      }

      var unique_edges = edges.filter((edge, index, arr) =>
        arr.filter(e => (e[0] === edge[1] && e[1] === edge[0]) || 
                        (e[0] === edge[0] && e[1] === edge[1])).length === 1
      );

      triangles = triangles.filter(tri => !bad_triangles.includes(tri));

      for(var edge of unique_edges) {
        triangles.push(this.triangle(edge[0], edge[1], point));
      }
    }

    var final_triangles = [];
    for(var tri of triangles){
      if(tri.p1 == p1 || tri.p2 == p1 || tri.p3 == p1) continue;
      if(tri.p1 == p2 || tri.p2 == p2 || tri.p3 == p2) continue;
      if(tri.p1 == p3 || tri.p2 == p3 || tri.p3 == p3) continue;
      final_triangles.push(tri);
    }
    return final_triangles;
  }
  
  /**
   * Generates a rotation matrix to rotate from vector a to vector b.
   * @param {number[]} a - The initial unit vector.
   * @param {number[]} b - The target unit vector.
   * @returns {number[][]} - The resulting rotation matrix.
   */
  getRotationMatrix(a, b) {
    // a and b are unit vectors
    var v = this.jsl.array.cross3D(a, b, 1);
    var s = this.jsl.env.math.norm(v);
    var c = this.jsl.array.dotVector(a, b);

    if(c == -1) { // Vectors are opposite
      // Find a vector orthogonal to 'a'
      var orthogonal = [0, 0, 0];
      if(this.jsl.env.math.abs(a[0]) < this.jsl.env.math.abs(a[1]) && 
          this.jsl.env.math.abs(a[0]) < this.jsl.env.math.abs(a[2])) {
        orthogonal = [0, -a[2], a[1]];
      } else if(this.jsl.env.math.abs(a[1]) < this.jsl.env.math.abs(a[2])) {
        orthogonal = [-a[2], 0, a[0]];
      } else {
        orthogonal = [-a[1], a[0], 0];
      }
      orthogonal = this.jsl.array.normalizeVector(orthogonal);

      // Compute rotation matrix using Householder reflection
      var o = orthogonal;
      return [
        [ -1 + 2 * o[0] * o[0],      2 * o[0] * o[1],      2 * o[0] * o[2],
             2 * o[1] * o[0],  -1 + 2 * o[1] * o[1],     2 * o[1] * o[2],
             2 * o[2] * o[0],      2 * o[2] * o[1], -1 + 2 * o[2] * o[2]]
      ];
    } else if(s === 0) { // Vectors are the same
      // Return identity matrix
      return [1, 0, 0, 0, 1, 0, 0, 0, 1];
    } else {
      // Compute skew-symmetric cross-product matrix of v
      var vx = this.jsl.array.skewVector(v);

      // Compute R = I + vx + vx * vx * ((1 - c) / (s * s))
      var I = [1, 0, 0, 0, 1, 0, 0, 0, 1];

      var vx2 = this.jsl.array.multiply(vx, vx, 3, 3, 3);

      var factor = (1 - c) / (s * s);

      var R = this.jsl.array.plus(this.jsl.array.plus(I, vx), this.jsl.array.scale(vx2, factor));

      return R;
    }
  }

  /**
   * Transforms coordinates by scaling, rotating, and translating them.
   * @param {number[][]} coordinates - Array of coordinate points.
   * @param {number} scale_factor - Factor by which to scale the coordinates.
   * @param {number[][]} rotation_matrix - Matrix used to rotate the coordinates.
   * @param {number[]} translation - Vector used to translate the coordinates.
   * @returns {number[][]} - The transformed coordinates.
   */
  transform(coordinates, scale_factor, rotation_matrix, translation) {
    var obj = this;
    return coordinates.map(function(coordinate) {
      var transformed = obj.jsl.array.plus(translation, obj.jsl.array.multiply(rotation_matrix, obj.jsl.array.scale(coordinate, scale_factor), 3, 3, 1));
      return transformed;
    });
  }
        
  /**
   * Creates 3D vectors for plotting based on provided parameters.
   * @param {number[]} xi - X coordinates of vector origins.
   * @param {number[]} yi - Y coordinates of vector origins.
   * @param {number[]} zi - Z coordinates of vector origins.
   * @param {number[]} ui - X components of vectors.
   * @param {number[]} vi - Y components of vectors.
   * @param {number[]} wi - Z components of vectors.
   * @param {number} scale - Scale factor for the vectors.
   * @param {number} angle_factor - Angle factor for arrowheads.
   * @param {Object} opts - Additional plotting options.
   * @returns {Object} - An object containing line and head trace data for plotting.
   */
  createVectors3D(xi, yi, zi, ui, vi, wi, scale = 0.3, angle_factor = 0.4, opts) {
    if(!Array.isArray(xi)) xi = [xi];
    if(!Array.isArray(yi)) yi = [yi];
    if(!Array.isArray(zi)) zi = [zi];
    if(!Array.isArray(ui)) ui = [ui];
    if(!Array.isArray(vi)) vi = [vi];
    if(!Array.isArray(wi)) wi = [wi];
    
    // Define the unit arrow once
    var arrowhead_length = scale * 1;
    var arrowhead_width = arrowhead_length * this.jsl.env.math.tan(angle_factor);

    // Shaft points (unit arrow along x-axis)
    var shaft_start = [0, 0, 0];
    var shaft_end = [1 - arrowhead_length, 0, 0];

    // Arrowhead base points
    var arrow_tip = [1, 0, 0];  // Tip at the end of the shaft
    var arrow_left = [1 - arrowhead_length, arrowhead_width, 0];
    var arrow_right = [1 - arrowhead_length, -arrowhead_width, 0];

    // All points of the unit arrow
    var unit_arrow_points = [shaft_start, shaft_end, arrow_tip, arrow_left, arrow_right];
    
    var vectors = {
      line: {
        x: [],
        y: [],
        z: [],
        type: 'scatter3d', color: '#00f', mode: 'lines', showLegend: false
      },
      head: {
        x: [],
        y: [],
        z: [],
        i: [],
        j: [],
        k: [],
        type: 'mesh3d', color: '#00f', opacity: 1, flatShading: true, 
        showScale: false, showLegend: false, lighting: {ambient: 1}
      }
    };
    
    if(typeof opts == 'object') {
      Object.assign(vectors.line, opts);
      Object.assign(vectors.head, opts);
      if(opts.hasOwnProperty('id')) {
        vectors.line.id = opts.id + '-line';
        vectors.head.id = opts.id + '-head';
      }
    }
    
    var vertex_index = 0;
    var x_axis = [1, 0, 0];
    
    for(var i = 0; i < xi.length; i++) {
      var x0 = xi[i];
      var y0 = yi[i];
      var z0 = zi[i];
      var u = ui[i];
      var v = vi[i];
      var w = wi[i];
      
      var vector = [u, v, w];
      
      // Calculate the length of the vector
      var length = this.jsl.env.math.norm(vector);
      if(length === 0) continue; // Skip zero-length vectors

      // Normalize the direction vector
      var dir = this.jsl.array.normalizeVector(vector);

      // Compute rotation matrix to rotate from x-axis to dir
      var R = this.getRotationMatrix(x_axis, dir);

      // Scale factor is the length of the vector
      var scale_factor = length;

      // Translation vector is the starting point (x0, y0, z0)
      var translation = [x0, y0, z0];

      // Transform the unit arrow points
      var transformed_points = this.transform(unit_arrow_points, scale_factor, R, translation);

      // Extract points
      var shaft_start_rot = transformed_points[0];
      var shaft_end_rot = transformed_points[1];
      var arrow_tip_rot = transformed_points[2];
      var arrow_left_rot = transformed_points[3];
      var arrow_right_rot = transformed_points[4];

      // Add shaft line to lines arrays
      vectors.line.x.push(shaft_start_rot[0], shaft_end_rot[0], null);
      vectors.line.y.push(shaft_start_rot[1], shaft_end_rot[1], null);
      vectors.line.z.push(shaft_start_rot[2], shaft_end_rot[2], null);

      // Add arrowhead edges to lines arrays
      vectors.line.x.push(
        arrow_tip_rot[0], arrow_left_rot[0], null,
        arrow_left_rot[0], arrow_right_rot[0], null,
        arrow_right_rot[0], arrow_tip_rot[0], null
      );
      vectors.line.y.push(
        arrow_tip_rot[1], arrow_left_rot[1], null,
        arrow_left_rot[1], arrow_right_rot[1], null,
        arrow_right_rot[1], arrow_tip_rot[1], null
      );
      vectors.line.z.push(
        arrow_tip_rot[2], arrow_left_rot[2], null,
        arrow_left_rot[2], arrow_right_rot[2], null,
        arrow_right_rot[2], arrow_tip_rot[2], null
      );

      // Add arrowhead vertices to mesh arrays
      vectors.head.x.push(arrow_tip_rot[0], arrow_left_rot[0], arrow_right_rot[0]);
      vectors.head.y.push(arrow_tip_rot[1], arrow_left_rot[1], arrow_right_rot[1]);
      vectors.head.z.push(arrow_tip_rot[2], arrow_left_rot[2], arrow_right_rot[2]);

      // Define the face for the current arrowhead
      vectors.head.i.push(vertex_index);
      vectors.head.j.push(vertex_index + 1);
      vectors.head.k.push(vertex_index + 2);

      // Update vertex index for the next arrow
      vertex_index += 3;
    }
    return vectors;
  }
  
  /**
   * Creates 3D disks for plotting based on provided parameters.
   * @param {number[]} xi - X coordinates of disk centers.
   * @param {number[]} yi - Y coordinates of disk centers.
   * @param {number[]} zi - Z coordinates of disk centers.
   * @param {number[]} ri - Radii of the disks.
   * @param {number[]} ui - X components of normal vectors (for disk orientation).
   * @param {number[]} vi - Y components of normal vectors (for disk orientation).
   * @param {number[]} wi - Z components of normal vectors (for disk orientation).
   * @param {Object} opts - Additional plotting options.
   * @returns {Object} - An object containing line and area trace data for plotting.
   */
  createDisks3D(xi, yi, zi, ri, ui, vi, wi, opts = {}) {
    if(!Array.isArray(xi)) xi = [xi];
    if(!Array.isArray(yi)) yi = [yi];
    if(!Array.isArray(zi)) zi = [zi];
    if(!Array.isArray(ri)) ri = [ri];
    if(!Array.isArray(ui)) ui = [ui];
    if(!Array.isArray(vi)) vi = [vi];
    if(!Array.isArray(wi)) wi = [wi];
    if(ri.length === 1 && xi.length > 1) ri = new Array(xi.length).fill(ri[0]);
    
    var segments = opts.segments || 32;
    delete opts.segments;
    
    var disks = {
      line: {
        x: [],
        y: [],
        z: [],
        type: 'scatter3d', color: '#00f', mode: 'lines', showLegend: false
      },
      area: {
        x: [],
        y: [],
        z: [],
        i: [],
        j: [],
        k: [],
        type: 'mesh3d', color: '#00f', opacity: 1, flatShading: true, 
        showScale: false, showLegend: false, lighting: {ambient: 1}
      }
    };
    
    if(typeof opts == 'object') {
      Object.assign(disks.line, opts);
      Object.assign(disks.area, opts);
      if(opts.hasOwnProperty('id')) {
        disks.line.id = opts.id + '-line';
        disks.area.id = opts.id + '-area';
      }
    }
    
    var vertex_index = 0;
    var z_axis = [0, 0, 1]; // Assuming disk normal initially aligns with x-axis

    // Create a unit circle in the XY plane for the disk
    var points = [...this.circle(1, segments)];

    for(var i = 0; i < xi.length; i++) {
      var x0 = xi[i];
      var y0 = yi[i];
      var z0 = zi[i];
      var radius = ri[i];
      var normal = [ui[i], vi[i], wi[i]];

      if(radius === 0) continue; // Skip zero-radius disks

      // Normalize the normal vector to ensure it's a unit vector
      var dir = this.jsl.array.normalizeVector(normal);

      // Compute rotation matrix to rotate from x-axis to the normal vector
      var R = this.getRotationMatrix(z_axis, dir);

      // Translation vector is the disk center point
      var translation = [x0, y0, z0];

      var circle = [...points];
      
      // Transform the circle points to the correct position and orientation
      var transformed_points = this.transform(circle, radius, R, translation);

      // Add circle outline to line data for edges
      for(var j = 0; j < transformed_points.length; j++) {
        var point = transformed_points[j];
        disks.line.x.push(point[0]);
        disks.line.y.push(point[1]);
        disks.line.z.push(point[2]);
        if(j === transformed_points.length - 1) {
          disks.line.x.push(transformed_points[0][0], null); // Connect last to first point
          disks.line.y.push(transformed_points[0][1], null);
          disks.line.z.push(transformed_points[0][2], null);
        }
      }
      disks.line.x.push(null);
      disks.line.y.push(null);
      disks.line.z.push(null);
          
      // Add all points for mesh (area) data
      for(var j = 0; j < transformed_points.length; j++) {
        var point = transformed_points[j];
        disks.area.x.push(point[0]);
        disks.area.y.push(point[1]);
        disks.area.z.push(point[2]);
      }

      // Triangulation for mesh
      for(var j = 1; j < transformed_points.length - 1; j++) {
        disks.area.i.push(vertex_index);
        disks.area.j.push(vertex_index + j);
        disks.area.k.push(vertex_index + j + 1);
      }

      vertex_index += transformed_points.length;
    }
    return disks;
  }
  
  /**
   * Creates a rectangular planes in 3D space, oriented by a normal vector [u, v, w].
   * @param {number[]} xi - X coordinates of planes centers.
   * @param {number[]} yi - Y coordinates of planes centers.
   * @param {number[]} zi - Z coordinates of planes centers.
   * @param {number[]} width_i    - Width of the rectangle.
   * @param {number[]} height_i   - Height of the rectangle.
   * @param {number[]} ui        - X component of the plane's normal vector.
   * @param {number[]} vi        - Y component of the plane's normal vector.
   * @param {number[]} wi        - Z component of the plane's normal vector.
   * @param {Object} opts     - Additional plotting options (color, opacity, etc.).
   * @returns {Object}        - An object containing line and area trace data for plotting.
   */
  createPlanes3D(xi, yi, zi, width_i, height_i, ui, vi, wi, opts) {
    if(!Array.isArray(xi)) xi = [xi];
    if(!Array.isArray(yi)) yi = [yi];
    if(!Array.isArray(zi)) zi = [zi];
    if(!Array.isArray(width_i)) width_i = [width_i];
    if(!Array.isArray(height_i)) height_i = [height_i];
    if(!Array.isArray(ui)) ui = [ui];
    if(!Array.isArray(vi)) vi = [vi];
    if(!Array.isArray(wi)) wi = [wi];
    if(width_i.length === 1 && xi.length > 1) width_i = new Array(xi.length).fill(width_i[0]);
    if(height_i.length === 1 && xi.length > 1) height_i = new Array(xi.length).fill(height_i[0]);
    
    const planes = {
      line: {
        x: [],
        y: [],
        z: [],
        type: 'scatter3d',
        color: '#00f',
        mode: 'lines',
        showLegend: false
      },
      area: {
        x: [],
        y: [],
        z: [],
        i: [],
        j: [],
        k: [],
        type: 'mesh3d',
        color: '#00f',
        opacity: 1,
        flatShading: true,
        showScale: false,
        showLegend: false,
        lighting: { ambient: 1 }
      }
    };

    // Merge any provided opts into our line & area objects
    if(typeof opts === 'object') {
      Object.assign(planes.line, opts);
      Object.assign(planes.area, opts);
      if(opts.hasOwnProperty('id')) {
        planes.line.id = opts.id + '-line';
        planes.area.id = opts.id + '-area';
      }
    }

    // Reference axis (z-axis) that our rectangle initially lies in (XY-plane).
    // We will rotate from z-axis to our normal.
    const z_axis = [0, 0, 1];
    
    for(var i = 0; i < ui.length; i++) {
      // Create a symmetrical rectangle in the XY-plane, centered at (0,0,0)
      const rect_coords = this.symRectangle(width_i[i], height_i[i], 0);

      // Convert that flat array into point-triplets:
      var rectangle_points = [];
      for(let i = 0; i < rect_coords.length; i += 3) {
        rectangle_points.push([rect_coords[i], rect_coords[i + 1], rect_coords[i + 2]]);
      }
    
      // Normal vector
      const normal = [ui[i], vi[i], wi[i]];
      
      // Normalize the plane normal
      const dir = this.jsl.array.normalizeVector(normal);

      // Compute rotation matrix to rotate a plane (lying in XY-plane) so its normal aligns with 'dir'
      const R = this.getRotationMatrix(z_axis, dir);
      
      // Rotate these points according to R
      // No scaling or translation is applied here. If you want to shift it to [x0,y0,z0], just add that translation.
      rectangle_points = this.transform(rectangle_points, 1.0, R, [xi[i], yi[i], zi[i]]);

      // Build the line trace: push each consecutive segment plus a null to break the stroke
      for(let j = 0; j < rectangle_points.length; j++) {
        var [x, y, z] = rectangle_points[j];
        planes.line.x.push(x);
        planes.line.y.push(y);
        planes.line.z.push(z);
      }
      // Insert null to break the line
      planes.line.x.push(null);
      planes.line.y.push(null);
      planes.line.z.push(null);

      // Build the mesh: we only need the first 4 unique corners for a rectangle
      // (the 5th is a repeat of the 1st).
      // Triangulate the rectangle as two triangles: (0,1,2) and (0,2,3)
      const n = 4; // We only take indices 0..3
      const base_index = 0;

      for(let j = 0; j < n; j++) {
        planes.area.x.push(rectangle_points[j][0]);
        planes.area.y.push(rectangle_points[j][1]);
        planes.area.z.push(rectangle_points[j][2]);
      }
      // Two triangles to form the quad
      planes.area.i.push(base_index, base_index);
      planes.area.j.push(base_index + 1, base_index + 2);
      planes.area.k.push(base_index + 2, base_index + 3);
    }
    return planes;
  }

  /**
   * Creates a lines in 3D space.
   * @param {number[]} x1i - X1 coordinates of lines.
   * @param {number[]} y1i - Y1 coordinates of lines.
   * @param {number[]} z1i - Z1 coordinates of lines.
   * @param {number[]} x2i - X2 coordinates of lines.
   * @param {number[]} y2i - Y2 coordinates of lines.
   * @param {number[]} z2i - Z2 coordinates of lines.
   * @returns {Object} - lines object.
   */
  createLines3D(x1i, y1i, z1i, x2i, y2i, z2i, opts) {
    if(!Array.isArray(x1i)) x1i = [x1i];
    if(!Array.isArray(y1i)) y1i = [y1i];
    if(!Array.isArray(z1i)) z1i = [z1i];
    if(!Array.isArray(x2i)) x2i = [x2i];
    if(!Array.isArray(y2i)) y2i = [y2i];
    if(!Array.isArray(z2i)) z2i = [z2i];
    
    const lines = {
      x: [],
      y: [],
      z: [],
      type: 'scatter3d',
      color: '#00f',
      mode: 'lines',
      showLegend: false
    };

    // Merge any provided opts into our line & area objects
    if(typeof opts === 'object') {
      Object.assign(lines, opts);
    }
    
    for(var i = 0; i < x1i.length; i++) {
      lines.x.push(x1i[i], x2i[i], null);
      lines.y.push(y1i[i], y2i[i], null);
      lines.z.push(z1i[i], z2i[i], null);
    }
    return lines;
  }

  /**
   * Creates a points in 3D space.
   * @param {number[]} xi - X coordinates of points.
   * @param {number[]} yi - Y coordinates of points.
   * @param {number[]} zi - Z coordinates of points.
   * @returns {Object} - points object.
   */
  createPoints3D(xi, yi, zi, opts) {
    if(!Array.isArray(xi)) xi = [xi];
    if(!Array.isArray(yi)) yi = [yi];
    if(!Array.isArray(zi)) zi = [zi];
    
    const points = {
      x: [],
      y: [],
      z: [],
      type: 'scatter3d',
      color: '#00f',
      mode: 'markers',
      showLegend: false
    };

    // Merge any provided opts into our line & area objects
    if(typeof opts === 'object') {
      Object.assign(points, opts);
    }
    
    for(var i = 0; i < xi.length; i++) {
      points.x.push(xi[i], null);
      points.y.push(yi[i], null);
      points.z.push(zi[i], null);
    }
    return points;
  }

  /**
   * Creates a points in 3D space.
   * @param {number[]} xi - X coordinates of points.
   * @param {number[]} yi - Y coordinates of points.
   * @param {number[]} zi - Z coordinates of points.
   * @returns {Object} - points object.
   */
  createText3D(xi, yi, zi, texti, dxi, dyi, dzi, opts) {
    if(!Array.isArray(xi)) xi = [xi];
    if(!Array.isArray(yi)) yi = [yi];
    if(!Array.isArray(zi)) zi = [zi];
    if(!Array.isArray(texti)) texti = [texti];
    if(!Array.isArray(dxi)) dxi = [dxi];
    if(!Array.isArray(dyi)) dyi = [dyi];
    if(!Array.isArray(dzi)) dzi = [dzi];
    if(dxi.length === 1 && xi.length > 1) dxi = new Array(xi.length).fill(dxi[0]);
    if(dyi.length === 1 && yi.length > 1) dyi = new Array(yi.length).fill(dyi[0]);
    if(dzi.length === 1 && zi.length > 1) dzi = new Array(zi.length).fill(dzi[0]);
    
    const texts = {
      x: [],
      y: [],
      z: [],
      text: [],
      type: 'scatter3d',
      textposition: 'center middle',
      textfont: {
        size: 18,
        color: '#f00'
      },
      mode: 'text',
      showLegend: false
    };

    // Merge any provided opts into our line & area objects
    if(typeof opts === 'object') {
      Object.assign(texts, opts);
    }
    
    for(var i = 0; i < xi.length; i++) {
      texts.x.push(plus(xi[i], dxi[i]));
      texts.y.push(plus(yi[i], dyi[i]));
      texts.z.push(plus(zi[i], dzi[i]));
      texts.text.push(texti[i]);
    }
    return texts;
  }
  
  /**
   * Creates a symmetrical rectangle in 3D space.
   * @param {number} W - Width of the rectangle.
   * @param {number} H - Height of the rectangle.
   * @param {number} [Z=0] - Z-coordinate for the rectangle plane.
   * @returns {number[]} - Array of vertex coordinates for the rectangle.
   */
  symRectangle(W, H, Z = 0) {
    return [W/2, H/2, Z, 
      -W/2, H/2, Z,
      -W/2, -H/2, Z,
      W/2, -H/2, Z,
      W/2, H/2, Z];
  }

  /**
   * Helper method to generate points for a circle in the XY plane.
   * @param {number} radius - Radius of the circle.
   * @param {number} segments - Number of segments for the circle.
   * @returns {number[][]} - Array of points forming the circle.
   */
  circle(radius, segments) {
    var points = [];
    for(var i = 0; i < segments; i++) {
      var angle = 2 * Math.PI * i / segments;
      points.push([radius * Math.cos(angle), radius * Math.sin(angle), 0]);
    }
    return points;
  }

  /**
   * Helper method to generate points for a disk in the XY plane.
   * @param {number} radius - Radius of the disk.
   * @param {number} segments_a - Number of angular segments for the disk.
   * @param {number} segments_r - Number of radial segments for the disk.
   * @returns {number[][]} - Array of points forming the disk.
   */
  disk(radius, segments_a, segments_r) {
    var points = [];
    points.push([0, 0, 0]);
    for(var j = 1; j <= segments_r; j++) {
      var r = radius * j / segments_r;
      for(var i = 1; i <= segments_a; i++) {
        var angle = 2 * Math.PI * i / segments_a;
        points.push([r * Math.cos(angle), r * Math.sin(angle), 0]);
      }
    }
    return points;
  }
  
  /**
   * Generates the boundary of a 3D shape based on points and a shrink factor.
   * @param {number[][]} points - Array of points defining the shape.
   * @param {number} [shrink=0.5] - Factor by which to shrink the boundary.
   * @returns {Array} - An array containing boundary facets and the volume.
   */
  boundary3D(points, shrink = 0.5) {
    var shp = new this.jsl.env.AlphaShape3D(); 
    shp.newShape(points);
    
    var Acrit = shp.getCriticalAlpha('one-region');
    var spec = shp.getAlphaSpectrum();
    
    var idx = spec.indexOf(Acrit);
    var subspec = spec.slice(idx);
    
    var idx = Math.max(Math.ceil((1 - shrink) * subspec.length) - 1, 0);
    var alphaval = subspec[idx];

    shp.setAlpha(alphaval);
    var V = shp.getVolume();
    var bf = shp.getBoundaryFacets();
    shp = null;
    return [bf, V];
  }
        
  /**
   * Writes geometry data to an OFF file.
   * @param {string} filename - The path to the OFF file.
   * @param {number[][]} vertices - Array of vertex coordinates.
   * @param {number[][]} faces - Array of face indices.
   */
  writeOff(filename, vertices, faces) {
    var shp = new this.jsl.env.AlphaShape3D(); 
    shp.writeOff(filename, vertices, faces);
    shp = null;
  }

  /**
   * Reads an OFF file and returns the vertices and faces.
   * @param {string} filename - The path to the OFF file.
   * @returns {{ vertices: number[][], faces: number[][] }} - An object containing vertices and faces arrays.
   * @throws Will throw an error if the file cannot be read or is not a valid OFF file.
   */
  readOff(filename) {
    var data = this.jsl.env.readFileSync(filename, 'utf8');
    var tokens = data.split(/\s+/).filter(token => token.length > 0);
    if(tokens[0] !== 'OFF') {
      this.jsl.env.error('@readOff: '+language.string(193));
    }
    tokens.shift();
    if(tokens.length < 3) {
      this.jsl.env.error('@readOff: '+language.string(194));
    }
    
    var j = 0;
    tokens = tokens.map(x => parseFloat(x));
    
    var nvert = tokens[j++];
    var nface = tokens[j++];
    if(!isNaN(tokens[j])) {
      j++;
    }
    
    // Read vertex coordinates
    var vertices = createArray(nvert);
    var k = 0;
    for(var i = 0; i < nvert; i++) {
      if(j + 2 >= tokens.length) {
        this.jsl.env.error('@readOff: '+language.string(195));
        break;
      }
      vertices[k++] = [tokens[j++], tokens[j++], tokens[j++]];
    }
    
    // Read face data
    var faces = createArray(nface);
    var k = 0;
    for(let i = 0; i < nface; i++) {
      if(j >= tokens.length) {
        this.jsl.env.error('@readOff: '+language.string(196));
        break;
      }
      var vertices_per_face = tokens[j++];
      var face = [];
      for(let v = 0; v < vertices_per_face; v++) {
        face.push(tokens[j++]);
      }
      faces[k++] = face;
    }
    
    return [ vertices, faces ];
  }
}

exports.PRDC_JSLAB_LIB_GEOMETRY = PRDC_JSLAB_LIB_GEOMETRY;

/**
 * Class for JSLAB triangle.
 */
class PRDC_JSLAB_TRIANGLE {
  
  #jsl;
  
  /**
   * Creates a new triangle instance.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   * @param {Array} p1 - First vertex.
   * @param {Array} p2 - Second vertex.
   * @param {Array} p3 - Third vertex.
   */
  constructor(jsl, v1, v2, v3) {
    this.#jsl = jsl;
    this._set(v1, v2, v3);
  }
  
  /**
   * Sets the triangle vertices and edges.
   * @param {Array} v1 - First vertex.
   * @param {Array} v2 - Second vertex.
   * @param {Array} v3 - Third vertex.
   */
  _set(v1, v2, v3) {
    if(Array.isArray(v1[0])) {
      v3 = v1[2];
      v2 = v1[1];
      v1 = v1[0];
    }
    
    this.v1 = v1 || [];
    this.v2 = v2 || [];
    this.v3 = v3 || [];
    this.edges = [
      [v1, v2], [v2, v3], [v3, v1]
    ];
  }
  
  /**
   * Checks if the triangle's circumcircle contains a point.
   * @param {Array} point - The point to test.
   * @returns {boolean} True if inside the circumcircle.
   */
  circumcircleContains(point) {
    var ax = this.v1[0], ay = this.v1[1];
    var bx = this.v2[0], by = this.v2[1];
    var cx = this.v3[0], cy = this.v3[1];
    var dx = point[0], dy = point[1];

    var ax_ = ax - dx, ay_ = ay - dy;
    var bx_ = bx - dx, by_ = by - dy;
    var cx_ = cx - dx, cy_ = cy - dy;

    var det = (ax_ * ax_ + ay_ * ay_) * (bx_ * cy_ - cx_ * by_) -
              (bx_ * bx_ + by_ * by_) * (ax_ * cy_ - cx_ * ay_) +
              (cx_ * cx_ + cy_ * cy_) * (ax_ * by_ - bx_ * ay_);

    return det > 0;
  }
  
  /**
   * Determines if a point is inside the triangle.
   * @param {Array} point - The point to check.
   * @returns {boolean} True if the point is inside.
   */
  contains(point) {
    var sign = (v1, v2, v3) =>
      (v1[0] - v3[0]) * (v2[1] - v3[1]) - (v2[0] - v3[0]) * (v1[1] - v3[1]);

    var d1 = sign(point, this.v1, this.v2);
    var d2 = sign(point, this.v2, this.v3);
    var d3 = sign(point, this.v3, this.v1);

    return (d1 >= 0 && d2 >= 0 && d3 >= 0) 
      || (d1 <= 0 && d2 <= 0 && d3 <= 0);
  }
  
  /**
   * Computes the interpolated value at a point using barycentric coordinates.
   * @param {Array} point - The query point.
   * @returns {number} Interpolated value.
   */
  valueAt(point) {
    const denom = ((this.v2[1] - this.v3[1]) * (this.v1[0] - this.v3[0]) +
                   (this.v3[0] - this.v2[0]) * (this.v1[1] - this.v3[1]));
    
    // Compute barycentric coordinates
    const alpha = ((this.v2[1] - this.v3[1]) * (point[0] - this.v3[0]) +
                   (this.v3[0] - this.v2[0]) * (point[1] - this.v3[1])) / denom;
    const beta = ((this.v3[1] - this.v1[1]) * (point[0] - this.v3[0]) +
                  (this.v1[0] - this.v3[0]) * (point[1] - this.v3[1])) / denom;
    const gamma = 1 - alpha - beta;
    
    return alpha * this.v1[2] + beta * this.v2[2] + gamma * this.v3[2];
  }
}
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={gui.js}]
/**
 * @file JSLAB library gui submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB gui submodule.
 */
class PRDC_JSLAB_LIB_GUI {
  
  /**
   * Initializes the gui submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
    
    this.escape_html_map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;',
      '/': '&#x2F;',
      '`': '&#x60;',
      '=': '&#x3D;'
    };
  }
  
  /**
   * Escapes reserved HTML characters in a string to prevent injection or XSS.
   * @param {string} string The raw text whose special characters should be converted to HTML entities.
   * @returns {string} The sanitized string safe for insertion into the DOM.
   */
  escapeHTML(string) {
    return String(string).replace(/[&<>"'`=\/]/g, s => this.escape_html_map[s]);
  }
  
  /**
   * Reports whether an element participates in layout flow (i.e., is not `display:none`).
   * @param {HTMLElement|null} el The element to test for visibility in normal document flow.
   * @returns {boolean} `true` if the element has a non-null `offsetParent`; otherwise `false`.
   */
  isVisible(el) {
    return !!el && el.offsetParent !== null;
  }

  /**
   * Reads an input-like element’s value, escapes it for HTML, and returns the result.
   * @param {string|HTMLElement} el_or_sel The element itself or a selector/ID string used to locate it.
   * @returns {string} The escaped string value, or an empty string if the element is not found.
   */
  getElVal(el_or_sel) {
    return this.escapeHTML(this._readVal(this._resolveEl(el_or_sel)));
  }
  
  /**
   * Reads an input-like element’s value, converts it to a number, and returns the result.
   * @param {string|HTMLElement} el_or_sel The element itself or a selector/ID string used to locate it.
   * @returns {number} The numeric value or `NaN` if conversion fails.
   */
  getElValNum(el_or_sel) {
    return Number(this._readVal(this._resolveEl(el_or_sel)));
  }

  /**
   * Attaches `input` and `change` listeners to a slider and forwards events to a callback.
   * @param {string|HTMLElement} el The slider element or a selector for delegated listening.
   * @param {Function} fun The function to invoke each time the slider emits `input` or `change`.
   */
  onSliderInput(el, fun) {
    var handler = function (e) { fun.call(this, e); };

    if(typeof el === 'string') {
      var doc = this._resolveDoc(el);
      this._delegate(doc, 'input', el, () => true, handler);
      this._delegate(doc, 'change', el, () => true, handler);
    } else {
      var n = el;
      n.addEventListener('input', handler);
      n.addEventListener('change', handler);
    }
  }
  
  /**
   * Fires a callback when an input loses focus or the user presses Enter, with optional delegation.
   * @param {string|HTMLElement} el Target element or CSS selector for delegation.
   * @param {Function} fun Callback executed with `this` bound to the element that triggered the event.
   * @param {Function} [validator] Optional predicate that must return `true` for the callback to fire.
   */
  onInput(el, fun, validator) {
    if(typeof el === 'string') {
      var doc = this._resolveDoc(el);
      this._delegate(doc, 'focusout', el, () => true, fun, true);
      this._delegate(doc, 'keyup', el, e => e.keyCode === this._ENTER, fun);
    } else {
      var nodes = this._resolveEls(el);
      nodes.forEach(n => {
        n.addEventListener('blur', e => fun.call(n, e));
        n.addEventListener('keyup', e => {
          if(e.keyCode === this._ENTER) fun.call(n, e);
        });
      });
    }
  }

  /**
   * Detects actual value changes in an input and invokes a callback after validation.
   * @param {string|HTMLElement} el Target element or selector for delegated listening.
   * @param {Function} fun Callback executed when the value truly changes.
   * @param {Function} [validator] Optional predicate to approve or reject the change.
   */
  onInputChange(el, fun, validator) {
    var initLastVal = n =>
      n.setAttribute('last-val', this.escapeHTML(this._readVal(n)));

    var hasChanged = n =>
      this.escapeHTML(this._readVal(n)) !== n.getAttribute('last-val');

    var maybeFire = (n, e) => {
      if(!hasChanged(n)) return;

      if(typeof validator === 'function' && !validator.call(this, n, e)) {
        n.value = n.getAttribute('last-val');
        n.focus();
        this.addClassMs(n, 'error', 400); 
        return;
      }

      initLastVal(n);
      fun.call(n, e); 
    };

    this._resolveEls(el).forEach(initLastVal);

    if(typeof el === 'string') {
      var always = () => true;
      var doc = this._resolveDoc(el);
      this._delegate(doc, 'focusout', el, always, e => maybeFire(e.target, e), true);
      this._delegate(doc, 'keyup', el, e => e.keyCode === this._ENTER, e => maybeFire(e.target, e));
      this._delegate(doc, 'change', el, always, e => maybeFire(e.target, e));
    } else {
      var n = el;
      ['blur', 'change'].forEach(t => n.addEventListener(t, e => maybeFire(n, e)));
      n.addEventListener('keyup', e => {
        if(e.keyCode === this._ENTER) maybeFire(n, e);
      });
    }
  }

  /**
   * Like `onInputChange` but triggers only while the element remains focused (active input).
   * @param {string|HTMLElement} el Target element or selector for delegated listening.
   * @param {Function} fun Callback executed when the value changes during active editing.
   * @param {Function} [validator] Optional predicate to approve or reject the change.
   */
  onActiveInputChange(el, fun, validator) {
    var initLastVal = n =>
      n.setAttribute('last-val', this.escapeHTML(this._readVal(n)));

    var maybeFire = (n, e) => {
      if(!hasChanged(n)) return;

      if(typeof validator === 'function' && !validator.call(this, n, e)) {
        n.value = n.getAttribute('last-val');
        n.focus();
        this.addClassMs(n, 'error', 400); 
        return;
      }

      initLastVal(n);
      fun.call(n, e); 
    };

    this._resolveEls(el).forEach(initLastVal);

    if(typeof el === 'string') {
      var doc = this._resolveDoc(el);
      this._delegate(doc, 'focusout', el, () => true, e => maybeFire(e.target, e), true);
      this._delegate(doc, 'keyup', el, e => e.keyCode === this._ENTER, e => maybeFire(e.target, e));
    } else {
      var n = el;
      n.addEventListener('blur', e => maybeFire(n, e));
      n.addEventListener('keyup', e => {
        if(e.keyCode === this._ENTER) maybeFire(n, e);
      });
    }
  }
  
  /**
   * Programmatically sets an input’s value and records it as the baseline for change tracking.
   * @param {string|HTMLElement} el_or_sel The input element or selector identifying it.
   * @param {string|number} val The value to assign and remember as the “set” value.
   */
  setInputValue(el_or_sel, val) {
    var n = this._resolveEl(el_or_sel);
    if(!n) return;
    n.value = val;
    n.setAttribute('last-val', String(val));
    n.setAttribute('set-val',  String(val));
  }

  /**
   * Updates an input’s value only if it is different from the current content, and records it.
   * @param {string|HTMLElement} el_or_sel The input element or selector identifying it.
   * @param {string|number} val The new value to write and store as the baseline.
   */
  updateInputValue(el_or_sel, val) {
    var n = this._resolveEl(el_or_sel);
    if(!n) return;
    if(n.value != val) {
      n.value = val;
      n.setAttribute('last-val', String(val));
      n.setAttribute('set-val',  String(val));
    }
  }
  
  /**
   * Restores an input to the value previously stored with `setInputValue`.
   * @param {string|HTMLElement} el_or_sel The input element or selector identifying it.
   */
  resetInputValue(el_or_sel) {
    var n = this._resolveEl(el_or_sel);
    if(!n) return;
    var v = n.getAttribute('set-val');
    if(v !== null) n.value = v;
  }

  /**
   * Adds or removes the `changed` CSS class based on whether the current value differs from the stored baseline.
   * @param {string|HTMLElement} el_or_sel The input element or selector identifying it.
   */
  showInputChanged(el_or_sel) {
    var n = this._resolveEl(el_or_sel);
    if(!n) return;
    var set_val = n.getAttribute('set-val') ?? '';
    n.classList.toggle('changed', String(n.value) !== set_val);
  }

  /**
   * Validates that an input contains a numeric value and briefly highlights errors.
   * @param {string|HTMLElement} el_or_sel The input element or selector identifying it.
   * @returns {Array} Tuple of the parsed number and a validity flag.
   */
  validateInputNumber(el_or_sel) {
    var n = this._resolveEl(el_or_sel);
    if(!n) return [NaN, false];
    var str = this._readVal(n).trim();
    var num = Number(str);
    if(str === '' || Number.isNaN(num)) {
      n.focus();
      this.addClassMs(n, 'error', 400);
      return [num, false];
    }
    return [num, true];
  }
  
  /**
   * Sets an input’s value and temporarily applies a `warning` class for visual feedback.
   * @param {string|HTMLElement} el_or_sel The input element or selector identifying it.
   * @param {string|number} val The value to assign before flashing the warning.
   */
  setInputWithWarning(el_or_sel, val) {
    var n = this._resolveEl(el_or_sel);
    if(!n) return;
    n.value = val;
    this.addClassMs(n, 'warning', 400);
  }

  /**
   * Adds a CSS class to an element for a specified duration, then removes it.
   * @param {HTMLElement} node The element to which the class will be applied.
   * @param {string} cls The CSS class name to toggle.
   * @param {number} ms The number of milliseconds to keep the class before removal.
   */
  addClassMs(node, cls, ms) {
    node.classList.add(cls);
    setTimeout(() => node.classList.remove(cls), ms);
  }

  /**
   * Observes an element’s size changes and reports each new `contentRect` to a callback.
   * @param {string|HTMLElement} el_or_sel The element or selector to observe.
   * @param {Function} cb Callback that receives the `ResizeObserverEntry.contentRect` whenever the element resizes.
   * @returns {ResizeObserver|undefined} The observer instance, or `undefined` if the element is not found.
   */
  onResize(el_or_sel, cb) {
    var el = this._resolveEl(el_or_sel);
    if(!el) return;
    var ro = new ResizeObserver(ent => cb(ent[0].contentRect));
    ro.observe(el);
    return ro;
  }

  /**
   * Converts various inputs into an array of HTMLElements.
   * @param {string|HTMLElement|NodeList|Iterable<HTMLElement>} el_or_sel Element, selector, or collection to resolve.
   * @returns {HTMLElement[]} An array of resolved elements (possibly empty).
   */
  _resolveEls(el_or_sel) {
    if(!el_or_sel) return [];
    if(typeof el_or_sel === 'string') {
      return Array.from(document.querySelectorAll(el_or_sel));
    }
    if(el_or_sel.nodeType === 1) {
      return [el_or_sel];
    }
    if(typeof el_or_sel[Symbol.iterator] === 'function') {
      return Array.from(el_or_sel).filter(n => n?.nodeType === 1);
    }
    return [];
  }

  /**
   * Resolves and returns the first HTMLElement that matches the input reference.
   * @param {string|HTMLElement} el_or_sel Element or selector used to locate one element.
   * @returns {HTMLElement|null} The matched element or `null` if none found.
   */
  _resolveEl(el_or_sel) {
    return this._resolveEls(el_or_sel)[0] ?? null;
  }
  
  /**
   * Retrieves the textual value from an input-type or content-editable element.
   * @param {HTMLElement} el The element whose value or text content should be read.
   * @returns {string} The raw string content of the element.
   */
  _readVal(el) {
    return el.matches('[contenteditable]') ? el.textContent : el.value;
  }
  
  /**
   * Determines the appropriate `Document` context for a given element or selector.
   * @param {string|Node} el_or_sel Element, node list, or selector used to infer a document.
   * @returns {Document} The resolved document object.
   */
  _resolveDoc(el_or_sel) {
    if(typeof el_or_sel !== 'string' && el_or_sel?.ownerDocument)
      return el_or_sel.ownerDocument;
    return document;
  }

  /**
   * Registers a delegated event listener that triggers a handler when the target matches a selector and passes an optional filter.
   * @param {Document|ShadowRoot} doc The root node on which to listen for the event.
   * @param {string} type The event type to listen for (e.g., `"keyup"`).
   * @param {string} selector The CSS selector that qualifying targets must match.
   * @param {Function} filter Predicate that further filters qualifying events.
   * @param {Function} handler Function executed with `this` bound to the event target.
   * @param {boolean} [useCapture=false] Whether to attach the listener in the capture phase.
   */
  _delegate(doc, type, selector, filter, handler, useCapture = false) {
    doc.addEventListener(
      type,
      e => {
        const t = e.target;
        if(t && t.matches(selector) && filter(e)) handler.call(t, e);
      },
      useCapture
    );
  }
}

exports.PRDC_JSLAB_LIB_GUI = PRDC_JSLAB_LIB_GUI;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={init-sandbox.js}]
/**
 * @file JSLAB sandbox window init file
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
// Modules
// --------------------
const helper = require("../js/helper.js");
require("../js/init-config.js");
const { PRDC_JSLAB_LANGUAGE } = require('../js/language');

global.app_path = process.argv.find(e => e.startsWith('--app-path=')).split('=')[1].replace(/\\js\\?$/, '');

const { PRDC_JSLAB_LIB } = require('../js/sandbox/jslab');

// Global variables
global.language = new PRDC_JSLAB_LANGUAGE();
var jsl = new PRDC_JSLAB_LIB();

if(config.TEST) {
  const { PRDC_JSLAB_TESTER } = require("../js/tester.js");
  tester = new PRDC_JSLAB_TESTER('sandbox');
  tester.runTests();
}
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={init-worker.js}]
/**
 * @file Init worker
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */
"use strict";

global.fs = require('fs');
global.path = require('path');
global.app_path = process.argv.find(e => e.startsWith('--app-path=')).split('=')[1].replace(/\\js\\?$/, '');

// Global variables
global.win = self;
global.worker_module;

/**
 * Handle messages
 */
self.addEventListener("message", function(e) {
  if(e.data.type == 'configureWorker') {
    var { PRDC_WORKER } = require(e.data.module_path);
    global.worker_module = new PRDC_WORKER();
  } else if(global.worker_module && e.data.hasOwnProperty('method')) {
    global.worker_module[e.data.method](e.data);
  }
});
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={jslab-env-electron.js}]
/**
 * @file JSLAB electron environment
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
  
if(!global.is_worker) {
  var { ipcRenderer } = require('electron');  
}

const { PRDC_JSLAB_FREECAD_LINK } = require('./freecad-link');
const { PRDC_JSLAB_OPENMODELICA_LINK } = require('./om-link');

const fs = require("fs");
const os = require('os');
const net = require('net');
const udp = require('dgram');
const cp = require("child_process");
const path = require("path");
const tcpPortUsed = require('tcp-port-used');
const { pathEqual } = require('path-equal');
const { Readable, Writable } = require('stream');
const { NativeModule } = require(app_path + '/build/Release/native_module');
const { AlphaShape3D } = require(app_path + '/build/Release/alpha_shape_3d');
const { extractFull } = require('node-7z');
const seedrandom = require('seedrandom');
const bin7zip = require('7zip-bin').path7za;
const PDFDocument = require('pdfkit');
const SVGtoPDF = require('svg-to-pdfkit');
const { PolynomialRegression } = require('ml-regression-polynomial');
const recast = require('recast');
const babel_parser = require('@babel/parser');
var SourceMapConsumer = require("source-map").SourceMapConsumer;
var { SerialPort } = require('serialport');
const jsdoc = require('jsdoc-api');

/**
 * Class for JSLAB electron environment.
 */
class PRDC_JSLAB_ENV {

  /**
   * Constructs a electron environment submodule object with access to JSLAB's electron environment functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;

    if(!global.is_worker) {
      this.context = window;
      this.debug = ipcRenderer.sendSync("sync-message", "get-debug-flag");
      this.version = ipcRenderer.sendSync("sync-message", "get-app-version");
      this.exe_path = ipcRenderer.sendSync("sync-message", "get-path", "exe");
      this.platform = ipcRenderer.sendSync("sync-message", "get-platform");
      this.speech = new SpeechSynthesisUtterance();
      this.speech.voice = speechSynthesis.getVoices()[0];
      this.navigator = navigator;
      this.processors_number = navigator.hardwareConcurrency;
      this.Cesium = Cesium;
      this.online = this.navigator.onLine;
      function onOnlineChange() {
        obj.online = obj.navigator.onLine;
      }
      this.context.addEventListener('online', onOnlineChange);
      this.context.addEventListener('offline', onOnlineChange);
    } else {
      this.context = global;
      this.debug = global.debug;
      this.version = global.version;
      this.exe_path = undefined;
      this.platform = global.platform;
      this.processors_number = undefined;
      this.Cesium = {};
    }
    this.native_module = new NativeModule();
    this.AlphaShape3D = AlphaShape3D;
    this.bin7zip = bin7zip;
    this.seedRandom = seedrandom;
    this.extractFull = extractFull;
    
    this.process_pid = process.pid;
    this.math = this.context.math;
    this.fmin = this.context.fmin;
    this.PDFDocument = PDFDocument;
    this.SVGtoPDF = SVGtoPDF;
    this.PolynomialRegression = PolynomialRegression;
    this.os = os;
    this.net = net;
    this.udp = udp;
    this.tcpPortUsed = tcpPortUsed;
    this.recast = recast;
    this.babel_parser = babel_parser;
    this.SourceMapConsumer = SourceMapConsumer;
    this.SourceMapConsumer.initialize({
      "lib/mappings.wasm": app_path+'/node_modules/source-map/lib/mappings.wasm',
    });
    this.SerialPort = SerialPort;
    this.jsdoc = jsdoc;
    
    this.context.freecad_link = new PRDC_JSLAB_FREECAD_LINK(this.jsl);
    this.context.om_link = new PRDC_JSLAB_OPENMODELICA_LINK(this.jsl);
    
    // On IPC message
    if(!global.is_worker) {
      ipcRenderer.on("SandboxWindow", function(event, action, data) {
        switch(action) {
          case "eval-code":
            obj.jsl.eval.evalCodeFromMain(...data);
            break;
          case "get-completions":
            ipcRenderer.send("completions-" + data[0], obj.jsl.basic.getCompletions(data));
            break;
          case "stop-loop":
            obj.jsl.setStopLoop(data);
            break;
          case "run-last-script":
            obj.jsl.eval.runLast();
            break;
          case "set-current-path":
            obj.jsl.setPath(data);
            break;
          case "set-saved-paths":
            obj.jsl.setSavedPaths(data);
            break;
          case "set-language":
            language.set(data);
            obj.jsl.figures._updateLanguage();
            obj.jsl.windows._updateLanguage();
            break;
        }
      });
    }
    
    // Functions
    this.setImmediate = this.context.setImmediate;
    this.clearImmediate = this.context.clearImmediate;
    this.pathEqual = pathEqual;
    this.Readable = Readable;
    this.Writable = Writable;
    
    // Which properties and methods to export to context
    this.exports = ['debug', 'version', 'platform'];
  }
  
  /**
   * Opens a window based on the provided ID.
   * @param {number} id - The ID of the window to open.
   * @returns {(boolean|BrowserWindow)} - The opened window or false if the window does not exist.
   */
  openWindow(wid, file = "blank.html") {
    if(!global.is_worker) {
      var obj = this;
      var sub_context = this.context.open(file, wid);
      sub_context.addEventListener("error", function(err) {
        if(err && err.hasOwnProperty('error')) {
          obj.error(err.error.stack);
        } else {
          obj.error(err.message);
        }
      });
      
      var loadCheckInterval = setInterval(function() {
        try {
          if(isFinite(sub_context.wid)) {
            clearInterval(loadCheckInterval);
          }
        } catch {
          sub_context.close();
          obj.jsl.windows._closedWindow(wid);
          clearInterval(loadCheckInterval);
          obj.error('@openWindow: '+language.string(174));
        }
      }, 10);

      return [sub_context, new Promise(function(resolve) {
        sub_context.addEventListener("DOMContentLoaded", function() {
          sub_context.wid = wid;
          
          sub_context.show = function() {
            return obj.jsl.windows.open_windows[wid].show();
          };
          sub_context.hide = function() {
            return obj.jsl.windows.open_windows[wid].hide();
          };
          sub_context.focus = function() {
            return obj.jsl.windows.open_windows[wid].focus();
          };
          sub_context.minimize = function() {
            return obj.jsl.windows.open_windows[wid].minimize();
          };
          sub_context.center = function() {
            return obj.jsl.windows.open_windows[wid].center();
          };
          sub_context.moveTop = function() {
            return obj.jsl.windows.open_windows[wid].moveTop();
          };
          
          
          sub_context.setSize = function(width, height) {
            return obj.jsl.windows.open_windows[wid].setSize(width, height);
          };
          sub_context.setPos = function(left, top) {
            return obj.jsl.windows.open_windows[wid].setPos(left, top);
          };
          sub_context.setResizable = function(state) {
            return obj.jsl.windows.open_windows[wid].setResizable(state);
          };
          sub_context.setMovable = function(state) {
            return obj.jsl.windows.open_windows[wid].setMovable(state);
          };
          sub_context.setAspectRatio = function(aspect_ratio) {
            return obj.jsl.windows.open_windows[wid].setMovable(aspect_ratio);
          };
          sub_context.setOpacity = function(opacity) {
            return obj.jsl.windows.open_windows[wid].setOpacity(opacity);
          };
          sub_context.setFullscreen = function(state) {
            return obj.jsl.windows.open_windows[wid].setFullscreen(state);
          };
          sub_context.setTitle = function(title) {
            return obj.jsl.windows.open_windows[wid].setTitle(title);
          };
          
          sub_context.getSize = function() {
            return obj.jsl.windows.open_windows[wid].getSize();
          };
          sub_context.getPos = function() {
            return obj.jsl.windows.open_windows[wid].getPos();
          };
          
          sub_context.openDevTools = function() {
            return obj.jsl.windows.open_windows[wid].openDevTools();
          };

          sub_context.printToPdf = function(options) {
            return obj.jsl.windows.open_windows[wid].printToPdf(options);
          };
          
          sub_context.document.addEventListener("keydown", function (e) {
            if(e.key == 'F12') {
              sub_context.openDevTools();
            } else if(e.ctrlKey && e.key.toLowerCase() == 'c') {
              if(obj.getWinSelectionText(sub_context) == "") {
                // No selected text
                obj.jsl.setStopLoop(true);
                e.stopPropagation();
                e.preventDefault();
              }
            }
          });
          resolve(sub_context);
        }, false);
      })];
    }
  }

  /**
   * Retrieves the selected text from a given window.
   * @param {Window} context - The window context to get the selection text from.
   * @returns {string} - The selected text.
   */
  getWinSelectionText(context) {
    var text = "";
    if(context.getSelection) {
        text = context.getSelection().toString();
    } else if(context.document.selection && context.document.selection.type != "Control") {
        text = context.document.selection.createRange().text;
    }
    return text;
  }
  
  /**
   * Closes a window or all windows based on the provided ID.
   * @param {number} id - The ID of the window to close, or "all" to close all windows.
   */
  closeWindow(wid) {
    if(!global.is_worker) {
      var obj = this;
      if(wid == "all") {
        Object.keys(this.jsl.windows.open_windows).forEach(function(key) {
          obj.jsl.windows.open_windows[key].context.close();
          obj.jsl.windows._closedWindow(key);
        });
        return true;
      } else if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        obj.jsl.windows.open_windows[key].context.close();
        obj.jsl.windows._closedWindow(key);
        return true;
      }
    }
    return false;
  }

  /**
   * Shows the specified window.
   * @param {number} wid - The ID of the window to show.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  showWindow(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, 'show']);
        return true;
      }
    }
    return false;
  }
  
  /**
   * Hides the specified window.
   * @param {number} wid - The ID of the window to hide.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  hideWindow(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, 'hide']);
        return true;
      }
    }
    return false;
  }
  
  /**
   * Brings the specified window to the foreground.
   * @param {number} wid - The ID of the window to focus.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  focusWindow(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, 'focus']);
        return true;
      }
    }
    return false;
  }
  
  /**
   * Minimizes the specified window.
   * @param {number} wid - The ID of the window to minimize.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  minimizeWindow(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, 'minimize']);
        return true;
      }
    }
    return false;
  }
  
  /**
   * Centers the specified window on the screen.
   * @param {number} wid - The ID of the window to center.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  centerWindow(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, 'center']);
        return true;
      }
    }
    return false;
  }
  
  /**
   * Moves the specified window to the top.
   * @param {number} wid - The ID of the window to move to top.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  moveTopWindow(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, 'moveTop']);
        return true;
      }
    }
    return false;
  }
  
  /**
   * Sets the size of a specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} width - The new width of the window.
   * @param {number} height - The new height of the window.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  setWindowSize(wid, width, height) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, "setSize", width, 49 + height]);
      }
    }
    return false;
  }
  
  /**
   * Sets the position of a specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} left - The new left position of the window.
   * @param {number} top - The new top position of the window.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  setWindowPos(wid, left, top) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, "setPosition", left, top]);
      }
    }
    return false;
  }
  
  /**
   * Sets whether the specified window is resizable.
   * @param {number} wid - The ID of the window.
   * @param {boolean} state - The resizable state to set.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  setWindowResizable(wid, state) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, "setResizable", state]);
      }
    }
    return false;
  }
  
  /**
   * Sets whether the specified window is movable.
   * @param {number} wid - The ID of the window.
   * @param {boolean} state - The movable state to set.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  setWindowMovable(wid, state) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, "setMovable", state]);
      } else {
        return false;
      }
    }
  }
  
  /**
   * Sets the aspect ratio of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} aspect_ratio - The aspect ratio to set (width/height).
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  setWindowAspectRatio(wid, aspect_ratio) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, "setAspectRatio", aspect_ratio]);
      }
    }
    return false;
  }
  
  /**
   * Sets the opacity of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} opacity - The opacity level to set (0.0 to 1.0).
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  setWindowOpacity(wid, opacity) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, "setOpacity", opacity]);
      }
    }
    return false;
  }

  /**
   * Sets state of fullscreen of window if not running in a worker thread.
   * @param {string} wid - The window ID.
   * @param {string} state - fullscreen state.
   * @returns {boolean|undefined} False if the window does not exist, undefined if in a worker thread.
   */
  setWindowFullscreen(wid, state) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, "setFullScreen", state]);
      }
    }
    return false;
  }
  
  /**
   * Sets the title of the specified window if not running in a worker thread.
   * @param {string} wid - The window ID.
   * @param {string} title - The new title for the window.
   * @returns {boolean|undefined} False if the window does not exist, undefined if in a worker thread.
   */
  setWindowTitle(wid, title) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        this.jsl.windows.open_windows[wid].context.document.title = title;
      }
    }
    return false;
  }
  
  /**
   * Retrieves the size of a specified window.
   * @param {number} wid - The ID of the window.
   * @returns {Array|boolean} - Returns an array [width, height] or false if the window ID is invalid.
   */
  getWindowSize(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, "getSize"]);
      }
    }
    return false;
  }
  
  /**
   * Retrieves the position of a specified window.
   * @param {number} wid - The ID of the window.
   * @returns {Array|boolean} - Returns an array [left, top] or false if the window ID is invalid.
   */
  getWindowPos(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "call-sub-win-method", 
          [wid, "getPosition"]);
      }
    }
    return false;
  }
  
  /**
   * Opens the developer tools for a specified window in the renderer process.
   * Only available if not in a worker context.
   * @param {string} wid - The window ID.
   * @returns {boolean} True if the developer tools were opened; otherwise, false.
   */
  openWindowDevTools(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "open-sub-win-devtools", wid);
      }
    }
    return false;
  }
  
  /**
   * Returns media source id for a specified window in the renderer process.
   * Only available if not in a worker context.
   * @param {string} wid - The window ID.
   * @returns {String|boolean} Media source id if there is window; otherwise, false.
   */
  getWindowMediaSourceId(wid) {
    if(!global.is_worker) {
      if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
        return ipcRenderer.sendSync("sync-message", "get-sub-win-source-id", wid);
      }
    }
    return false;
  }
  
  /**
   * Opens the developer tools for the sandbox environment.
   */
  openSandboxDevTools() {
    ipcRenderer.send("MainProcess", "show-sandbox-dev-tools");
  }
  
  /**
   * Clears local storage.
   */
  clearStorage() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "clear-storage");
    }
  }
  
  /**
   * Creates a directory at the specified path. If the directory already exists, no action is taken.
   * @param {string} directory - The path where the directory will be created.
   * @returns {boolean} True if the directory was created or already exists, false if an error occurred.
   */
  makeDirectory(directory) {
    try {
      fs.mkdirSync(directory, { recursive: true });
      return true;
    } catch(err) {
      this.jsl._console.log(err);
      if(err.code === 'EEXIST') {
        return true;
      } else {
        return false;
      }
    }
  }
  
  /**
   * Checks if a directory exists at the specified path.
   * @param {string} directory - The path to the directory.
   * @returns {boolean} - True if the directory exists, false otherwise.
   */
  checkDirectory(directory) {
    var lstat = fs.lstatSync(directory, {throwIfNoEntry: false});
    if(lstat != undefined && lstat.isDirectory()) {
      return true;
    } else {
      return false;
    }
  }
  
  /**
   * Checks if a file exists at the specified path.
   * @param {string} file_path - The path to the file.
   * @returns {boolean} - True if the file exists, false otherwise.
   */
  checkFile(file_path) {
    var lstat = fs.lstatSync(file_path, {throwIfNoEntry: false});
    if(lstat != undefined && lstat.isFile()) {
      return true;
    } else {
      return false;
    }
  }

  /**
   * Checks if the provided path is an absolute path.
   * @param {string} file_path The file path to check.
   * @returns {boolean} True if the path is absolute, false otherwise.
   */
  pathIsAbsolute(file_path) {
    if(typeof file_path === 'string') {
      return path.isAbsolute(file_path);
    } else {
      return false;
    }
  }

  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter.
   * @param {...string} paths The path segments to join.
   * @returns {string} The combined path.
   */
  pathJoin(...arg) {
    return path.join(...arg);
  }

  /**
   * Retrieves the platform-specific path separator.
   * @returns {string} The path separator.
   */
  pathSep() {
    return path.sep;
  }
  
  /**
   * Extracts the basename of a path, possibly removing the specified extension.
   * @param {...string} paths The path to extract the basename from, followed by an optional extension to remove.
   * @returns {string} The basename of the path.
   */
  pathBaseName(...arg) {
    return path.basename(...arg);
  }

  /**
   * Retrieves the file name without its extension from the given file path.
   * @param {string} file_path - The path to the file.
   * @returns {string} - The file name without the extension.
   */
  pathFileName(file_path) {
    return path.parse(file_path).name;
  }

  /**
   * Extracts the directory of file.
   * @param {String} path The filesystem path from which to extract the directory.
   * @returns {String} The directory from the given path.
   */
  pathDirName(file_path) {
    return path.dirname(file_path);
  }
  
  /**
   * Retrieves the file extension from the given file path.
   * @param {string} file_path - The path to the file.
   * @returns {string} - The file extension.
   */
  pathExtName(file_path) {
    return path.extname(file_path);
  }
  
  /**
   * Resolves a sequence of path segments into an absolute path.
   * @param {string} path_in - The path or sequence of paths to resolve.
   * @returns {string} - The resolved absolute path.
   */
  pathResolve(path_in) {
    return path.resolve(path_in);
  }
    
  /**
   * Computes the relative path from one path to another. 
   * @param {string} from - The starting path.
   * @param {string} to - The target path.
   * @returns {string} - The relative path from the `from` path to the `to` path.
   */
  pathRelative(from, to) {
    return path.relative(from, to);
  }
  
  /**
   * Normalizes a given path, resolving '..' and '.' segments.
   * @param {string} path - The path to normalize.
   * @returns {string} - The normalized path.
   */
  pathNormalize(path_in) {
    return path.normalize(path_in);
  }
    
  /**
   * Parses a file path into its component parts.
   * @param {string} path - The file path to parse.
   * @returns {Object} An object containing properties like `root`, `dir`, `base`, `ext`, and `name`.
   */
  pathParse(path_in) {
    return path.parse(path_in);
  }
  
  /**
   * Reads the content of a file synchronously.
   * @param {string} file_path The path to the file.
   * @returns {(Buffer|string|false)} The file content or false in case of an error.
   */
  readFileSync(...arg) {
    try {
      return fs.readFileSync(...arg);
    } catch(err) {
      this.jsl._console.log(err);
      return false;
    }
  }

  /**
   * Copies a file synchronously with the given arguments.
   * @param {...any} arg - Arguments to pass to fs.copyFileSync.
   * @returns {boolean} - Returns true if the copy was successful, false otherwise.
   */
  copyFileSync(...arg) {
    try {
      return fs.copyFileSync(...arg);
    } catch(err) {
      this.jsl._console.log(err);
      return false;
    }
  }
  
  /**
   * Writes data to a file synchronously.
   * @param {string} file_path - The path to the file.
   * @param {any} data - The data to write.
   * @param {boolean} throw_flag - Whether to throw an error on failure.
   * @returns {boolean} - Returns true if the write was successful, false otherwise.
   */
	writeFileSync(file_path, data, throw_flag) {
    try {
      return fs.writeFileSync(file_path, data);
    } catch(err) {
      this.jsl._console.log(err);
      if(throw_flag) {
        this.error('@writeFileSync: '+err);
      }
      return false;
    }
  }

  /**
   * Removes a file or directory synchronously.
   * @param {string} path - The path to remove.
   * @param {boolean} [throw_flag=true] - Whether to throw an error on failure.
   * @returns {boolean} - Returns true if the removal was successful, false otherwise.
   */
  rmSync(path_in, throw_flag = true) {
    try {
      return fs.rmSync(path_in, { recursive: true, force: true });
    } catch(err) {
      this.jsl._console.log(err);
      if(throw_flag) {
        this.error('@rmSync: '+err);
      }
      return false;
    }
  }
  
  /**
   * Reads the contents of a directory synchronously.
   * @param {string} folder The path to the directory.
   * @returns {string[]|false} An array of filenames or false in case of an error.
   */
	readDir(...args) {
    try {
      return fs.readdirSync(...args);
    } catch(err) {
      this.jsl._console.log(err);
      this.error('@readDir: '+err);
      return false;
    }
  }

  /**
   * Displays a dialog to open files, asynchronously returning the selected files' paths.
   * @param {Object} options The options for the dialog.
   * @returns {Promise<string[]>} A promise that resolves to the paths of selected files.
   */
  showOpenDialog(options) {
    if(!global.is_worker) {
      return ipcRenderer.invoke("dialog", "showOpenDialog", options);
    }
    return false;
  }

  /**
   * Displays a dialog to open files, synchronously returning the selected files' paths.
   * @param {Object} options The options for the dialog.
   * @returns {string[]} The paths of selected files.
   */
  showOpenDialogSync(options) {
    if(!global.is_worker) {
      return ipcRenderer.sendSync("dialog", "showOpenDialogSync", options);
    }
    return false;
  }

  /**
   * Displays a dialog to save file, asynchronously returning the selected files' paths.
   * @param {Object} options The options for the dialog.
   * @returns {Promise<string[]>} A promise that resolves to the paths of selected files.
   */
  showSaveDialog(options) {
    if(!global.is_worker) {
      return ipcRenderer.invoke("dialog", "showSaveDialog", options);
    }
    return false;
  }
  
  /**
   * Displays a dialog to save file, synchronously returning the selected files' paths.
   * @param {Object} options The options for the dialog.
   * @returns {string[]} The paths of selected files.
   */
  showSaveDialogSync(options) {
    if(!global.is_worker) {
      return ipcRenderer.sendSync("dialog", "showSaveDialogSync", options);
    }
    return false;
  }

  /**
   * Displays a message box, synchronously returning the index of the clicked button.
   * @param {Object} options The options for the message box.
   * @returns {number} The index of the clicked button.
   */
  showMessageBox(options) {
    if(!global.is_worker) {
      return ipcRenderer.sendSync("dialog", "showMessageBoxSync", options);
    }
    return false;
  }

  /**
   * Checks if a loop stop flag has been set, indicating whether to halt execution.
   * @returns {boolean} True if the loop should stop, false otherwise.
   */
  checkStopLoop() {
    if(!global.is_worker) {
      return ipcRenderer.sendSync("sync-message", "check-stop-loop");
    }
    return false;
  }

  /**
   * Resets the loop stop flag to allow continued execution.
   * @returns {undefined} No return value.
   */
  resetStopLoop() {
    if(!global.is_worker) {
      return ipcRenderer.sendSync("sync-message", "reset-stop-loop");
    }
    return false;
  }
  
  /**
   * Opens the editor window and optionally loads a script.
   * @param {string} filename - The path to the script file to open.
   * @param {number} lineno - Line number to highlight.
   */
  editor(filename, lineno) {
    if(!global.is_worker) {
      ipcRenderer.send("MainProcess", "show-editor");
      if(typeof filename == "string") {
        ipcRenderer.send("EditorWindow", "open-script", [filename, lineno]);
      }
    }
  }

  /**
   * Sends a message to display in the main window of the application.
   * @param {...any} args - The messages to send for display in the main window.
   */
  disp(...args) {
    if(!global.is_worker) {
      var obj = this;
      args.forEach(function(msg) {
        ipcRenderer.send("MainWindow", "disp", obj.jsl.format.safeStringify(msg));
      });
    }
  }

  /**
   * Sends a message to display in the main window of the application with monospaced font.
   * @param {...any} args - The messages to send for display in the main window with monospaced font.
   */
  dispMonospaced(...args) {
    if(!global.is_worker) {
      var obj = this;
      args.forEach(function(msg) {
        ipcRenderer.send("MainWindow", "disp-monospaced", obj.jsl.format.safeStringify(msg));
      });
    }
  }
  
  /**
   * Sends a message to display latex in the main window of the application.
   * @param {string} expr The expression to be displayed.
   */
  dispLatex(expr) {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "disp-latex", expr);
    }
  }
  
  /**
   * Triggers the display of CMD help content in the main window.
   */
  cmd_help() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "help");
    }
  }

  /**
   * Triggers the display of informational content in the main window.
   */
  info() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "info");
    }
  }

  /**
   * Opens the settings interface in the main window.
   */
  settings() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "settings");
    }
  }

  /**
   * Sends an error message to be displayed in the main window.
   * @param {string} msg The error message to be displayed.
   */
  error(msg, throw_flag = true) {
    if(!global.is_worker) {
      this.jsl.stop_loop = true;
      this.jsl.onStopLoop(false);
      this.jsl.no_ans = true;
      this.jsl.ignore_output = true;
      this.jsl.onEvaluated();
      if(throw_flag) {
        throw new Error(msg);
      } else {
        ipcRenderer.send("MainWindow", "error", this.jsl.format.safeStringify(msg));
      }
    }
  }

  /**
   * Sends an internal error message to be displayed, indicating an error within the application's internals.
   * @param {string} msg The internal error message.
   */
  errorInternal(msg) {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "internal-error", msg);
    }
  }

  /**
   * Sends a warning message to be displayed in the main window.
   * @param {string} msg The warning message.
   */
  warn(msg) {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "warn", msg);
    }
  }
  
  /**
   * Clears the command window, removing all current content.
   */
  clc() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "clear");
    }
  }

  /**
   * Lists the contents of the current directory and returns them.
   * @returns {string[]} The contents of the current directory.
   */
  listFolderContents() {
    return fs.readdirSync(this.jsl.current_path);
  }
  
  /**
   * Requests an update of the file browser to reflect current directory or file changes.
   */
  updateFileBrowser() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "update-file-browser");
    }
  }

  /**
   * Displays the result of an operation in the workspace area of the main window.
   * @param {string} data The data or result to display.
   */
  showAns(data) {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "show-ans", data);
    }
  }

  /**
   * Requests an update of the workspace to reflect changes in variables or state.
   */
  updateWorkspace() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "update-workspace");
    }
  }

  /**
   * Sets the workspace with the provided data, replacing the current state.
   */
  setWorkspace() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "set-workspace", this.jsl.getWorkspace());
    }
  }
  
  /**
   * Saves a new path to the application's memory for quick access.
   * @param {string} new_path The path to save.
   */
  savePath(new_path) {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "save-path", new_path);
    }
  }

  /**
   * Removes a previously saved path from the application's memory.
   * @param {string} saved_path The path to remove.
   */
  removePath(saved_path) {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "remove-path", saved_path);
    }
  }

  /**
   * Sets the application's status message.
   * @param {string} state The current state of the application.
   * @param {string} txt The text message to display as status.
   */
  setStatus(state, txt) {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "set-status", [state, txt]);
    }
  }

  /**
   * Updates the application's statistics, typically displayed in the status bar or a similar area.
   * @param {object} stats The statistical data to set.
   */
  setStats(stats) {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "set-stats", stats);
    }
  }
  
  /**
   * Notifies the main window that code evaluation has started.
   */
  codeEvaluating() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "code-evaluating");
    }
  }
  
  /**
   * Notifies the main window that code evaluation has finished.
   */
  codeEvaluated() {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "code-evaluated");
      ipcRenderer.send("MainProcess", "code-evaluated");
    }
  }

  /**
   * Checks if a script resides within the current active directory or a saved directory, and if not, prompts to find the script.
   * @param {string} script_path The path of the script to check.
   * @returns {boolean} Returns true if the script directory is unknown, prompting for location; otherwise false.
   */
  checkScriptDir(script_path) {
    var script_dir = this.addPathSep(path.dirname(script_path));
    if(pathEqual(script_dir, this.jsl.current_path) ||
        this.jsl.saved_paths.includes(script_dir)) {
      return false;
    } else {
      ipcRenderer.send("MainWindow", "unknown-script-dir");
      return true;
    }
  }

  /**
   * Ensures a path string ends with a path separator, appending one if necessary.
   * @param {string} path_str The path string to modify.
   * @returns {string} The modified path string with a trailing separator.
   */
  addPathSep(path_str) {
    if(path_str && path_str[path_str.length-1] != path.sep) {
      path_str += path.sep;
    }
    return path_str;
  }
  
  /**
   * Changes the current working directory to the specified path.
   * @param {string} new_path The path to set as the current working directory.
   */
  cd(new_path) {
    if(!global.is_worker) {
      ipcRenderer.send("MainWindow", "set-current-path", new_path,
        undefined, false);
    }
  }

  /**
   * Retrieves a default path based on a specified type, e.g., documents, downloads.
   * @param {string} type The type of default path to retrieve.
   * @returns {string} The default path for the specified type.
   */
  getDefaultPath(type) {
    if(!global.is_worker) {
      return ipcRenderer.sendSync("sync-message", "get-path", type) + path.sep;
    }
    return false;
  }

  /**
   * Opens the specified folder in the file manager.
   * @param {string} file_path The path of the folder to open.
   */
  openFolder(file_path) {
    if(!global.is_worker) {
      return ipcRenderer.send("MainProcess", "open-folder", file_path);
    }
    return false;
  }

  /**
   * Opens the specified directory in the file manager. This method is similar to `openFolder`.
   * @param {string} file_path The path of the directory to open.
   */
  openDir(file_path) {
    if(!global.is_worker) {
      return ipcRenderer.send("MainProcess", "open-dir", file_path);
    }
    return false;
  }

  /**
   * Shows the specified file in the folder using the file manager.
   * @param {string} file_path The path of the file to show.
   */
  showFileInFolder(file_path) {
    if(!global.is_worker) {
      return ipcRenderer.send("MainProcess", "show-file-in-folder", file_path);
    }
    return false;
  }

  /**
   * Shows the specified file in the directory using the file manager. This is similar to `showFileInFolder`.
   * @param {string} file_path The path of the file to highlight.
   */
  showFileInDir(file_path) {
    if(!global.is_worker) {
      return ipcRenderer.send("MainProcess", "show-file-in-dir", file_path);
    }
    return false;
  }
  
  /**
   * Retrieves desktop sources synchronously by sending an IPC message.
   * @returns {DesktopSource[]|undefined} An array of desktop sources if not in a worker, otherwise undefined.
   */
  getDesktopSources() {
    if(!global.is_worker) {
      return ipcRenderer.sendSync("get-desktop-sources");
    }
    return false;
  }
  
  /**
   * Prints window to PDF format.
   * @param {string} wid - The window ID.
   * @param {Object} options - Options for printing
   * @returns {Buffer} Generated PDF data.
   */
  printWindowToPdf(wid, options) {
    if(!global.is_worker) {
      return ipcRenderer.invoke('print-sub-win-to-pdf', wid, options);
    }
    return false;
  }
  
  /**
   * Executes a system command assynchronously.
   * @param {...*} args Command arguments.
   */
  exec(...args){
    return cp.exec(...args);
  }
  
  /**
   * Executes a system command synchronously and returns the result.
   * @param {...*} args Command arguments.
   * @returns {*} The result of the command execution.
   */
  execSync(...args){
    return cp.execSync(...args);
  }
  
  /**
   * Spawns child process synchronously.
   * @param {...*} args Command arguments.
   */
  spawnSync(...args){
    return cp.spawnSync(...args);
  }
  
  /**
   * Spawns child process assynchronously.
   * @param {...*} args Command arguments.
   */
  spawn(...args){
    return cp.spawn(...args);
  }
  
  /**
   * Resets the sandbox environment by sending a synchronous IPC message if not in a worker.
   * @returns {void}
   */
  resetSandbox() {
    if(!global.is_worker) {
      ipcRenderer.sendSync("sync-message", "reset-sandbox");
    }
  }
  
  /**
   * Resets the app.
   * @returns {void}
   */
  resetApp() {
    if(!global.is_worker) {
      ipcRenderer.sendSync("sync-message", "reset-app");
    }
  }
}

exports.PRDC_JSLAB_ENV = PRDC_JSLAB_ENV;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={jslab-eval.js}]
/**
 * @file JSLAB library eval
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB library eval.
 */
class PRDC_JSLAB_EVAL {
  
  /**
   * Constructs a eval submodule object with access to JSLAB's electron environment functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
    
    // Errors handling
    this.jsl.context.addEventListener('unhandledrejection', function(e) { 
      if(e && e.reason) {
        if(obj.jsl.ready) {
          if(e.reason.hasOwnProperty('stack')) {
            obj.rewriteError('@jslab: '+e.reason.stack.toString());
          } else if(e.reason.message) {
            obj.jsl.env.error('@jslab: '+e.reason.message, false);
          }
        } else {
          console.log(e);
          obj.jsl.env.errorInternal('@jslab [FATAL INTERNAL]: ' + e.message);
        }
        e.preventDefault();
      }
    });

    this.jsl.context.addEventListener('error', function(e) {
      if(obj.jsl.ready) {
        if(e && e.error && 'stack' in e.error) {
          obj.rewriteError('@jslab: '+e.error.stack.toString());
        } else if(e && e.error && e.error.message) {
          obj.jsl.env.error('@jslab: '+e.error.message, false);
        }
      } else {
        console.log(e);
        obj.jsl.env.errorInternal('@jslab [FATAL INTERNAL]: ' + e.message);
      }
      e.preventDefault();
    });
  }
  
  /**
   * Evaluates a block of code as a string within the JSLAB environment.
   * @param {String} code The code block to evaluate.
   * @param {Boolean} [show_output=true] If true, displays the output of the code block.
   * @param {String} [jsl_file_name='jslcmdwindow'] The name of the file context for the code block.
   */
  async evalCodeFromMain(code, show_output = true, jsl_file_name = 'jslcmdwindow') {
    var obj = this;

    this.jsl.onEvaluating();
    this.jsl.jsl_file_name = jsl_file_name;
    this.jsl.current_script =  jsl_file_name;
    
    this.source_codes = [];
    this.transformed_codes = [];
    this.source_maps = [];
    this.current_source_code;
    this.current_source_map;    
    
    this.jsl.savePreviousWorkspace();
    this.jsl.loadPreviousWorkspace();

    function onError(err) {
      obj.jsl.onEvaluated();
      if(err.name == 'JslabError') {
        obj.jsl.env.error(err.message, false);
      } else {
        obj.rewriteError(err.stack.toString());
      }
    }
    
    try {
      var data = await this.evalString(code);
      if(obj.jsl.no_ans == false) {
        obj.jsl.context.ans = data;
      }
      if(show_output && obj.jsl.ignore_output == false) {
        obj.jsl.env.showAns(prettyPrint(data));
      }
      obj.jsl.onEvaluated();
    } catch(err) {
      onError(err);
    }
  }
  
  /**
   * Evaluates a string of code and handles errors and output.
   * @param {String} code The code string to evaluate.
   * @returns {*} The result of the evaluated code.
   */
  async evalString(code) { 
    var rewrite_result = this.rewriteCode(code);
    if(rewrite_result) {
      this.source_maps.push(rewrite_result.map);
      this.transformed_codes.push(rewrite_result.code);
      this.source_codes.push(code);
      
      var current_source_code = this.current_source_code;
      var current_source_map = this.current_source_map;
      this.current_source_code = code;
      this.current_source_map = rewrite_result.map;

      var result = await this.jsl._eval(rewrite_result.code);
      
      this.current_source_code = current_source_code;
      this.current_source_map = current_source_map;
      return result;
    }
    return false;
  }
  
  /**
   * Executes a script file within the JSLAB environment.
   * @param {String} script_path The path to the script file to be executed.
   * @param {Array} [lines] Specifies a range of lines to execute, if provided.
   * @param {Boolean} [silent=false] If true, suppresses output from the script.
   */
  async runScript(script_path, lines, silent = false) {
    script_path = this.jsl.pathResolve(script_path);
    if(script_path) {
      this.jsl.current_script = script_path;
      this.jsl.jsl_file_name = this.jsl.env.pathBaseName(script_path);
      
      var script_code = this.jsl.env.readFileSync(script_path);
      if(script_code === false) {
        this.jsl.env.error('@runScript: '+language.string(103)+': '+ script_path, false);
      } else {
        script_code = script_code.toString();
        if(lines !== undefined) {
          var code_lines = script_code.split('\n');
          if(typeof lines == 'number') {
            if(code_lines.length >= lines) {
              code_lines[lines-1];
            } else {
              this.jsl.env.error('@runScript: '+language.string(104)+'!\n '+language.string(105)+': '+ script_path, false);
            }
          } else {
            if(code_lines.length >= lines[0] && code_lines.length >= lines[1]) {
              code_lines = code_lines.slice(lines[0]-1, lines[1]-1);
            } else {
              this.jsl.env.error('@runScript: '+language.string(104)+'!\n '+language.string(105)+': '+ script_path);
            }
          }
        }
        return await this.evalString(script_code, !silent);
      }
    }
    return false;
  } 

  /**
   * Re-evaluates the last script file that was executed in the environment.
   */
  async runLast() {
    var cmd;
    if(this.jsl.last_script_lines !== undefined) {
      cmd = 'run(' + JSON.stringify(this.jsl.last_script_path) + ', ' + this.jsl.last_script_lines.toString() + '", undefined, true)';
    } else {
      cmd = 'run(' + JSON.stringify(this.jsl.last_script_path) + ', undefined, false, true)';
    }
    await this.evalCodeFromMain(cmd);
  }
  
  /**
   * Extracts and logs error information from the stack trace.
   * @param {String} stack The error stack trace.
   */
  async rewriteError(stack, on_rewrite = false) {
    this.jsl._console.log(stack, on_rewrite);
    
    const regex_normal = /at\s(.*?)\s\((.*\\.*?):(\d+):(\d+)\)/;
    const regex_eval = /eval at evalString\s*\(.*:(\d+):(\d+)\)$/;
    const regex_rewrite = /\((\d+):(\d+)\)/;
    var lines = stack.split('\n');
    var msg = lines[0];
    
    if(on_rewrite) {
      msg = msg.replace(/\(\d+:\d+\)/g, '');
      let matchs = lines[0].match(regex_rewrite);
      if(matchs) {
        let line = parseInt(matchs[1]);
        let column = parseInt(matchs[2]);
        
        msg += "\n  "+language.string(114)+" ";
        msg += "(" + this.jsl.current_script + ") "+language.string(112)+": " + line + ", "+language.string(113)+": " +  column;
      }
      throw {
        name: 'JslabError',
        message: msg
      };
    } else {
      for(let i = 1; i < lines.length; i++) {
        if(lines[i].includes("eval at evalString (")) {
          msg += "\n  "+language.string(114)+" ";
          let matchs = lines[i].match(regex_eval);
          let line = parseInt(matchs[1]);
          let column = parseInt(matchs[2]);
          var result = await this.getOriginalPosition(end(this.source_maps), line, column);
          
          msg += "(" + this.jsl.current_script + ") "+language.string(112)+": " + result.line + ", "+language.string(113)+": " +  result.column;
          break;
        } else {
          let matchs = lines[i].match(regex_normal);
          if(matchs) {
            msg += "\n  "+language.string(114)+" ";
            let expression = matchs[1];
            let path = matchs[2];
            let line = parseInt(matchs[3]);
            let column = parseInt(matchs[4]);            
            msg += expression + " (" + path + ") "+language.string(112)+": " + line + ", "+language.string(113)+": " +  column;
          }
        }
      }
      this.jsl.env.error(msg, false);
    }
  }
  
  /**
   * Extracts the position (line and column) of an expression from an error stack trace, providing context for debugging.
   * @returns {Array} An array containing the line number, column number, and script path of the expression causing the error.
   */
  async getExpressionPosition() {
    var err = new Error();
    var stack = err.stack;

    const regex_normal = /at\s(.*?)\s\((.*\\.*?):(\d+):(\d+)\)/;
    const regex_eval = /eval at evalString\s*\(.*:(\d+):(\d+)\)$/;
    var lines = stack.split('\n');
    var line;
    var script;
    
    for(let i = 2; i < lines.length; i++) {
      if(lines[i].includes("eval at evalString (")) {
        let matchs = lines[i].match(regex_eval);
        line = parseInt(matchs[1]);
        column = parseInt(matchs[2]);
        script = this.jsl.current_script;
        break;
      } else {
        let matchs = lines[i].match(regex_normal);
        if(matchs) {
          line = parseInt(matchs[3]);
          column = parseInt(matchs[4]);
          script = matchs[2];
          break;
        }
      }
    }
    
    var result = await this.getOriginalPosition(end(this.source_maps), line, column);
    return [result.line, result.column, script];
  }
  
  /**
   * Retrieves the original source position from a source map.
   * @param {Object} map - The source map object.
   * @param {number} line - The line number in the generated code.
   * @param {number} column - The column number in the generated code.
   * @returns {Promise<Object>} An object containing the original source position, including source file, line, and column.
   */
  async getOriginalPosition(map, line, column) {
    this.jsl.override.withoutCheckStop = true;
    var smc = await new this.jsl.env.SourceMapConsumer(map);
    this.jsl.override.withoutCheckStop = false;
    var result = smc.originalPositionFor({ line: line, column: column });
    smc.destroy();
    return result;
  }
  
  /**
   * Extracts the body of a given function as a string.
   * @param {Function} fun - The function from which to extract the body.
   * @returns {string|undefined} The body of the function as a string, or `undefined` if it cannot be extracted.
   */
  getFunctionBody(fun) {
    if(typeof fun == 'function') {
      const funStr = fun.toString();
      const bodyMatch = funStr.match(/{([\s\S]*)}/);
      if(bodyMatch && bodyMatch[1]) {
        return bodyMatch[1];
      }
    }
    return undefined;
  }
  
  /**
   * Rewrites a string of code using Recast and Babel Parser.
   * @param {String} code The code string to evaluate.
   * @returns {String} The rewritten code.
   */
  rewriteCode(code) {
    const obj = this;

    // Trick from devtools: Wrap code in parentheses if it's an object literal
    if(/^\s*\{/.test(code) && /\}\s*$/.test(code)) {
      code = '(' + code + ')';
    }

    if(config.DEBUG_PRE_TRANSFORMED_CODE) {
      obj.jsl._console.log(code);
    }

    // Parse the code into an AST using Recast with Babel parser
    let ast;
    try {
      ast = this.jsl.env.recast.parse(code, {
        parser: {
          parse(source) {
            return obj.jsl.env.babel_parser.parse(source, {
              sourceType: 'module',
              plugins: [
                'jsx',
                'typescript',
                'classProperties',
                'dynamicImport',
                'optionalChaining',
                'nullishCoalescingOperator',
                "@babel/plugin-syntax-top-level-await"
              ],
              tolerant: true
            });
          },
        },
        sourceFileName: "source.js"
      });
    } catch(err) {
      this.rewriteError(err.stack, true);
      return false;
    }

    // Function to check for forbidden names in patterns
    function checkPattern(pattern) {
      if(pattern.type === 'Identifier') {
        if(config.FORBIDDEN_NAMES.includes(pattern.name)) {
          throw {
            name: 'JslabError',
            message: `${language.string(185)}: '${pattern.name}' ${language.string(184)}`,
          };
        }
      } else if(pattern.type === 'ObjectPattern') {
        pattern.properties.forEach((prop) => {
          if(prop.type === 'RestElement') {
            checkPattern(prop.argument);
          } else {
            checkPattern(prop.value);
          }
        });
      } else if(pattern.type === 'ArrayPattern') {
        pattern.elements.forEach((element) => {
          if(element) checkPattern(element);
        });
      } else if(pattern.type === 'RestElement') {
        checkPattern(pattern.argument);
      } else if(pattern.type === 'AssignmentPattern') {
        checkPattern(pattern.left);
      }
    }

    // Traverse the AST to check for forbidden names
    this.jsl.env.recast.types.visit(ast, {
      visitVariableDeclarator(path) {
        checkPattern(path.node.id);
        this.traverse(path);
      },
      visitFunctionDeclaration(path) {
        const node = path.node;
        if(node.id && config.FORBIDDEN_NAMES.includes(node.id.name)) {
          throw {
            name: 'JslabError',
            message: `${language.string(186)}: '${node.id.name}' ${language.string(184)}`,
          };
        }
        this.traverse(path);
      },
      visitClassDeclaration(path) {
        const node = path.node;
        if(node.id && config.FORBIDDEN_NAMES.includes(node.id.name)) {
          throw {
            name: 'JslabError',
            message: `${language.string(187)}: '${node.id.name}' ${language.string(184)}`,
          };
        }
        this.traverse(path);
      },
      visitImportDeclaration(path) {
        path.node.specifiers.forEach((specifier) => {
          if(config.FORBIDDEN_NAMES.includes(specifier.local.name)) {
            throw {
              name: 'JslabError',
              message: `${language.string(188)}: '${specifier.local.name}' ${language.string(184)}`,
            };
          }
        });
        this.traverse(path);
      },
      visitAssignmentExpression(path) {
        checkPattern(path.node.left);
        this.traverse(path);
      },
    });

    const b = this.jsl.env.recast.types.builders;

    // Helper function to transform patterns to assign to jsl.context
    function transformPatternToContext(pattern) {
      if(pattern.type === 'Identifier') {
        // Replace identifier with jsl.context.identifier
        return b.memberExpression(
          b.memberExpression(b.identifier('jsl'), b.identifier('context')),
          b.identifier(pattern.name),
          false
        );
      } else if(pattern.type === 'ObjectPattern') {
        return b.objectPattern(
          pattern.properties.map((prop) => {
            if(prop.type === 'RestElement') {
              return b.restElement(transformPatternToContext(prop.argument));
            }
            return b.objectProperty(
              prop.key,
              transformPatternToContext(prop.value),
              prop.computed,
              false
            );
          })
        );
      } else if(pattern.type === 'ArrayPattern') {
        return b.arrayPattern(
          pattern.elements.map((element) => {
            if(element) {
              return transformPatternToContext(element);
            }
            return null;
          })
        );
      } else if(pattern.type === 'RestElement') {
        return b.restElement(transformPatternToContext(pattern.argument));
      } else if(pattern.type === 'AssignmentPattern') {
        return b.assignmentPattern(
          transformPatternToContext(pattern.left),
          pattern.right
        );
      }
      return pattern;
    }

    let tempVarCounter = 0;
    let functionDepth = 0;

    // Helpers to track function-like scopes
    function enterFunctionScope() {
      functionDepth++;
    }
    function leaveFunctionScope() {
      functionDepth--;
    }

    const visitObj = {
      // If top-level, after the function declaration, assign it to jsl.context
      visitFunctionDeclaration(path) {
        const node = path.node;
        if(functionDepth === 0 && node.id) {
          enterFunctionScope();
          this.traverse(path);
          leaveFunctionScope();

          // Insert assignment after the function declaration
          const funcName = node.id.name;
          const assignment = b.expressionStatement(
            b.assignmentExpression(
              '=',
              b.memberExpression(
                b.memberExpression(b.identifier('jsl'), b.identifier('context')),
                b.identifier(funcName)
              ),
              b.identifier(funcName)
            )
          );
          path.insertAfter(assignment);

          return false;
        } else {
          enterFunctionScope();
          this.traverse(path);
          leaveFunctionScope();
          return false;
        }
      },

      // Same logic for arrow functions and others - no change required
      visitFunctionExpression(path) {
        enterFunctionScope();
        this.traverse(path);
        leaveFunctionScope();
        return false;
      },
      visitArrowFunctionExpression(path) {
        enterFunctionScope();
        this.traverse(path);
        leaveFunctionScope();
        return false;
      },
      visitClassMethod(path) {
        enterFunctionScope();
        this.traverse(path);
        leaveFunctionScope();
        return false;
      },
      visitObjectMethod(path) {
        enterFunctionScope();
        this.traverse(path);
        leaveFunctionScope();
        return false;
      },
      visitClassPrivateMethod(path) {
        enterFunctionScope();
        this.traverse(path);
        leaveFunctionScope();
        return false;
      },

      // If top-level class declaration, after it assign it to jsl.context
      visitClassDeclaration(path) {
        const node = path.node;
        if(functionDepth === 0 && node.id) {
          enterFunctionScope();
          this.traverse(path);
          leaveFunctionScope();

          const className = node.id.name;
          const assignment = b.expressionStatement(
            b.assignmentExpression(
              '=',
              b.memberExpression(
                b.memberExpression(b.identifier('jsl'), b.identifier('context')),
                b.identifier(className)
              ),
              b.identifier(className)
            )
          );
          path.insertAfter(assignment);

          return false;
        } else {
          enterFunctionScope();
          this.traverse(path);
          leaveFunctionScope();
          return false;
        }
      },

      visitVariableDeclaration(path) {
        const node = path.node;
        const parent = path.parent.node;
        const parentType = parent.type;
        const isTopLevel = (functionDepth === 0); // Only transform top-level declarations

        // Handle variable declarations in for‑of and for‑in loops only if at top level.
        if(
          isTopLevel &&
          (parentType === 'ForOfStatement' || parentType === 'ForInStatement') &&
          parent.left === node
        ) {
          if(node.declarations.length !== 1) {
            throw new Error("Unexpected multiple declarations in for loop");
          }
          // Replace the parent's left with the transformed identifier, without the var keyword.
          parent.left = transformPatternToContext(node.declarations[0].id);
          return false;
        }

        // Existing logic for top-level declarations:
        const shouldRewrite =
          ((node.kind === 'var') && isTopLevel) ||
          ((node.kind === 'let' || node.kind === 'const') && parentType === 'Program');

        if(!shouldRewrite) {
          this.traverse(path);
          return false;
        }

        const newAssignments = [];
  
        node.declarations.forEach((decl) => {
          if(decl.id.type === 'ArrayPattern') {
            // Handle ArrayPattern by creating a temporary variable and individual assignments
            const tempVarName = `__temp${tempVarCounter++}`;
            // Create a temporary init variable if needed
            const tempDecl = b.variableDeclaration('var', [
              b.variableDeclarator(b.identifier(tempVarName), decl.init)
            ]);
            newAssignments.push(tempDecl);

            // For each element in the ArrayPattern, assign to jsl.context
            decl.id.elements.forEach((element, index) => {
              if(element && element.type === 'Identifier') {
                const transformedLeft = b.memberExpression(
                  b.memberExpression(b.identifier('jsl'), b.identifier('context')),
                  b.identifier(element.name),
                  false
                );
                const rightAccess = b.memberExpression(
                  b.identifier(tempVarName),
                  b.numericLiteral(index),
                  true
                );
                newAssignments.push(
                  b.expressionStatement(
                    b.assignmentExpression('=', transformedLeft, rightAccess)
                  )
                );
              } else if(element && element.type === 'RestElement') {
                // Handle RestElement (e.g., ...rest)
                const transformedLeft = transformPatternToContext(element.argument);
                const rightSlice = b.callExpression(
                  b.memberExpression(
                    b.identifier(tempVarName),
                    b.identifier('slice'),
                    false
                  ),
                  [b.numericLiteral(index)]
                );
                newAssignments.push(
                  b.expressionStatement(
                    b.assignmentExpression('=', transformedLeft, rightSlice)
                  )
                );
              }
            });

          } else {
            // For normal patterns or single identifiers
            const transformedId = transformPatternToContext(decl.id);
            const assignment = b.expressionStatement(
              b.assignmentExpression('=', transformedId, decl.init || b.identifier('undefined'))
            );
            newAssignments.push(assignment);
          }
        });

        // Check if this declaration is part of a ForStatement init
        if(path.parent.node.type === 'ForStatement' && path.parent.node.init === node) {
          // For a ForStatement init, we need a single expression, not multiple statements
          const exprs = [];
          newAssignments.forEach((stmt) => {
            if(stmt.type === 'VariableDeclaration' && stmt.declarations.length === 1) {
              // Convert var temp = init into (temp = init)
              const declInit = stmt.declarations[0].init || b.identifier('undefined');
              exprs.push(b.assignmentExpression('=', b.identifier(stmt.declarations[0].id.name), declInit));
            } else if(stmt.type === 'ExpressionStatement') {
              exprs.push(stmt.expression);
            }
          });

          let initExpr;
          if(exprs.length === 1) {
            initExpr = exprs[0];
          } else {
            initExpr = b.sequenceExpression(exprs);
          }

          path.replace(initExpr);
          return false;
        } else {
          // Normal top-level or block-level declaration: replace with multiple statements
          path.replace(...newAssignments);
          return false;
        }
      },

      visitImportDeclaration(path) {
        const node = path.node;
        const newStatements = [];

        node.specifiers.forEach((specifier) => {
          let requireCall;
          if(specifier.type === 'ImportDefaultSpecifier') {
            // const defaultExport = require('module').default;
            requireCall = b.memberExpression(
              b.callExpression(b.identifier('require'), [node.source]),
              b.identifier('default'),
              false
            );
          } else {
            // const { namedExport } = require('module');
            requireCall = b.callExpression(b.identifier('require'), [node.source]);
          }

          const left = b.memberExpression(
            b.memberExpression(b.identifier('jsl'), b.identifier('context')),
            b.identifier(specifier.local.name),
            false
          );

          const right =
            specifier.type === 'ImportDefaultSpecifier' ? requireCall
            : b.memberExpression(requireCall, b.identifier(specifier.imported.name), false);

          newStatements.push(
            b.expressionStatement(
              b.assignmentExpression('=', left, right)
            )
          );
        });

        path.replace(...newStatements);
        return false;
      }
    };

    this.jsl.env.recast.types.visit(ast, visitObj);

    // Ensure the value of the last expression is returned
    const finalBody = ast.program.body;
    if(finalBody.length > 0) {
      const lastNode = finalBody[finalBody.length - 1];
      if(lastNode.type === 'ExpressionStatement') {
        // Replace it with a return statement
        finalBody[finalBody.length - 1] = b.returnStatement(lastNode.expression);
      } else if(lastNode.type !== 'ReturnStatement') {
        // Not an expression or return statement, so append 'return undefined;'
        finalBody.push(
          b.returnStatement(b.identifier('undefined'))
        );
      }
    } else {
      // If the body is empty, add 'return undefined;'
      finalBody.push(
        b.returnStatement(b.identifier('undefined'))
      );
    }

    // Reconstruct the AST with the transformed body
    const transformedAST = b.program(finalBody);

    // Generate code from the transformed AST with Recast
    const result = this.jsl.env.recast.print(transformedAST, {
      sourceMapName: 'transformed.js.map',
    });

    // Wrap the code in an async IIFE to allow top-level await
    const transformedCode = `(async () => { ${result.code} })();`;

    if(config.DEBUG_TRANSFORMED_CODE) {
      obj.jsl._console.log(transformedCode);
      obj.jsl._console.log(result.map);
    }

    return { code: transformedCode, map: result.map };
  }
}

exports.PRDC_JSLAB_EVAL = PRDC_JSLAB_EVAL;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={jslab-override.js}]
/**
 * @file JSLAB library override submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB override submodule.
 */
class PRDC_JSLAB_OVERRIDE {
  
  /**
   * Initializes the override submodule, setting up a secure execution environment by deleting or overriding global properties and methods.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
    
    this.jsl.builtin_workspace = Object.getOwnPropertyNames(this.jsl.context);
    this._Module = require('module');
    
    // Overrides
    this.jsl._console = this.jsl.context.console;
    this.jsl._eval = this.jsl.context.eval;
    this.jsl._require = this._Module.prototype.require;
    this.jsl._requestAnimationFrame = this.jsl.context.requestAnimationFrame.bind(this.context);
    this.jsl._cancelAnimationFrame = this.jsl.context.cancelAnimationFrame.bind(this.context);
    this.jsl._setInterval = setInterval.bind(this.jsl.context);
    this.jsl._clearInterval = clearInterval.bind(this.jsl.context);
    this.jsl._setTimeout = setTimeout.bind(this.jsl.context);
    this.jsl._clearTimeout = clearTimeout.bind(this.jsl.context);
    this.jsl._setImmediate = this.jsl.env.setImmediate;
    this.jsl._clearImmediate = this.jsl.env.clearImmediate;
    this.jsl._Promise = this.jsl.context.Promise;
    if(!global.is_worker) {
      this.jsl._requestIdleCallback = this.jsl.context.requestIdleCallback.bind(this.context);
      this.jsl._cancelIdleCallback = this.jsl.context.cancelIdleCallback.bind(this.context);
    }
    this.jsl._isNaN = this.jsl.context.isNaN;
    
    // Add toJSON methods to some classes
    if(typeof Gamepad != 'undefined' && !Gamepad.prototype.toJSON) {
      Gamepad.prototype.toJSON = function() {
        return {
          id: this.id,
          index: this.index,
          connected: this.connected,
          timestamp: this.timestamp,
          mapping: this.mapping,
          axes: Array.from(this.axes),
          buttons: this.buttons.map(button => ({
            pressed: button.pressed,
            value: button.value
          }))
        };
      };
    }
    if(typeof MediaDeviceInfo != 'undefined' && !MediaDeviceInfo.prototype.toJSON) {
      MediaDeviceInfo.prototype.toJSON = function() {
        return {
          deviceId: this.deviceId,
          kind: this.kind,
          label: this.label,
          groupId: this.groupId
        };
      };
    }

    // Assign environment properties to context
    this.jsl.env.exports.forEach(function(prop) {
      if(config.DEBUG_FUN_SHADOW && obj.jsl.context.hasOwnProperty(prop)) {
        obj.jsl._console.log('Shadowing function/property: ' + prop + ' with env');
      } else if(config.DEBUG_NEW_FUN) {
        obj.jsl._console.log('Adding function/property to context: ' + prop + ' from env');
      }
      obj.jsl.context[prop] = obj.jsl.env.prop;
    });

    // Assign libraries properties and methods to context
    if(this.jsl.env.math) {
      Object.getOwnPropertyNames(this.jsl.env.math).forEach(function(prop) {
        if(config.DEBUG_FUN_SHADOW && obj.jsl.context.hasOwnProperty(prop)) {
          obj.jsl._console.log('Shadowing function/property: ' + prop + ' with math lib');
        } else if(config.DEBUG_NEW_FUN) {
          obj.jsl._console.log('Adding function/property to context: ' + prop + ' from math lib');
        }
        
        var prop_out = prop;
        if(config.MATHJS_PREVENT_OVERRIDE.includes(prop)) {
          prop_out = 'mathjs_'+prop;
        }
        obj.jsl.context[prop_out] = obj.jsl.env.math[prop];
      });
    }
    
    // Construct objects of submodules
    var submodules = {};
    config.SUBMODULES['builtin'].forEach(function(module) {  
      var exp = require('./'+module.file);
      submodules[module.name] = new exp[module.class_name](obj.jsl);
    });

    config.SUBMODULES['lib'].forEach(function(lib) {  
      var exp = require('./'+lib.file);
      obj.jsl.context[lib.name] = new exp[lib.class_name](obj.jsl);
      obj.jsl[lib.name] = obj.jsl.context[lib.name];
    });

    // Assign submodule properties and methods to context
    Object.getOwnPropertyNames(submodules).forEach(function(submodule) {
      obj.jsl[submodule] = submodules[submodule]; // Assign submodules
      Object.getOwnPropertyNames(submodules[submodule]).forEach(function(prop) {
        if(!['jsl'].includes(prop) || !prop.startsWith('_')) {
          if(config.DEBUG_FUN_SHADOW && obj.jsl.context.hasOwnProperty(prop)) {
            obj.jsl._console.log('Shadowing property: ' + prop + ' with submodule ' + submodule);
          } else if(config.DEBUG_NEW_FUN) {
            obj.jsl._console.log('Adding property to context: ' + prop + ' from submodule ' + submodule);
          } 
          obj.jsl.context[prop] = submodules[submodule][prop];
        }
      });
      
      Object.getOwnPropertyNames(Object.getPrototypeOf(submodules[submodule])).forEach(function(prop) {
        if(!['constructor'].includes(prop)) {
          if(config.DEBUG_FUN_SHADOW && obj.jsl.context.hasOwnProperty(prop)) {
            obj.jsl._console.log('Shadowing function: ' + prop + ' with submodule ' + submodule);
          } else if(config.DEBUG_NEW_FUN) {
            obj.jsl._console.log('Adding function to context: ' + prop + ' from submodule ' + submodule);
          } 
          obj.jsl.context[prop] = submodules[submodule][prop].bind(submodules[submodule]);
        }
      });
    });
    
    this.jsl.initial_workspace = Object.getOwnPropertyNames(this.jsl.context);

    // Execute override submodule
    this.execute();
    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(function(prop) {
      if(!['constructor', 'execute'].includes(prop)) {
        if(config.DEBUG_FUN_SHADOW && obj.jsl.context.hasOwnProperty(prop)) {
          obj.jsl._console.log('Shadowing function: ' + prop + ' with submodule override');
        } else if(config.DEBUG_NEW_FUN) {
          obj.jsl._console.log('Adding function to context: ' + prop + ' from submodule override');
        } 
        obj.jsl.context[prop] = obj[prop].bind(obj);
      }
    });

    setTimeout(function() {
      obj.jsl.context.Promise = obj.Promise;
      obj.jsl.context.console = obj.console;
    }, 500);
  }
  
  /**
   * Executes overrides
   */
  execute() {
    var obj = this;
    
    this.deleted = {};
    this.delete_globals = [
      'eval', 'name', 'closed', 'length', 'frameElement', 'navigator', 'styleMedia', 'onsearch', 'isSeureContext', 'trustedTypes', 'onappinstalled', 'onbeforeinstallprompt', 'customElements', 'history', 'navigation', 'locationbar', 'menubar', 'personalbar', 'onunload', 'scheduler', 'chrome',  'scrollbars', 'clientInformation', 'onstorage', 'launchQueue', 'originAgentCluster', 'isSecureContext', 'statusbar', 'toolbar', 'status', 'origin', 'credentialless', 'external', 'screen', 'innerWidth', 'innerHeight', 'scrollX', 'pageXOffset', 'scrollY', 'pageYOffset', 'visualViewport', 'screenX', 'screenY', 'outerWidth', 'outerHeight', 'screenLeft', 'screenTop', 'onbeforexrselect', 'onabort', 'onbeforeinput', 'onblur', 'oncancel', 'oncanplay', 'oncanplaythrough', 'onchange', 'onclick', 'onclose', 'oncontextlost', 'oncontextmenu', 'oncontextrestored', 'oncuechange', 'ondblclick', 'ondrag', 'ondragend', 'ondragenter', 'ondragleave', 'ondragover', 'ondragstart', 'ondrop', 'ondurationchange', 'onemptied', 'onended', 'onfocus', 'onformdata', 'oninput', 'oninvalid', 'onload', 'onloadeddata', 'onloadedmetadata', 'onloadstart', 'onmousedown', 'onmouseenter', 'onmouseleave', 'onmousemove', 'onmouseout', 'onmouseover', 'onmouseup', 'onmousewheel', 'onpause', 'onplay', 'onplaying', 'onprogress', 'onratechange', 'onreset', 'onresize', 'onscroll', 'onsecuritypolicyviolation', 'onseeked', 'onseeking', 'onselect', 'onslotchange', 'onstalled', 'onsubmit', 'onsuspend', 'ontimeupdate', 'ontoggle', 'onvolumechange', 'onwaiting', 'onwebkitanimationend', 'onwebkitanimationiteration', 'onwebkitanimationstart', 'onwebkittransitionend', 'onwheel', 'onauxclick', 'ongotpointercapture', 'onlostpointercapture', 'onpointerdown', 'onpointermove', 'onpointerrawupdate', 'onpointerup', 'onpointercancel', 'onpointerover', 'onpointerout', 'onpointerenter', 'onpointerleave', 'onselectstart', 'onselectionchange', 'onanimationend', 'onanimationiteration', 'onanimationstart', 'ontransitionrun', 'ontransitionstart', 'ontransitionend', 'ontransitioncancel', 'onafterprint', 'onbeforeprint', 'onbeforeunload', 'onhashchange', 'onlanguagechange', 'onmessage', 'onmessageerror', 'onoffline', 'ononline', 'onpagehide', 'onpageshow', 'onpopstate', 'ondevicemotion', 'ondeviceorientation', 'ondeviceorientationabsolute', 'onbeforematch', 'onbeforetoggle', 'onscrollend', 'oncontentvisibilityautostatechange', 'cookieStore', 'caches'
    ];
    
    // Delete globals
    this.delete_globals.forEach(function(prop) {
      obj.deleted[prop] = obj.jsl.env.context[prop];
      delete obj.jsl.env.context[prop];
    });
    
    /**
     * Custom implementation of console methods to integrate with JSLAB's display and logging mechanisms.
     */
    this.console = {
      log: function(...arg) {
        obj.jsl.env.disp(...arg);
        obj.jsl.no_ans = true;
        obj.jsl.ignore_output = true;
      },
      warn: function(...arg) {
        obj.jsl.env.warn(...arg);
        obj.jsl.no_ans = true;
        obj.jsl.ignore_output = true;
      },
      info: function(...arg) {
        obj.jsl.env.disp(...arg);
        obj.jsl.no_ans = true;
        obj.jsl.ignore_output = true;
      },
      error: function(...arg) {
        obj.jsl.env.error(...arg);
        obj.jsl.no_ans = true;
        obj.jsl.ignore_output = true;
      },
      trace: function() {
        obj.jsl.notImplemented();
      },
      assert: function(expression, msg) {
        if(!expression) {
          obj.jsl.env.error(msg);
          obj.jsl.no_ans = true;
          obj.jsl.ignore_output = true;
        }
      },
      table: function(...arg) {
        obj.jsl.notImplemented();
      },
      clear: function() {
        obj.jsl.basic._clear();
      },
      debug: function() {
        obj.jsl.notImplemented();
      },
      dir: function() {
        obj.jsl.notImplemented();
      },
      dirxml: function() {
        obj.jsl.notImplemented();
      },
      time: function() {
        obj.jsl.notImplemented();
      },
      timeLog: function() {
        obj.jsl.notImplemented();
      },
      timeEnd: function() {
        obj.jsl.notImplemented();
      },
      timeStamp: function() {
        obj.jsl.notImplemented();
      },
      count: function() {
        obj.jsl.notImplemented();
      },
      countreset: function() {
        obj.jsl.notImplemented();
      },
      group: function() {
        obj.jsl.notImplemented();
      },
      groupCollapsed: function() {
        obj.jsl.notImplemented();
      },
      groupEnd: function() {
        obj.jsl.notImplemented();
      },
      profile: function() {
        obj.jsl.notImplemented();
      },
      profileEnd: function() {
        obj.jsl.notImplemented();
      }
    };
    
    /**
     * Provides a custom Promise implementation with enhanced functionality to integrate with JSLAB's execution flow.
     */
    this.Promise = class extends this.jsl._Promise {
      constructor(executor) {
        if(obj.jsl.basic.checkStopLoop() || !obj.jsl.basic.checkStopLoop()) {
          obj.jsl.promises_number += 1;
          obj.jsl.last_promise_id += 1;
          let promises_id = obj.jsl.last_promise_id;
          obj.jsl.onStatsChange();
          let data = super(function(_resolve, _reject) {
             return executor(function(...args) {
               obj.jsl.clearPromise(promises_id);
               _resolve(...args);
             }, function(...args) {
               obj.jsl.clearPromise(promises_id);
               _reject(...args);
             });
          });
          data.loop_stoped = false;
          obj.jsl.started_promises[promises_id] = data;
          return data;
        } else {
          let data = super(function(resolve, reject) {
            reject();
          });
          return data;
        }
      }

      // Override the `then` method
      then(...args) {
        if(!this.loop_stoped) {
          let newPromise = super.then(...args);
          return newPromise;
        }
        return false;
      }

      // Override the `catch` method
      catch(...args) {
        if(!this.loop_stoped) {
          let newPromise = super.catch(...args);          
          return newPromise;
        }
        return false;
      }
      
      // Override the `finally` method
      finally(...args) {
        if(!this.loop_stoped) {
          let newPromise = super.finally(...args);
          return newPromise;
        }
        return false;
      }
    };
    
    this._Module.prototype.require = function(...args) {
      var name = obj.jsl.pathResolve(args[0], this);
      if(name) {
        if(!obj.jsl.required_modules.includes(name)) {
          obj.jsl.required_modules.push(name);
        }
        args[0] = name;
        return obj.jsl._require.apply(this, args);
      }
      return false;
    };
  }
  
  /**
   * Schedules a function to be called on the next animation frame in a non-blocking manner.
   * @param {Function} fun The function to call on the next animation frame.
   * @returns {number} The request ID of the animation frame request.
   */
  requestAnimationFrame(fun) {
    var obj = this;
    var request_id = this.jsl._requestAnimationFrame(function() {
      fun();
      obj.jsl.array.removeElementByValue(obj.jsl.started_animation_frames, request_id);
      obj.jsl.onStatsChange();
    });
    this.jsl.started_animation_frames.push(request_id);
    this.jsl.onStatsChange();
    return request_id;
  }
  
  /**
   * Cancels an animation frame request.
   * @param {number} request_id The ID of the request to cancel.
   */
  cancelAnimationFrame(request_id) {
    this.jsl._cancelAnimationFrame(request_id);
    this.jsl.array.removeElementByValue(this.jsl.started_animation_frames, request_id);
    this.jsl.onStatsChange();
  }
  
  /**
   * Schedules a function to run during the browser's idle periods in a non-blocking manner.
   * @param {Function} fun The function to execute during idle time.
   * @param {Object} options Optional settings for the idle callback.
   * @returns {number} The request ID of the idle callback request.
   */
  requestIdleCallback(fun, options) {
    var obj = this;
    var request_id = this.jsl.requestIdleCallback(function() {
      fun(options);
      obj.jsl.array.removeElementByValue(obj.jsl.started_idle_callbacks, request_id);
      obj.jsl.onStatsChange();
    });
    this.jsl.started_idle_callbacks.push(request_id);
    this.jsl.onStatsChange();
    return request_id;
  }
  
  /**
   * Cancels an idle callback request.
   * @param {number} request_id The ID of the request to cancel.
   */
  cancelIdleCallback(request_id) {
    this.jsl._cancelIdleCallback(request_id);
    this.jsl.array.removeElementByValue(this.jsl.started_idle_callbacks, request_id);
    this.jsl.onStatsChange();
  }
  
  /**
   * Sets a repeated interval in a non-blocking manner.
   * @param {Function} fun The function to execute at each interval.
   * @param {number} delay The number of milliseconds between each execution of the function.
   * @returns {number} The interval ID.
   */
  setInterval(...arg) {
    var request_id = this.jsl._setInterval(...arg);
    this.jsl.started_intervals.push(request_id);
    this.jsl.onStatsChange();
    return request_id;
  }

  /**
   * Clears a repeated interval.
   * @param {number} request_id The ID of the interval to clear.
   */
  clearInterval(request_id) {
    this.jsl._clearInterval(request_id);
    this.jsl.array.removeElementByValue(this.jsl.started_intervals, request_id);
    this.jsl.onStatsChange();
  }
  
  /**
   * Sets a timeout to execute a function once after a delay in a non-blocking manner.
   * @param {Function} fun The function to execute after the delay.
   * @param {number} delay The delay in milliseconds before the function is executed.
   * @returns {number} The timeout ID.
   */
  setTimeout(fun, delay, ...arg) {
    var obj = this;
    var request_id = this.jsl._setTimeout(function() {
      fun(...arg);
      obj.jsl.array.removeElementByValue(obj.jsl.started_timeouts, request_id); 
      obj.jsl.onStatsChange();      
    }, delay);
    this.jsl.started_timeouts.push(request_id);
    this.jsl.onStatsChange(); 
    return request_id;
  }
  
  /**
   * Clears a timeout.
   * @param {number} request_id The ID of the timeout to clear.
   */
  clearTimeout(request_id) {
    this.jsl._clearTimeout(request_id);
    this.jsl.array.removeElementByValue(this.jsl.started_timeouts, request_id);
    this.jsl.onStatsChange();
  }
  
  /**
   * Schedules a function to be executed immediately in a non-blocking manner.
   * @param {Function} fun The function to execute.
   * @returns {number} The immediate ID.
   */
  setImmediate(fun) {
    var obj = this;
    var request_id = this.jsl._setImmediate(function() {
      fun();
      obj.jsl.array.removeElementByValue(obj.jsl.started_immediates, request_id);
      obj.jsl.onStatsChange();
    });
    this.jsl.started_immediates.push(request_id);
    this.jsl.onStatsChange(); 
    return request_id;
  }
  
  /**
   * Clears an immediate.
   * @param {number} request_id The ID of the immediate to clear.
   */
  clearImmediate(request_id) {
    this.jsl._clearImmediate(request_id);
    this.jsl.array.removeElementByValue(this.jsl.started_immediates, request_id);
    this.jsl.onStatsChange();
  }
}

exports.PRDC_JSLAB_OVERRIDE = PRDC_JSLAB_OVERRIDE;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={jslab-ploter-echarts.js}]
/**
 * @file JSLAB ploter echarts based
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB ploter echarts based.
 */
class PRDC_JSLAB_PLOTER {
  
  /**
   * Create ploter object.
   */
  constructor() {
    this.library = 'echarts';
  }
}

exports.PRDC_JSLAB_PLOTER = PRDC_JSLAB_PLOTER;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={jslab-ploter-plotly.js}]
/**
 * @file JSLAB ploter plotly based
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB ploter plotly based.
 */
class PRDC_JSLAB_PLOTER {
  
  /**
   * Initializes the plotter object, setting Plotly as the underlying library for plotting operations.
 * @param {Object} jsl - Reference to the JSLAB environment.
   */
  constructor(jsl) {
    this.jsl = jsl;
    this.library = 'plotly';
    
  }
  
  /**
   * Sets the plot for the given figure identifier, displaying data and configuration.
   * @param {number} fid - The identifier for the figure to update.
   */
  async plot(fid) {
    if(!this.jsl.figures.open_figures.hasOwnProperty(fid)) {
      this.jsl.env.error('@ploter/plot: '+language.string(172));
      return;
    }
    
    var obj = this;
    var figure = this.jsl.figures.open_figures[fid];
    var plot = figure.plot;
    var context_plot = figure.context.plot;
    
    var plot_cont = figure.dom.querySelector('#figure-content .plot-cont');
    if(!plot_cont) {
      context_plot.setCont();
      plot_cont = context_plot.plot_cont;
    }
    
    // Plot traces
    var traces = [];
    var plot_traces = structuredClone(plot.traces);
    if(!Array.isArray(plot_traces)) {
      plot_traces = [plot_traces];
    }
    var ci = 0;
    figure.layout_3d = false;
    
    plot_traces.forEach(function(trace_options) {
      if(!figure.layout_3d && (trace_options.hasOwnProperty('z') && 
          (trace_options.hasOwnProperty('type') && trace_options.type != 'heatmap'))) {
        figure.layout_3d = true; // It is 3D plot
      }
      
      var type;
      if(trace_options.hasOwnProperty('type')) {
        type = trace_options.type;
      }
      if(type != 'pie') {
        var trace = {};
        trace.type = type;
        
        Object.keys(trace_options).forEach(function(key) {
          if(['x', 'y', 'z'].includes(key) && !Array.isArray(trace_options[key])) {
            trace[key] = [trace_options[key]];
          } else if((!['mesh3d'].includes(type) && key == 'color') || key == 'width') {
            if(!trace.hasOwnProperty('line')) {
              trace.line = {};
            }
            trace.line[key] = trace_options[key];
          } else {
            var key_lc = key.toLowerCase();
            if(trace.hasOwnProperty(key_lc) && typeof trace[key_lc] == 'object') {
              Object.assign(trace[key_lc], trace_options[key]);
            } else {
              trace[key_lc] = trace_options[key];
            }
          }
        });
        
        if(!['mesh3d'].includes(type) && (!trace.hasOwnProperty('line') || !trace.line.hasOwnProperty('color'))) {
         if(!trace.hasOwnProperty('line')) {
            trace.line = {};
          }
          trace.line.color = obj.jsl.color.colororder[ci];
          ci += 1;
          trace.cliponaxis = false;
        }
        traces.push(trace);
      } else {
        traces.push(trace_options);
      }
    });
    
    if(figure.layout_3d) {
      figure.dom.getElementById('figure-menu').className = 'figure-3d';
      if(!plot.axis_style_val) {
        plot.axis_style_val = 'equal';
      }
    } else {
      figure.dom.getElementById('figure-menu').className =  'figure-2d';
      if(!plot.axis_style_val) {
        plot.axis_style_val = 'normal';
      }
    }
      
    // Plot config
    var config = {
      responsive: true,
      scrollZoom: true
    };

    var layout = {};
    
    await context_plot.newPlot(plot, traces, layout, config);
    figure.dom.getElementById('rotate-menu').style.display = "none";
  }
  
  /**
   * Updates the layout for the plot associated with the specified figure identifier.
   * @param {number} fid - The identifier for the figure whose layout is to be updated.
   */
  updatePlotLayout(fid) {
    if(!this.jsl.figures.open_figures.hasOwnProperty(fid)) {
      this.jsl.env.error('@ploter/updatePlotLayout: '+language.string(172));
      return;
    }
    var figure = this.jsl.figures.open_figures[fid];
    var plot = figure.plot;
    var context_plot = figure.context.plot;
    var plot_cont = context_plot.plot_cont;
    
    // Plot layout
    var layout = {
      title: {},
      autosize: true,
      plot_bgcolor: "#fff",
      paper_bgcolor: "#fff",
      showlegend: plot.traces.length > 1,
      legend: {
        x: 0.98,
        xanchor: 'right',
        y: 0.98,
        bgcolor: '#fff',
        bordercolor: '#000',
        borderwidth: 1,
        borderpad: 10
      },
      font: {
        family: 'Roboto',
        size: 18
      }
    };
    
    if(figure.layout_3d) {
      Object.assign(layout, 
        {
          margin: {
            l: 0,
            r: 0,
            b: 0,
            t: 0,
            pad: 0
          },
          scene: {
            xaxis: {
              showgrid: true,
              zeroline: false,
              showline: true,
              ticks: 'inside',
              ticklen: 8,
              linewidth: 1,
              tickwidth: 1,
              gridwidth: 0.5,
              tickcolor: '#000',
              linecolor: '#000',
              gridcolor: '#999',
              mirror: 'ticks',
              autorange: true,
              title: {
                text: 'x [m]'
              },
              tickangle: 0
            },
            yaxis: {
              showgrid: true,
              zeroline: false,
              showline: true,
              ticks: 'inside',
              ticklen: 8,
              linewidth: 1,
              tickwidth: 1,
              gridwidth: 0.5,
              tickcolor: '#000',
              linecolor: '#000',
              gridcolor: '#999',
              mirror: 'ticks',
              autorange: true,
              title: {
                text: 'y [m]'
              },
              tickangle: 0
            },
            zaxis: {
              showgrid: true,
              zeroline: false,
              showline: true,
              ticks: 'inside',
              ticklen: 8,
              linewidth: 1,
              tickwidth: 1,
              gridwidth: 0.5,
              tickcolor: '#000',
              linecolor: '#000',
              gridcolor: '#999',
              mirror: 'ticks',
              autorange: true,
              title: {
                text: 'z [m]'
              },
              tickangle: 0
            },
            aspectratio: {
              x: 1, y: 1, z: 1
            },
            camera: {
              projection: { type: 'orthographic' }
            },
            dragmode: 'orbit' // "zoom" | "pan" | "orbit"
          }
        }
      );
    } else {
      Object.assign(layout, 
        {
          margin: {
            l: 60,
            r: 15,
            b: 60,
            t: 15,
            pad: 0
          },
          xaxis: {
            showgrid: true,
            zeroline: false,
            showline: true,
            automargin: true,
            mirror: 'ticks',
            ticks: 'inside',
            ticklen: 8,
            tickwidth: 0.5,
            tickcolor: '#000',
            linecolor: '#000',
            linewidth: 0.5,
            exponentformat: 'power'
          },
          yaxis: {
            showgrid: true,
            zeroline: false,
            showline: true,
            automargin: true,
            mirror: 'ticks',
            ticks: 'inside',
            ticklen: 8,
            tickwidth: 0.5,
            tickcolor: '#000',
            linecolor: '#000',
            linewidth: 0.5,
            exponentformat: 'power'
          }
        }
      );
    }

    // Options    
    if(plot.options.hasOwnProperty('legend')) {
      Object.assign(layout.legend, plot.options.legend);
    }
    if(plot.options.hasOwnProperty('showLegend')) {
      layout.showlegend = plot.options.showLegend;
    }
    if(plot.options.hasOwnProperty('legendLocation')) {
      switch(plot.options.legendLocation.toLowerCase()) {
        case 'north':
          layout.legend.xanchor = 'center',
          layout.legend.yanchor = 'top',
          layout.legend.x = 0.5,
          layout.legend.y = 0.98;
          break;
        case 'south':
          layout.legend.xanchor = 'center',
          layout.legend.yanchor = 'bottom',
          layout.legend.x = 0.5,
          layout.legend.y = 0.02;
          break;
        case 'east':
          layout.legend.xanchor = 'right',
          layout.legend.yanchor = 'center',
          layout.legend.x = 0.98,
          layout.legend.y = 0.5;
          break;
        case 'west':
          layout.legend.xanchor = 'left',
          layout.legend.yanchor = 'center',
          layout.legend.x = 0.02,
          layout.legend.y = 0.5;
          break;
        case 'northeast':
          layout.legend.xanchor = 'right',
          layout.legend.yanchor = 'top',
          layout.legend.x = 0.98,
          layout.legend.y = 0.98;
          break;
        case 'northwest':
          layout.legend.xanchor = 'left',
          layout.legend.yanchor = 'top',
          layout.legend.x = 0.02,
          layout.legend.y = 0.98;
          break;
        case 'southeast':
          layout.legend.xanchor = 'right',
          layout.legend.yanchor = 'bottom',
          layout.legend.x = 0.98,
          layout.legend.y = 0.02;
          break;
        case 'southwest':
          layout.legend.xanchor = 'left',
          layout.legend.yanchor = 'bottom',
          layout.legend.x = 0.02,
          layout.legend.y = 0.02;
          break;
        case 'northoutside':
          layout.legend.xanchor = 'center',
          layout.legend.yanchor = 'bottom',
          layout.legend.x = 0.5,
          layout.legend.y = 1.02;
          break;
        case 'southoutside':
          layout.legend.xanchor = 'center',
          layout.legend.yanchor = 'top',
          layout.legend.x = 0.5,
          layout.legend.y = -0.02;
          break;
        case 'eastoutside':
          layout.legend.xanchor = 'left',
          layout.legend.yanchor = 'center',
          layout.legend.x = 1.02,
          layout.legend.y = 0.5;
          break;
        case 'westoutside':
          layout.legend.xanchor = 'right',
          layout.legend.yanchor = 'center',
          layout.legend.x = -0.02,
          layout.legend.y = 0.5;
          break;
        case 'northeastoutside':
          layout.legend.xanchor = 'left',
          layout.legend.yanchor = 'bottom',
          layout.legend.x = 1.02,
          layout.legend.y = 1.02;
          break;
        case 'northwestoutside':
          layout.legend.xanchor = 'right',
          layout.legend.yanchor = 'bottom',
          layout.legend.x = -0.02,
          layout.legend.y = 1.02;
          break;
        case 'southeastoutside':
          layout.legend.xanchor = 'left',
          layout.legend.yanchor = 'top',
          layout.legend.x = 1.02,
          layout.legend.y = -0.02;
          break;
        case 'southwestoutside':
          layout.legend.xanchor = 'right',
          layout.legend.yanchor = 'top',
          layout.legend.x = -0.02,
          layout.legend.y = -0.02;
          break;
      }
    }
    if(plot.options.hasOwnProperty('legendOrientation')) {
      if(plot.options.legendOrientation == 'horizontal' ||
          plot.options.legendOrientation == 'h') {
        layout.legend.orientation = 'h';
      } else {
        layout.legend.orientation = 'v';
      }
    }
    
    if(figure.layout_3d) {
      if(plot.options.hasOwnProperty('xlim')) {
        layout.scene.xaxis.range = plot.options.xlim;
      }
      if(plot.options.hasOwnProperty('ylim')) {
        layout.scene.yaxis.range = plot.options.ylim;
      }
      if(plot.options.hasOwnProperty('zlim')) {
        layout.scene.zaxis.range = plot.options.zlim;
      }
    } else {
      if(plot.options.hasOwnProperty('xlim')) {
        layout.xaxis.range = plot.options.xlim;
      }
      if(plot.options.hasOwnProperty('ylim')) {
        layout.yaxis.range = plot.options.ylim;
      }
    }
    
    if(plot.options.hasOwnProperty('font')) {
      layout.font = plot.options.font;
    }
    if(plot.options.hasOwnProperty('margin')) {
      var margin = plot.options.margin;
      if(margin.hasOwnProperty('top')) {
        layout.margin.t = margin.top;
      }
      if(margin.hasOwnProperty('bottom')) {
        layout.margin.b = margin.bottom;
      }
      if(margin.hasOwnProperty('left')) {
        layout.margin.l = margin.left;
      }
      if(margin.hasOwnProperty('right')) {
        layout.margin.r = margin.right;
      }
    }

    if(plot.hasOwnProperty('title_val')) {
      layout.title.text = plot.title_val;
      layout.title.font = {
        size: 18
      };
      layout.margin.t = 40;
    }
    
    if(plot.hasOwnProperty('legend_state_val') && 
        ['on', 'off', 1, 0].includes(plot.legend_state_val)) {
      layout.showlegend = plot.legend_state_val == 'on' || plot.legend_state_val;
    }
    
    if(figure.layout_3d) {
      if(plot.hasOwnProperty('xlabel_val')) {
        layout.scene.xaxis.title = plot.xlabel_val;
        layout.scene.xaxis.automargin = true;
        layout.scene.xaxis.standoff = 20;
      }
      if(plot.hasOwnProperty('ylabel_val')) {
        layout.scene.yaxis.title = plot.ylabel_val;
        layout.scene.yaxis.automargin = true;
        layout.scene.yaxis.standoff = 20;
      }
      if(plot.hasOwnProperty('zlabel_val')) {
        layout.scene.zaxis.title = plot.zlabel_val;
        layout.scene.zaxis.automargin = true;
        layout.scene.zaxis.standoff = 20;
      }
    } else {
      if(plot.hasOwnProperty('xlabel_val')) {
        layout.xaxis.title = plot.xlabel_val;
        layout.xaxis.automargin = true;
        layout.xaxis.standoff = 20;
      }
      if(plot.hasOwnProperty('ylabel_val')) {
        layout.yaxis.title = plot.ylabel_val;
        layout.yaxis.automargin = true;
        layout.yaxis.standoff = 20;
      }
      if(plot.axis_style_val == 'equal') {
        layout.yaxis.scaleanchor = "x";
      } else {
        layout.yaxis.scaleanchor = false;
      }
    }
    
    context_plot.relayout(layout);
    context_plot.resize();
    
    if(plot.lim_update) {
      plot.lim_update = false;
      var layout2 = {};
      if(figure.layout_3d) {
        if(plot.hasOwnProperty('xlim_val')) {
          if(plot.xlim_val[0] == 'auto') {
            plot.xlim_val[0] = plot_cont._fullLayout.scene.xaxis.range[0];
          } 
          if(plot.xlim_val[1] == 'auto') {
            plot.xlim_val[1] = plot_cont._fullLayout.scene.xaxis.range[1];
          } 
          layout2['scene.xaxis.range'] = plot.xlim_val;
        }
        if(plot.hasOwnProperty('ylim_val')) {
          if(plot.ylim_val[0] == 'auto') {
            plot.ylim_val[0] = plot_cont._fullLayout.scene.yaxis.range[0];
          } 
          if(plot.ylim_val[1] == 'auto') {
            plot.ylim_val[1] = plot_cont._fullLayout.scene.yaxis.range[1];
          } 
          layout2['scene.yaxis.range'] = plot.ylim_val;
        }
        if(plot.hasOwnProperty('zlim_val')) {
          if(plot.zlim_val[0] == 'auto') {
            plot.zlim_val[0] = plot_cont._fullLayout.scene.zaxis.range[0];
          } 
          if(plot.zlim_val[1] == 'auto') {
            plot.zlim_val[1] = plot_cont._fullLayout.scene.zaxis.range[1];
          } 
          layout2['scene.zaxis.range'] = plot.zlim_val;
        }
      } else {
        if(plot.hasOwnProperty('xlim_val')) {
          if(plot.xlim_val[0] == 'auto') {
            plot.xlim_val[0] = plot_cont._fullLayout.xaxis.range[0];
          } 
          if(plot.xlim_val[1] == 'auto') {
            plot.xlim_val[1] = plot_cont._fullLayout.xaxis.range[1];
          } 
          layout2['xaxis.range'] = plot.xlim_val;
        }
        if(plot.hasOwnProperty('ylim_val')) {
          if(plot.ylim_val[0] == 'auto') {
            plot.ylim_val[0] = plot_cont._fullLayout.yaxis.range[0];
          } 
          if(plot.ylim_val[1] == 'auto') {
            plot.ylim_val[1] = plot_cont._fullLayout.yaxis.range[1];
          } 
          layout2['yaxis.range'] = plot.ylim_val;
        }
      }
      context_plot.relayout(layout2);
      context_plot.resize();
    }
    
    if(figure.layout_3d) {
      var layout3 = {};
      
      // Equal axes
      var xRange = plot_cont._fullLayout.scene.xaxis.range;
      if(plot.hasOwnProperty('xlim_val')) {
        xRange = plot.xlim_val;
        layout3['scene.xaxis.range'] = plot.xlim_val;
      }
      var yRange = plot_cont._fullLayout.scene.yaxis.range;
      if(plot.hasOwnProperty('ylim_val')) {
        yRange = plot.ylim_val;
        layout3['scene.yaxis.range'] = plot.ylim_val;
      }
      var zRange = plot_cont._fullLayout.scene.zaxis.range;
      if(plot.hasOwnProperty('zlim_val')) {
        zRange = plot.zlim_val;
        layout3['scene.zaxis.range'] = plot.zlim_val;
      }

      var zoom = 1;
      if(typeof plot.zoom_val != 'undefined') {
        zoom = plot.zoom_val;
      }
      
      if(plot.axis_style_val == 'equal') {
        var xRangeSize = Math.abs(xRange[1] - xRange[0]);
        var yRangeSize = Math.abs(yRange[1] - yRange[0]);
        var zRangeSize = Math.abs(zRange[1] - zRange[0]);
        var maxRange = Math.max(xRangeSize, yRangeSize, zRangeSize);
        
        layout3["scene.aspectratio"] =  {
          x: xRangeSize / maxRange * zoom,
          y: yRangeSize / maxRange * zoom,
          z: zRangeSize / maxRange * zoom
        };
      } else {
        layout3["scene.aspectratio"] =  {
          x: zoom,
          y: zoom,
          z: zoom
        };
      }
     
      var radius = maxRange/2;
      var azimuthRad = plot.view_val[0] * Math.PI / 180;
      var elevationRad = plot.view_val[1] * Math.PI / 180;

      var eye = {
        x: radius * Math.cos(elevationRad) * Math.cos(azimuthRad),
        y: radius * Math.cos(elevationRad) * Math.sin(azimuthRad),
        z: radius * Math.sin(elevationRad)
      };
      
      var up = { x: 0, y: 0, z: 1 };

      layout3['scene.camera.eye'] = eye;
      layout3['scene.camera.up'] = up;
      
      context_plot.relayout(layout3);
      context_plot.resize();
    }
  }

  /**
   * Updates plot data for a specified figure.
   * @param {string} fid - The identifier of the figure to update.
   * @param {Object} traces - The trace data to be updated in the plot.
   * @param {number} N - The new data length or index for updating the plot.
   */
  updateData(fid, traces, N) {
    if(!this.jsl.figures.open_figures.hasOwnProperty(fid)) {
      this.jsl.env.error('@ploter/updateData: '+language.string(172));
      return;
    }
    var figure = this.jsl.figures.open_figures[fid];
    figure.context.plot.updateData(traces, N);
  }
  
  /**
   * Updates plot data for a specified figure.
   * @param {string} fid - Identifier of the figure to update.
   * @param {Object|Object[]} data - Single trace or array of traces, each with an `id` and properties to restyle.
   */
  updateDataById(fid, data) {
    if(!this.jsl.figures.open_figures.hasOwnProperty(fid)) {
      this.jsl.env.error('@ploter/updateDataById: '+language.string(172));
      return;
    }
    var figure = this.jsl.figures.open_figures[fid];
    figure.context.plot.updateDataById(data);
  }
  
  /**
   * Handles plot resizing for a specified figure identifier.
   * @param {number} fid - The identifier for the figure to resize.
   */
  onResize(fid) {
    if(!this.jsl.figures.open_figures.hasOwnProperty(fid)) {
      this.jsl.env.error('@ploter/onResize: '+language.string(172));
      return;
    }
    var figure = this.jsl.figures.open_figures[fid];
    figure.context.plot.resize();
  }
  
  /**
   * Removes the plot container for a specified figure identifier.
   * @param {number} fid - The identifier for the figure from which to remove the plot container.
   */
  remove(fid) {
    if(!this.jsl.figures.open_figures.hasOwnProperty(fid)) {
      this.jsl.env.error('@ploter/remove: '+language.string(172));
      return;
    }
    var figure = this.jsl.figures.open_figures[fid];
    var plot_cont = figure.context.plot.plot_cont;
    if(plot_cont) {
      plot_cont.remove();
    }
  }
  
  /**
   * Sets the plot data from JSON.
   * @param {number} fid - The identifier for the figure to update.
   * @param {Array} data Data for the plot.
   */
  async fromJSON(fid, data) {
    var figure = this.jsl.figures.open_figures[fid];
    var plot = figure.plot;
    var context_plot = figure.context.plot;
    
    var plot_cont = figure.dom.querySelector('#figure-content .plot-cont');
    if(!plot_cont) {
      context_plot.setCont();
    }

    plot.traces = data.data;
    this._JsonToOptions(figure, data);
    await context_plot.fromJSON(data);
  }
  
  /**
   * Sets the plot data from JSON.
   * @param {Array} fig Data for the plot.
   * @returns {Boolean} - Returns true if the figure is 3D.
   */
  _is3DFigure(fig) {
    var types_3d = new Set([
      'scatter3d', 'surface', 'mesh3d',
      'cone', 'streamtube', 'volume', 'isosurface'
    ]);
    var trace_is_3d = fig.data?.some(t => types_3d.has(t.type));
    var layout_has_scene = Object.keys(fig.layout || {})
                                 .some(k => k.startsWith('scene'));
    return trace_is_3d || layout_has_scene;
  }
  
  /**
   * Re-creates plot.options and the extra “synthetic” fields
   * (title_val, xlim_val, …) from a saved Plotly figure JSON.
   *
   * @param {Object} figure  – runtime figure wrapper (has .plot, .dom, …)
   * @param {Object} data    – JSON produced by Plotly.toJSON / graphJson
   */
  _JsonToOptions(figure, data) {
    var plot = figure.plot;
    var layout = data.layout ?? {};

    figure.layout_3d = this._is3DFigure(data);

    figure.dom.getElementById('figure-menu').className =
        figure.layout_3d ? 'figure-3d' : 'figure-2d';

    if(!plot.axis_style_val) {
      plot.axis_style_val = figure.layout_3d ? 'equal' : 'normal';
    }

    var options = {};

    if(typeof layout.showlegend === 'boolean') {
      options.showLegend      = layout.showlegend;
      plot.legend_state_val   = layout.showlegend ? 'on' : 'off';
    }

    if(layout.legend && Object.keys(layout.legend).length) {
      var lg = JSON.parse(JSON.stringify(layout.legend));
      options.legend = lg;

      if(lg.orientation)
        options.legendOrientation =
          lg.orientation === 'h' ? 'horizontal' : 'vertical';

      {
        var { x=0, y=0 } = lg;
        var outsideX = x < 0 || x > 1;
        var outsideY = y < 0 || y > 1;

        var dirNS = y <= (outsideY ? -0.02 : 0.02) ? 'south'
                    : y >= (outsideY ? 1.02 : 0.98) ? 'north' : '';
        var dirEW = x <= (outsideX ? -0.02 : 0.02) ? 'west'
                    : x >= (outsideX ? 1.02 : 0.98) ? 'east' : '';

        let loc = (dirNS + dirEW) || 'north';
        if (outsideX || outsideY) loc += 'outside';
        options.legendLocation = loc.toLowerCase();
      }
    }

    if(figure.layout_3d) {
      var sc = layout.scene ?? {};
      if(sc.xaxis?.range) options.xlim = plot.xlim_val = [...sc.xaxis.range];
      if(sc.yaxis?.range) options.ylim = plot.ylim_val = [...sc.yaxis.range];
      if(sc.zaxis?.range) options.zlim = plot.zlim_val = [...sc.zaxis.range];
    } else {
      if(layout.xaxis?.range) options.xlim = plot.xlim_val = [...layout.xaxis.range];
      if(layout.yaxis?.range) options.ylim = plot.ylim_val = [...layout.yaxis.range];
    }

    if(layout.font)   options.font   = JSON.parse(JSON.stringify(layout.font));
    if(layout.margin) {
      var {t, b, l, r} = layout.margin;
      options.margin = {
        ...(t != null && { top: t }),
        ...(b != null && { bottom: b }),
        ...(l != null && { left: l }),
        ...(r != null && { right: r })
      };
    }

    if(layout.title?.text) plot.title_val  = layout.title.text;

    if(figure.layout_3d) {
      var sc = layout.scene ?? {};
      if(sc.xaxis?.title?.text) plot.xlabel_val = sc.xaxis.title.text;
      if(sc.yaxis?.title?.text) plot.ylabel_val = sc.yaxis.title.text;
      if(sc.zaxis?.title?.text) plot.zlabel_val = sc.zaxis.title.text;
    } else {
      if(layout.xaxis?.title?.text) plot.xlabel_val = layout.xaxis.title.text;
      if(layout.yaxis?.title?.text) plot.ylabel_val = layout.yaxis.title.text;
    }

    if(figure.layout_3d) {
      var sc = layout.scene ?? {};

      if(sc.aspectratio) {
        var {x = 1, y = 1, z = 1} = sc.aspectratio;
        var minAR = Math.min(x,y,z), maxAR = Math.max(x,y,z);
        var approxEqual = (maxAR - minAR) < 1e-6;
        plot.axis_style_val = approxEqual ? 'equal' : 'normal';
      }

      if(sc.camera?.eye) {
        var {x: ex = 1, y: ey = 1, z: ez = 1} = sc.camera.eye;
        var radius = Math.hypot(ex, ey, ez);
        var azimuth = (Math.atan2(ey, ex) * 180 / Math.PI + 360) % 360;
        var elevation = Math.asin(ez / radius) * 180 / Math.PI;
        plot.view_val = [azimuth, elevation];

        if(sc.aspectratio && plot.xlim_val && plot.ylim_val && plot.zlim_val) {
          var dx = Math.abs(plot.xlim_val[1] - plot.xlim_val[0]);
          var dy = Math.abs(plot.ylim_val[1] - plot.ylim_val[0]);
          var dz = Math.abs(plot.zlim_val[1] - plot.zlim_val[0]);
          var maxRange = Math.max(dx, dy, dz);
          var intrinsicAR = { x: dx/maxRange, y: dy/maxRange, z: dz/maxRange };
          var {x: ax = 1, y: ay = 1, z: az = 1} = sc.aspectratio;
          var zoom = (ax/(intrinsicAR.x || 1) +
                        ay/(intrinsicAR.y || 1) +
                        az/(intrinsicAR.z || 1)) / 3;
          plot.zoom_val = zoom;
        }
      }
    } else {
      plot.axis_style_val =
        layout.yaxis?.scaleanchor === 'x' ? 'equal' : 'normal';
    }
    figure.plot.options = options;
  }
}

exports.PRDC_JSLAB_PLOTER = PRDC_JSLAB_PLOTER;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={jslab.js}]
/**
 * @file JSLAB library
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const { PRDC_JSLAB_EVAL } = require('./jslab-eval');
const { PRDC_JSLAB_OVERRIDE } = require('./jslab-override');
const { PRDC_JSLAB_ENV } = require('./jslab-env-electron');

/**
 * Class for JSLAB library.
 */
class PRDC_JSLAB_LIB {
  
  /**
   * Constructs the JSLAB library environment, initializing submodules and setting up the execution context.
   */
  constructor() {
    var obj = this;
    this.ready = false;
    
    // Library built in properties
    this.previous_workspace = {};
    this.previous_properties = [];
    
    this.stop_loop = false;
    this.last_script_path;
    this.last_script_lines;
    this.last_script_silent;
    
    this.current_script;
    
    this.required_modules = [];
    this.started_timeouts = [];
    this.started_intervals = [];
    this.started_animation_frames = [];
    this.started_idle_callbacks = [];
    this.started_immediates = [];
    this.cleanup_registry = [];
    this.started_promises = {};
    this.promises_number = 0;
    this.last_promise_id = 0;
    
    this.env = new PRDC_JSLAB_ENV(this);
    this.context = this.env.context;
    this.setDepthSafeStringify(this.context, 1);
    this.context._ = Symbol('_');
    this.eval = new PRDC_JSLAB_EVAL(this);
    
    this.debug = this.env.debug;
    this.includes_path = this.env.getDefaultPath('includes');
    
    if(config.PLOTER == 'plotly') {
      var { PRDC_JSLAB_PLOTER } = require('./jslab-ploter-plotly');
    } else if(config.PLOTER == 'echarts') {
      var { PRDC_JSLAB_PLOTER } = require('./jslab-ploter-echarts');
    }
    this.ploter = new PRDC_JSLAB_PLOTER(this);
    
    this.override = new PRDC_JSLAB_OVERRIDE(this);
    
    this.ready = true;
  }
  
  /**
   * Invoked at the beginning of a code evaluation to set up necessary flags and state.
   */
  onEvaluating() {
    this.env.codeEvaluating();
    this.ignore_output = false;
    this.no_ans = false;
    this.stop_loop = false;
    this.env.resetStopLoop();
    this.env.setStatus('busy', language.string(88));
  }
  
  /**
   * Invoked after code evaluation to finalize the state and update the environment accordingly.
   */
  onEvaluated() {
    this.env.setWorkspace();
    this.env.codeEvaluated();
    this.env.setStatus('ready', language.string(87));
  }

  /**
   * Triggers when there are changes in the stats, such as the number of promises or timeouts, and updates the environment state.
   */
  onStatsChange() {
    this.env.setWorkspace();
    this.env.setStats({
      'required_modules': this.required_modules.length, 
      'promises': this.promises_number, 
      'timeouts': this.started_timeouts.length, 
      'immediates': this.started_immediates.length, 
      'intervals': this.started_intervals.length, 
      'animation_frames': this.started_animation_frames.length, 
      'idle_callbacks': this.started_idle_callbacks.length
    });
  }
  
  /**
   * Clears the current workspace, stopping any ongoing operations and removing any dynamic properties.
   */
  clear() {
    this.doCleanup();
    this.context.sym.clear();
    this.context.parallel.terminate();

    this.clearEventListeners();
    this.clearImmediates();
    this.clearAnimationFrames();
    this.clearIntervals();
    this.clearTimeouts();
    this.clearIdleCallbacks();
    this.stopPromises();
    this.stopSubprocesses();
    this.unrequireAll();
    this.onStatsChange();

    var obj = this;
    this.previous_properties.forEach(function(property) {
      if(typeof obj.context[property] != 'function' || (typeof obj.context[property] == 'function' && obj.context[property]._jsl_saved)) {
        delete obj.context[property];
      }
    });
    this.previous_properties = [];
    this.previous_workspace = {};
    this.no_ans = true;
    this.ignore_output = true;
  }
  
  /**
   * Sets the current path in the environment, adjusting how file paths are resolved.
   * @param {String} new_path The new path to set as the current working directory.
   */
  setPath(new_path) {
    this.current_path = this.env.addPathSep(new_path);
  }
  
  /**
   * Saves the properties of the current workspace to restore them later if needed.
   */
  savePreviousWorkspace() {
    var obj = this;
    this.previous_properties = this.getWorkspaceProperties();
    this.previous_properties.forEach(function(property) {
      if(typeof obj.context[property] == 'function') {
        obj.context[property]._jsl_saved = true;
      }
      obj.previous_workspace[property] = obj.context[property];
      delete obj.context[property];
    });
  }

  /**
   * Restores the properties of the workspace that were saved by `savePreviousWorkspace`.
   */
  loadPreviousWorkspace() {
    var obj = this;
    var workspace = this.getWorkspaceProperties();
    workspace.forEach(function(property) {
      if(obj.previous_properties.includes(property)) {
        // This property is defined again in new code
        obj.previous_properties.splice(
          obj.previous_properties.indexOf(property), 1);
      }
    });

    // Add saved properties back to global scope
    this.previous_properties.forEach(function(property) {
      obj.context[property] = obj.previous_workspace[property];
    });
  }
  
  /**
   * Retrieves a list of custom properties added to the global context since the initial load of the library.
   * @returns {Array} A list of property names that have been added to the global context.
   */
  getWorkspaceProperties() {
    var initial_props = this.initial_workspace;
    var current_prop_list = Object.getOwnPropertyNames(this.context);
    var workspace = [];

    for(var i = 0, l = current_prop_list.length; i < l; ++i) {
      var prop_name = current_prop_list[i];
      if(initial_props.indexOf(prop_name) === -1) {
        workspace.push(prop_name);
      }
    }
    return workspace;
  }

  /**
   * Constructs a detailed view of the current workspace, including the types and names of properties.
   * @returns {Array} An array of arrays, each containing the name, type, and constructor name (if applicable) of each property.
   */
  getWorkspace() {
    var initial_props = this.initial_workspace;
    var current_prop_list = Object.getOwnPropertyNames(this.context);
    var workspace = [];

    for(var i = 0, l = current_prop_list.length; i < l; ++i) {
      var prop_name = current_prop_list[i];
      if(initial_props && initial_props.indexOf(prop_name) === -1) {
        var prop = this.context[prop_name];
        var type = typeof prop;
        var name = 'none';

        if(type !== 'undefined') {
          if(prop && prop.constructor) {
            name = prop.constructor.name;
          } else {
            name = '/';
          }
        }
        workspace.push([prop_name, type, name]);
      }
    }

    return workspace;
  }
  
  /**
   * Generates the initialization script for the worker environment.
   * @returns {string} - The worker initialization script as a string.
   */
  getWorkerInit() {
    return `
      global.app_path = ${JSON.stringify(app_path)};
      global.is_worker = true;
      global.debug = ${this.env.debug};
      global.version = '${this.env.version}';
      global.platform = '${this.env.platform}';
      
      
      const helper = require(app_path + "/js/helper.js");
      require(app_path + "/js/init-config.js");

      importScripts(app_path + '/lib/luxon-3.4.4/luxon-3.4.4.min.js');
      importScripts(app_path + '/lib/math-11.8.2/math-11.8.2.min.js');
      importScripts(app_path + '/lib/sprintf-1.1.3/sprintf-1.1.3.min.js');
      importScripts(app_path + '/lib/sympy-0.26.2/pyodide.js');

      const { PRDC_JSLAB_LIB } = require(app_path + '/js/sandbox/jslab');

      // Global variables
      var jsl = new PRDC_JSLAB_LIB();
      jsl.current_path = ${JSON.stringify(this.current_path)};
      jsl.includes_path = ${JSON.stringify(this.includes_path)};
      jsl.saved_paths = JSON.parse('${JSON.stringify(this.saved_paths)}');
    `;
  }
  
  /**
   * Resolves the absolute path for a file, searching through predefined directories and optionally using module context.
   * @param {string} file_path - The file path to resolve.
   * @param {object} [this_module] - Optional module context for resolution.
   * @returns {string|boolean} - The resolved path, or `false` if not found.
   */
  pathResolve(file_path, this_module) {
    var obj = this;
    if(typeof file_path == 'string') {
      if(!this.env.pathIsAbsolute(file_path)) {
        if(this_module) {
          var file_path_temp = this.env.pathJoin(this_module.path, file_path);
          if(this.env.checkFile(file_path_temp)) {
            return file_path_temp;
          }
        }
        
        var file_paths = [];
        var file_path_temp = this.env.pathJoin(this.current_path, file_path);
        if(this.env.checkFile(file_path_temp)) {
          file_paths.push(file_path_temp);
        }
        file_path_temp = this.env.pathJoin(this.includes_path, file_path);
        if(this.env.checkFile(file_path_temp)) {
          file_paths.push(file_path_temp);
        }
        this.saved_paths.forEach(function(saved_path) {
          file_path_temp = obj.env.pathJoin(saved_path, file_path);
          if(obj.env.checkFile(file_path_temp)) {
            file_paths.push(file_path_temp);
          }
        });
        if(file_paths.length > 2) {
          var N = file_paths.length;
          var str = '@pathResolve: '+language.string(106)+' ' + file_paths[0] + ' '+language.string(107)+': [\n';
          for(var i = 1; i < N-1; i++) {
            str += '  '+ file_paths[i] + ',\n';
          }
          str += '  ' + file_paths[N-1] + '\n]'; 
          this.env.disp(str); 
        } else if(file_paths.length > 1) {
          this.env.disp('@pathResolve: '+language.string(106)+' ' + file_paths[0] + ' '+language.string(108)+': [\n  ' + file_paths[1] + '\n]');
        } else if(file_paths.length == 0) {
          try {
            if(this_module) {
              return this.override._Module._resolveFilename(file_path, this_module, false);
            } else {
              return require.resolve(file_path);
            }
          } catch(err) {
            this._console.log(err);
            this.env.error('@pathResolve: '+language.string(109)+' ' + file_path + ' '+language.string(110)+'.');
            return false;
          }
        }
        file_path = file_paths[0];
      }
    } else {
      this.env.error('@pathResolve: '+language.string(111)+'.');
      return false;
    }
    return file_path;
  }
  
  /**
   * Sets the flag to stop loop execution within the JSLAB environment.
   * @param {Boolean} data The flag indicating whether to stop loop execution.
   */
  setStopLoop(data) {
    this.stop_loop = data;
    this.onStopLoop(false);
    this.onEvaluated();
    this.env.disp(language.string(90));
  }
  
  /**
   * Handles the process of stopping loop execution and cleaning up asynchronous operations.
   * @param {Boolean} [throw_error=true] Indicates whether to throw an error when stopping the loop.
   * @throws {Object} An error object with a custom message if `throw_error` is true and the loop needs to be stopped.
   */
  onStopLoop(throw_error = true) {
    if(this.stop_loop) {
      this.clearEventListeners();
      this.clearImmediates();
      this.clearAnimationFrames();
      this.clearIntervals();
      this.clearTimeouts();
      this.clearIdleCallbacks();
      this.stopPromises();
      this.stopSubprocesses();
      this.doCleanup();
      this.onStatsChange();
      if(throw_error) {
        throw {name: 'JslabError', message: language.string(90)};
      }
    }
  }
  
  /**
   * Sets the paths saved in the environment for easier access to files and modules.
   * @param {Array} data An array of paths to be saved for future use.
   */
  setSavedPaths(data) {
    this.saved_paths = data;
  }
  
  /**
   * Placeholder function for features that have not been implemented.
   */
  notImplemented() {
    obj.env.error(language.string(115));
  }
  
  /**
   * Clears all modules that have been required during the session.
   */
  unrequireAll() {
    var obj = this;
    this.required_modules.forEach(function(module) {
      try {
        var name = require.resolve(module);
        if(name) {
          delete require.cache[name];    
        }
      } catch(err) {
        obj._console.log(err);
      }
    });
    this.required_modules = [];
    Object.keys(require.cache).forEach(function(key) { delete require.cache[key]; });
  }
  
  /**
   * Stops all promises that have been started within the environment.
   */
  stopPromises() {
    var obj = this;
    Object.keys(this.started_promises).forEach(function(key) {
      obj.started_promises[key].loop_stoped = true;
      delete obj.started_promises[key];
    });  
    this.promises_number = 0;
  }
  
  /**
   * Registers an object for cleanup with a specified cleanup function.
   * @param {Object} obj - The object to be registered for cleanup.
   * @param {Function} fun - The function to execute during cleanup.
   */
  addForCleanup(obj, fun) {
    this.cleanup_registry.push({obj: obj, fun: fun});
  }
  
  /**
   * Do cleanup on all registred objects;
   */
  doCleanup() {
    for(var entry of this.cleanup_registry) {
      if(isFunction(entry.fun)) {
        try {
          entry.fun();
        } catch {};
      } else if(isFunction(entry.obj._jslabCleanup)) {
        try {
          entry.obj._jslabCleanup();
        } catch {};
      }
    }
    this.cleanup_registry = [];
  }
  
  /**
   * Removes a specific promise from the tracking list based on its ID.
   * @param {Number} id The ID of the promise to remove.
   */
  clearPromise(id) {
   this.promises_number -= 1;
   if(this.promises_number < 0) {
     this.promises_number = 0;
   }
   this.onStatsChange();
   delete this.started_promises[id];
  }
          
  /**
   * Clears all timeouts that have been set within the environment.
   */
  clearTimeouts() {
    var obj = this;
    this.started_timeouts.forEach(function(timeout) {
      obj._clearTimeout(timeout);
    });
    this.started_timeouts = [];
  }

  /**
   * Clears all intervals that have been set within the environment.
   */
  clearIntervals() {
    var obj = this;
    this.started_intervals.forEach(function(interval) {
      obj._clearInterval(interval);
    });
    this.started_intervals = [];
  }
  
  /**
   * Cancels all animation frames that have been requested within the environment.
   */
  clearAnimationFrames() {
    var obj = this;
    this.started_animation_frames.forEach(function(animation_frames) {
      obj._cancelAnimationFrame(animation_frames);
    });
    this.started_animation_frames = [];
  }

  /**
   * Cancels all idle callbacks that have been requested within the environment.
   */
  clearIdleCallbacks() {
    var obj = this;
    this.started_idle_callbacks.forEach(function(idle_callback) {
      obj._cancelIdleCallback(idle_callback);
    });
    this.started_idle_callbacks = [];
  }

  /**
   * Clears all immediate executions that have been set within the environment.
   */
  clearImmediates() {
    var obj = this;
    this.started_immediates.forEach(function(immediate) {
      obj._clearImmediate(immediate);
    });
    this.started_immediates = [];
  }

  /**
   * Removes all event listeners that have been added to the document body, effectively clearing any remaining event bindings.
   */
  clearEventListeners() {
    document.body.parentNode.replaceChild(document.body.cloneNode(true), document.body);
  }

  /**
   * Lists all subprocesses.
   */
  stopSubprocesses() {
    var pids = this.listSubprocesses();
    pids.forEach(function(pid) {
      killProcess(pid);
    });
  }
  
  /**
   * Sets the safe stringify depth for the given data.
   * @param {Object} data - The data object to modify.
   * @param {number} depth - The depth level for safe stringification.
   * @returns {Object} The modified data object with the set depth.
   */
  setDepthSafeStringify(data, depth) {
    data._safeStringifyDepth = depth;
    return data;
  }

  /**
   * Lists all subprocesses.
   */
  listSubprocesses() {
    return this.env.native_module.listSubprocesses(this.env.process_pid);
  }
  
  /**
   * Gets properties missing documentation.
   * @param {Array|string} [workspace=this.initial_workspace] - Workspace to check.
   * @param {boolean} [without_builtin=true] - Exclude built-in properties.
   * @returns {Array<string>} Missing property names.
   */
  _getMissingDocs(workspace = this.initial_workspace, without_builtin = true) {
    var missing = [];
    for(var prop of workspace) {
      if(!prop.startsWith('_') && 
          (!without_builtin || 
           !this.builtin_workspace.includes(prop))) {
        try {
          help(prop);
        } catch {
          missing.push(prop);
        }
      }
    }
    return missing;
  }
  
  /**
   * Writes templates for missing docs to a file.
   * @param {string} path - File path for missing docs.
   * @param {Array|string} [workspace=this.initial_workspace] - Workspace to check.
   */
  _writeMissingDocsToFile(path, workspace = this.initial_workspace) {
    var workspace_array = workspace;
    if(!Array.isArray(workspace)) {
      workspace_array = Object.keys(workspace);
    }
     
    var missing = this._getMissingDocs(workspace_array);
    var str = '';
    for(var prop of missing) {
      var kind = 'function member';
      if(!Array.isArray(workspace)) {
        kind = typeof workspace[prop] === 'function' ? 'function' : 'member';
      }
      str += `
  /**
   * Description
   * @name ${prop}
   * @kind ${kind}
   * @param {}
   * @returns {}
   * @memberof PRDC_JSLAB_LIB_
   */
   
`;
    }
    this.env.writeFileSync(path, str);
  }
  
  /**
   * Awaits the provided promise if the loop has not been stopped.
   * @param {Promise} p - The promise to await.
   * @returns {Promise|undefined} - Resolves if `p` is awaited; does nothing if the loop is stopped.
   */
  async promiseOrStoped(p) {
    if(!p.loop_stoped) {
      await p;
    }
  }
}

exports.PRDC_JSLAB_LIB = PRDC_JSLAB_LIB;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={jslab.test.js}]
/**
 * @file JSLAB test
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const { PRDC_JSLAB_TESTS } = require('../tester');
var tests = new PRDC_JSLAB_TESTS();

tests.add('Expect tic to be equal to last tic', function() {
    return tic == jsl.context.last_tic;
  }
);

tests.add('Joining two paths with path separator', function() {
    return 'a'+pathSep()+'b' == jsl.env.pathJoin('a', 'b');
  }
);
    
exports.MODULE_TESTS = tests;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={math.js}]

/**
 * @file JSLAB library math submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB math submodule.
 */
class PRDC_JSLAB_LIB_MATH {
  
  /**
   * Constructs the math submodule, initializing mathematical constants and functions.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
    
    // Additional math constants
    if(this.jsl.env.math) {
      /**
       * Pi number.
       * @type {number}
       */
      this.Pi = this.jsl.env.math.pi; 
      
      /**
       * Coefficient for converting degrees to radians.
       * @type {number}
       */
      this.d2r = this.jsl.env.math.pi/180; 
      
      /**
       * Coefficient for converting radians to degrees.
       * @type {number}
       */
      this.r2d = 1/this.d2r; 
    }
    
    /**
     * Floating-point relative accuracy
     * @type {number}
     */
    this.eps = 1E-7; 
    
    /**
     * Floating-point relative accuracy
     * @type {number}
     */
    this.EPS = this.eps; 
  }
  
  /**
   * Seeds the random number generator with the provided arguments.
   * @param {...any} args - Arguments used to seed the random generator.
   * @returns {any} The result from the seeded random generator.
   */
  seedRandom(...args) {
    return this.jsl.env.seedRandom(...args);
  }
    
  /**
   * Performs linear interpolation on a set of data points.
   * @param {Array} x The x-values of the data points.
   * @param {Array} y The y-values of the data points, corresponding to each x-value.
   * @param {Number|Array} xq The x-value(s) for which to interpolate a y-value.
   * @param {String} mode The mode of interpolation. Use 'extrap' for extrapolation.
   * @returns {Number|Array} The interpolated y-value(s) at xq.
   */
  interp(x, y, xq, mode = 'none') {
    // Helper function for scalar interpolation
    const interpolate = (xqi) => {
      // Use lastIndexOf to get the last occurrence of an exact match.
      const i = x.lastIndexOf(xqi);
      if(i >= 0) {
        return y[i];
      }

      // Find the closest points for interpolation
      let x1 = null, x2 = null;
      for(let v of x) {
        if(v < xqi && (x1 === null || v > x1)) {
          x1 = v;
        }
        if(v > xqi && (x2 === null || v < x2)) {
          x2 = v;
        }
      }

      // Handle extrapolation if mode is 'extrap'
      if(mode === 'extrap') {
        if(xqi < x[0]) {
          const gradient = (y[1] - y[0]) / (x[1] - x[0]);
          return y[0] + (xqi - x[0]) * gradient;
        } else if(xqi > x[x.length - 1]) {
          const lastIdx = x.length - 1;
          const gradient = (y[lastIdx] - y[lastIdx - 1]) / (x[lastIdx] - x[lastIdx - 1]);
          return y[lastIdx] + (xqi - x[lastIdx]) * gradient;
        }
      }

      // Interpolate between x1 and x2
      if(x1 !== null && x2 !== null && x1 !== x2) {
        // Use the last occurrence for x1 and the first occurrence for x2
        const idx1 = x.lastIndexOf(x1);
        const idx2 = x.indexOf(x2);
        const y1 = y[idx1];
        const y2 = y[idx2];
        return y1 + (xqi - x1) * (y2 - y1) / (x2 - x1);
      }

      // Return NaN if no valid interpolation point is found
      return NaN;
    };

    // If xq is an array, map over each element
    return Array.isArray(xq) ? xq.map(interpolate) : interpolate(xq);
  }

  /**
   * Computes the gradient of a 2D grid.
   * @param {Array} x - X coordinates.
   * @param {Array} y - Y coordinates.
   * @param {Array[]} z - 2D data array.
   * @param {number} [N_a=11] - Neighborhood size.
   * @returns {Array[]} Gradient components [dz_x, dz_y].
   */
  gridGradient(x, y, z, N_a = 11) {
    var obj = this;
    var hx = x[1]-x[0]; 
    var hy = y[1]-y[0];
    var N_a_c = Math.floor(N_a / 2); 
    
    var n = z.length;
    var m = z[0].length;
        
    var dz_x = zeros(n, m);
    var dz_y = zeros(n, m);
    var dz_x_m = zeros(n, m);
    var dz_y_m = zeros(n, m);

    // Compute the gradient at a single point (x,y)
    // In our function, x is the horizontal index and y is the vertical index.
    function pointGradient(x, y) {
      if(x < 0 || x >= m || y < 0 || y >= n) return;
      // Check if gradients are already calculated
      if(dz_x[y][x] !== 0 || dz_y[y][x] !== 0) return;

      if(obj.jsl._isNaN(z[y][x])) {
        // If the current value is NaN or Inf, try using central differences if available
        // x component:
        if(x === 0 || x === m - 1) {
          dz_x[y][x] = 0;
        } else if(!obj.jsl._isNaN(z[y][x - 1]) && !obj.jsl._isNaN(z[y][x + 1])) {
          dz_x[y][x] = (z[y][x + 1] - z[y][x - 1]) / 2;
        } else {
          dz_x[y][x] = 0;
        }
        // y component:
        if(y === 0 || y === n - 1) {
          dz_y[y][x] = 0;
        } else if(!obj.jsl._isNaN(z[y - 1][x]) && !obj.jsl._isNaN(z[y + 1][x])) {
          dz_y[y][x] = (z[y + 1][x] - z[y - 1][x]) / 2;
        } else {
          dz_y[y][x] = 0;
        }
      } else {
        // If the value is valid, use one-sided differences on the boundaries
        // x component:
        if(x === 0 || x === m - 1) {
          if(x === 0 && !obj.jsl._isNaN(z[y][x + 1])) {
            dz_x[y][x] = z[y][x + 1] - z[y][x];
          } else if(x === m - 1 && !obj.jsl._isNaN(z[y][x - 1])) {
            dz_x[y][x] = z[y][x] - z[y][x - 1];
          } else {
            dz_x[y][x] = 0;
          }
        } else {
          if(!obj.jsl._isNaN(z[y][x - 1]) && !obj.jsl._isNaN(z[y][x + 1])) {
            dz_x[y][x] = (z[y][x + 1] - z[y][x - 1]) / 2;
          } else if(!obj.jsl._isNaN(z[y][x + 1])) {
            dz_x[y][x] = z[y][x + 1] - z[y][x];
          } else if(!obj.jsl._isNaN(z[y][x - 1])) {
            dz_x[y][x] = z[y][x] - z[y][x - 1];
          } else {
            dz_x[y][x] = 0;
          }
        }
        // y component:
        if(y === 0 || y === n - 1) {
          if(y === 0 && !obj.jsl._isNaN(z[y + 1][x])) {
            dz_y[y][x] = z[y + 1][x] - z[y][x];
          } else if(y === n - 1 && !obj.jsl._isNaN(z[y - 1][x])) {
            dz_y[y][x] = z[y][x] - z[y - 1][x];
          } else {
            dz_y[y][x] = 0;
          }
        } else {
          if(!obj.jsl._isNaN(z[y - 1][x]) && !obj.jsl._isNaN(z[y + 1][x])) {
            dz_y[y][x] = (z[y + 1][x] - z[y - 1][x]) / 2;
          } else if(!obj.jsl._isNaN(z[y + 1][x])) {
            dz_y[y][x] = z[y + 1][x] - z[y][x];
          } else if(!obj.jsl._isNaN(z[y - 1][x])) {
            dz_y[y][x] = z[y][x] - z[y - 1][x];
          } else {
            dz_y[y][x] = 0;
          }
        }
      }
      // Scale the gradients by the grid spacing
      dz_x[y][x] /= hx;
      dz_y[y][x] /= hy;
    }
    

    // Compute the mean gradient at a point using its neighborhood
    function meanGradient(x, y) {
      // Check if already calculated
      if(dz_x_m[y][x] !== 0 || dz_y_m[y][x] !== 0) return;
      var sum_x = 0, sum_y = 0, count_x = 0, count_y = 0;
      for(var p = 0; p < N_a; p++) {
        for(var q = 0; q < N_a; q++) {
          var nx = x + q - N_a_c;
          var ny = y + p - N_a_c;
          if(!(nx < 0 || nx >= m || ny < 0 || ny >= n)) {
            if(dz_x[ny][nx] !== 0) {
              sum_x += dz_x[ny][nx];
              count_x++;
            }
            if(dz_y[ny][nx] !== 0) {
              sum_y += dz_y[ny][nx];
              count_y++;
            }
          }
        }
      }
      dz_x_m[y][x] = count_x > 1 ? sum_x / count_x : sum_x;
      dz_y_m[y][x] = count_y > 1 ? sum_y / count_y : sum_y;
    }

    for(var y = 0; y < n; y++) {
      for(var x = 0; x < m; x++) {
        pointGradient(x, y);
      }
    }
    // Calculate mean gradient for all points
    for(var y = 0; y < n; y++) {
      for(var x = 0; x < m; x++) {
        meanGradient(x, y);
      }
    }
    
    return [dz_x_m, dz_y_m];
  }
  
  /**
   * Interpolates grid data using the specified method.
   * @param {Array} x - X coordinates.
   * @param {Array} y - Y coordinates.
   * @param {Array} z - Data values.
   * @param {Array} xq - Query X coordinates.
   * @param {Array} yq - Query Y coordinates.
   * @param {string} [method="linear"] - Interpolation method.
   * @param {Object} [opts_in] - Optional settings.
   * @returns {Array[]} Interpolated grid [xq, yq, zq].
   */
  gridData(x, y, z, xq, yq, method = "linear", opts_in) {
    var opts = {
      N_a: 11,
      k_e: 0.05,
      Ngx: 5,
      Ngy: 1,
      extrap: true,
      ...opts_in
    };
    
    function isBetween(A, a, b){
      var B = [];
      for(var i = 0; i < A.length; i += 1){
        if(A[i] >= (a - (b - a) * opts.k_e) && 
           A[i] <= (b + (b - a) * opts.k_e)) B.push(i);
      }
      return B;
    }

    var q_ids = [];
    var i_ids = [];

    var limits_x = linspace(xq[0], end(xq), opts.Ngx + 1);
    var limits_y = linspace(yq[0], end(yq), opts.Ngy + 1);
    
    for(var i = 0; i < opts.Ngx; i++){
      var i_idx = isBetween(x, limits_x[i], limits_x[i + 1]);
      for(var j = 0; j < opts.Ngy; j++){
        var i_idy = isBetween(y, limits_y[j], limits_y[j + 1]);
        var i_id = this.jsl.array.arrayIntersect(i_idx, i_idy);
        i_ids.push(structuredClone(i_id));
        
        var q_ids_ij = [];
        for(var k = 0; k < xq.length; k++){
          for(var m = 0; m < yq.length; m++){
            if(limits_x[i] <= xq[k] && 
                 xq[k] <= limits_x[i + 1] &&
                 limits_y[j] <= yq[m] && 
                 yq[m] <= limits_y[j + 1]){
              q_ids_ij.push([k, m]);
            } 
          }
        }
        q_ids.push([...q_ids_ij]);
      }
    }
    
    // Interpolation
    var zq = this.jsl.array.NaNs(yq.length, xq.length);
    if(method == 'nearest') {
      for(var i = 0; i < q_ids.length; i++) {
        var gc_q_ids = q_ids[i];
        var gc_i_ids = i_ids[i];
        for(var j = 0; j < gc_q_ids.length; j++) {
          var L_min;
          for(var k = 0; k < gc_i_ids.length; k++) {
            var L = Math.sqrt(Math.pow(x[gc_i_ids[k]] - xq[gc_q_ids[j][0]], 2) + 
                              Math.pow(y[gc_i_ids[k]] - yq[gc_q_ids[j][1]], 2));
            if(k == 0 || L < L_min){
              L_min = L;
              zq[gc_q_ids[j][1]][gc_q_ids[j][0]] = z[gc_i_ids[k]];
            }
          }
        }
      }
    } else if(method == 'linear') {
      for(var i = 0; i < q_ids.length; i++) {
        var gc_q_ids = q_ids[i];
        var gc_i_ids = i_ids[i];
        
        // Delaunay triangulation
        var points = [];
        for(var j = 0; j < gc_i_ids.length; j++) {
          points.push([x[gc_i_ids[j]], y[gc_i_ids[j]], z[gc_i_ids[j]]]);
        }
        var triangles = this.jsl.geometry.delaunayTriangulation(points);
        
        // Locate point (xq, yq) in triangle and calculate zq
        for(var j = 0; j < gc_q_ids.length; j++) {
          var point = [xq[gc_q_ids[j][0]], yq[gc_q_ids[j][1]], 0];
          for(var k = 0; k < triangles.length; k++) {
           if(triangles[k].contains(point)) {
             zq[gc_q_ids[j][1]][gc_q_ids[j][0]] = triangles[k].valueAt(point);
             break; 
           }
          }
        }        
      }

      if(opts.extrap) {
        // Extrapolation
        var zq0 = structuredClone(zq);
        
        // Calculate dz/dx and dz/dy for grid
        var [dz_x, dz_y] = this.gridGradient(xq, yq, zq, opts.N_a);
        
        for(var i = 0; i < q_ids.length; i++) {
          var gc_q_ids = q_ids[i];
          
          // Find nearest point with dz/dx and dz/dy
          for(var j = 0; j < gc_q_ids.length; j++) {
            var point = [
              xq[gc_q_ids[j][0]], 
              yq[gc_q_ids[j][1]], 
              zq[gc_q_ids[j][1]][gc_q_ids[j][0]]
             ];
            if(this.jsl._isNaN(point[2])) {
              var L_min;
              var k_min = -1;
              for(var k = 0; k < gc_q_ids.length; k++) {
                if(!this.jsl._isNaN(zq0[gc_q_ids[k][1]][gc_q_ids[k][0]])) {
                  var L = Math.sqrt(Math.pow(point[0] - xq[gc_q_ids[k][0]], 2) + 
                                   Math.pow(point[1] - yq[gc_q_ids[k][1]], 2));
                  if(k_min == -1 || L < L_min){
                    L_min = L;
                    k_min = k;
                  }
                }
              }
              if(k_min >= 0) {
                // Calculate dz and z
                var dz_x_i = dz_x[gc_q_ids[k_min][1]][gc_q_ids[k_min][0]];
                var dz_y_i = dz_y[gc_q_ids[k_min][1]][gc_q_ids[k_min][0]];
                
                var dx = xq[gc_q_ids[k_min][0]] - point[0];
                var dy = yq[gc_q_ids[k_min][1]] - point[1];
                zq[gc_q_ids[j][1]][gc_q_ids[j][0]] = 
                  zq[gc_q_ids[k_min][1]][gc_q_ids[k_min][0]] - 
                  dx * dz_x_i - dy * dz_y_i;
              }
            }
          }
        }
      }
    } else {
      this.jsl.env.error('@gridData: '+language.string(235));
    }
    return [xq, yq, zq];
  }
  
  /**
   * Calculates the output of a bilinear function based on input value, midpoint, and mid-value.
   * @param {number} x - The input value for the function.
   * @param {number} midPoint - The midpoint of the function where the slope changes.
   * @param {number} midValue - The value of the function at the midpoint.
   * @returns {number} The output value of the bilinear function.
   */
  bilinearFunction(x, midPoint, midValue) {
    var sign = 1;
    if(x < 0) {
      sign = -1;
    }
    x = Math.abs(x);
    if(x <= midPoint) {
      return sign*(midValue / midPoint) * x;
    } else {
      return sign*(((1 - midValue) / (1 - midPoint)) * (x - midPoint) + midValue);
    }
  }

  /**
   * Generates a random number between a specified range.
   * @param {Number} [min=0] The lower bound of the range.
   * @param {Number} [max] The upper bound of the range.
   * @returns {Number} A random number within the specified range.
   */
  random(min, max) {
    if(isNaN(Number(max))) return Math.random();
    if(isNaN(Number(min))) min = 0;
    return Math.random() * (max - min) + min;
  }

  /**
   * Generates a random integer within a specified range.
   * @param {Number} [min=0] The lower bound of the range.
   * @param {Number} [max] The upper bound of the range.
   * @returns {Number} A random integer within the specified range.
   */
  randInt(min, max) {
    if(isNaN(Number(max))) return NaN;
    if(isNaN(Number(min))) min = 0;
    return Math.floor(Math.random() * (max - min + 1) + min);
  }

  /**
   * Computes the arc cosine of x, with the result in degrees.
   * @param {Number} x The value to compute the arc cosine for.
   * @returns {Number} The arc cosine of x in degrees.
   */
  acosd(x) {
    return this.jsl.env.math.dotMultiply(this.jsl.env.math.acos(x), this.r2d);
  }

  /**
   * Computes the arc cotangent of x, with the result in degrees.
   * @param {Number} x The value to compute the arc cotangent for.
   * @returns {Number} The arc cotangent of x in degrees.
   */
  acotd(x) {
    return this.jsl.env.math.dotMultiply(this.jsl.env.math.acot(x), this.r2d);
  }

  /**
   * Computes the arc cosecant of x, with the result in degrees.
   * @param {Number} x The value to compute the arc cosecant for.
   * @returns {Number} The arc cosecant of x in degrees.
   */
  acscd(x) {
    return this.jsl.env.math.dotMultiply(this.jsl.env.math.acsc(x), this.r2d);
  }

  /**
   * Computes the arc secant of x, with the result in degrees.
   * @param {Number} x The value to compute the arc secant for.
   * @returns {Number} The arc secant of x in degrees.
   */
  asecd(x) {
    return this.jsl.env.math.dotMultiply(this.jsl.env.math.asec(x), this.r2d);
  }

  /**
   * Computes the arc sine of x, with the result in degrees.
   * @param {Number} x The value to compute the arc sine for.
   * @returns {Number} The arc sine of x in degrees.
   */
  asind(x) {
    return this.jsl.env.math.dotMultiply(this.jsl.env.math.asin(x), this.r2d);
  }

  /**
   * Computes the arc tangent of x, with the result in degrees.
   * @param {Number} x The value to compute the arc tangent for.
   * @returns {Number} The arc tangent of x in degrees.
   */
  atand(x) {
    return this.jsl.env.math.dotMultiply(this.jsl.env.math.atan(x), this.r2d);
  }

  /**
   * Computes the arc tangent of the quotient of its arguments, with the result in degrees.
   * @param {Number} y The y coordinate.
   * @param {Number} x The x coordinate.
   * @returns {Number} The arc tangent of y/x in degrees.
   */
  atan2d(y, x) {
    return this.jsl.env.math.dotMultiply(this.jsl.env.math.atan2(y, x), this.r2d);
  }

  /**
   * Computes the cosine of x, where x is in degrees.
   * @param {Number} x The angle in degrees.
   * @returns {Number} The cosine of x in degrees.
   */
  cosd(x) {
    return this.jsl.env.math.cos(this.jsl.env.math.dotMultiply(x, this.d2r));
  }

  /**
   * Computes the cotangent of x, where x is in degrees.
   * @param {Number} x The angle in degrees.
   * @returns {Number} The cotangent of x.
   */
  cotd(x) {
    return this.jsl.env.math.cot(this.jsl.env.math.dotMultiply(x, this.d2r));
  }

  /**
   * Computes the cosecant of x, where x is in degrees.
   * @param {Number} x The angle in degrees.
   * @returns {Number} The cosecant of x.
   */
  cscd(x) {
    return this.jsl.env.math.csc(this.jsl.env.math.dotMultiply(x, this.d2r));
  }

  /**
   * Computes the secant of x, where x is in degrees.
   * @param {Number} x The angle in degrees.
   * @returns {Number} The secant of x.
   */
  secd(x) {
    return this.jsl.env.math.sec(this.jsl.env.math.dotMultiply(x, this.d2r));
  }

  /**
   * Computes the sine of x, where x is in degrees.
   * @param {Number} x The angle in degrees.
   * @returns {Number} The sine of x.
   */
  sind(x) {
    return this.jsl.env.math.sin(this.jsl.env.math.dotMultiply(x, this.d2r));
  }

  /**
   * Computes the tangent of x, where x is in degrees.
   * @param {Number} x The angle in degrees.
   * @returns {Number} The tangent of x.
   */
  tand(x) {
    return this.jsl.env.math.tan(this.jsl.env.math.dotMultiply(x, this.d2r));
  }
  
  /**
   * Computes the characteristic polynomial of a matrix or the polynomial from roots.
   * @param {Array} A - If `A` is a matrix (2D array), computes its characteristic polynomial.
   *                    If `A` is an array of roots, computes the polynomial with those roots.
   * @returns {Array} - Coefficients of the resulting polynomial.
   */
  poly(A) {
    if(A[0].length) {
      return charpoly(A);
    }
    
    let p = [1];
    
    for(const root of A) {
      p = p.map((coef) => coef * -root)
        .concat(0)
        .map((coef, index, arr) => coef + (arr[index + 1] || 0));
    }
    
    return p;
  }

  /**
   * Fits a polynomial of degree n to the given data points and returns the coefficients (highest degree first).
   * @param {number[]} x - The array of x-values.
   * @param {number[]} y - The array of y-values corresponding to each x-value.
   * @param {number} n - The degree of the polynomial to fit.
   * @returns {number[]} The coefficients of the fitted polynomial in descending order.
   */
  polyfit(x, y, n) {
    var p = new this.jsl.env.PolynomialRegression(x, y, n);
    return p.coefficients.reverse(); // Reverse to match MATLAB's coefficient order
  }

  /**
   * Evaluates a polynomial with given coefficients at specified x-values.
   * @param {number[]} p - The coefficients of the polynomial in descending order.
   * @param {number[]} x_in - The array of x-values at which to evaluate the polynomial.
   * @returns {number[]} The resulting y-values after evaluating the polynomial at x_in.
   */
  polyval(p, x_in) {
    var y_out = [];
    y_out.length = x_in.length;
    for(var k = 0; k < x_in.length; k++) {
      var y = p[0];
      for(var i = 1; i < p.length; i++) {
        y = y * x_in[k] + p[i];
      }
      y_out[k] = y;
    }
    return y_out;
  }

  /**
   * Computes the roots of a polynomial with the given coefficients.
   * @param {number[]} p - Array of polynomial coefficients, ordered from highest degree to constant term.
   * @returns {number[]} Array of roots (real or complex) of the polynomial.
   */
  roots(p) {
    return this.jsl.env.native_module.roots(p);
  }

  /**
   * Generates a string representation of a polynomial based on the provided coefficients and options.
   * @param {number[]} p - An array of polynomial coefficients, ordered from highest degree to constant term.
   * @param {Object} [opts] - Optional settings for the polynomial string.
   * @param {string} [opts.x_symbol='x'] - The symbol to use for the variable x.
   * @param {string} [opts.y_symbol='y'] - The symbol to use for the variable y.
   * @param {number} [opts.precision=7] - The number of decimal places for coefficients.
   * @param {string} [opts.lang] - The language format for the output ('tex', 'c', etc.).
   * @returns {string} The formatted polynomial string.
   */
  polystr(p, opts) {
    let degree = p.length - 1;
    let x_symbol = 'x';
    let y_symbol = 'y';
    let precision = 7;
    let lang;
    if(opts) {
      if(opts.hasOwnProperty('x_symbol')) {
        x_symbol = opts.x_symbol;
      }
      if(opts.hasOwnProperty('y_symbol')) {
        y_symbol = opts.y_symbol;
      }
      if(opts.hasOwnProperty('precision')) {
        precision = opts.precision;
      }
      if(opts.hasOwnProperty('lang')) {
        lang = opts.lang;
      }
    }
    let str = y_symbol+' = ';

    for(let i = 0; i < p.length; i++) {
      let current_power = degree - i;
      let coef = p[i];

      // Skip terms with zero coefficient
      if(coef === 0) {
        continue;
      }

      // Handle the sign
      let sign_str = '';
      if(coef > 0 && i !== 0) {
        sign_str = ' + ';
      } else if(coef < 0) {
        sign_str = ' - ';
        coef = -coef; // Convert to positive for display
      }

      // Form the term based on the power of x
      let term_str;
      if(current_power > 1) {
        if(lang == 'tex') {
          term_str = `${sign_str}\\num\{${coef.toExponential(precision)}\}\\, ${x_symbol}^\{${current_power}\}`;
        } else if(lang == 'c') {
          term_str = `${sign_str}${coef.toExponential(precision)}*pow(${x_symbol}, ${current_power})`;
        } else {
          term_str = `${sign_str}${coef.toExponential(precision)}*${x_symbol}^${current_power}`;
        }
      } else if(current_power === 1) {
        if(lang == 'tex') {
          term_str = `${sign_str}\\num\{${coef.toExponential(precision)}\}\\, ${x_symbol}`;
        } else {
          term_str = `${sign_str}${coef.toExponential(precision)}*${x_symbol}`;
        }
        
      } else {
        if(lang == 'tex') {
          term_str = `${sign_str}\\num\{${coef.toExponential(precision)}\}`;
        } else {
          term_str = `${sign_str}${coef.toExponential(precision)}`;
        }
      }

      // Append the term to the polynomial string
      str += term_str;
    }

    return str;
  }
  
  /**
   * Generates a C language formatted string representation of a polynomial.
   * @param {number[]} p - An array of polynomial coefficients, ordered from highest degree to constant term.
   * @param {Object} [opts] - Optional settings for the polynomial string.
   * @returns {string} The polynomial string formatted for C language.
   */
  polystrc(p, opts) {
    if(opts) {
      opts.lang = 'c';
    } else {
      opts = {lang: 'c'};
    }
    return polystr(p, opts);
  }

  /**
   * Generates a LaTeX formatted string representation of a polynomial.
   * @param {number[]} p - An array of polynomial coefficients, ordered from highest degree to constant term.
   * @param {Object} [opts] - Optional settings for the polynomial string.
   * @returns {string} The polynomial string formatted for LaTeX.
   */
  polystrtex(p, opts) {
    if(opts) {
      opts.lang = 'tex';
    } else {
      opts = {lang: 'tex'};
    }
    return polystr(p, opts);
  }

  /**
   * Filters out spikes in a sequence by replacing sudden large changes with the previous value.
   * @param {number[]} x - The input sequence of numbers.
   * @param {number} dx_max - The maximum allowed difference between consecutive elements before considering it a spike.
   * @param {number} n - The maximum number of consecutive spikes to correct.
   * @returns {number[]} The filtered sequence with spikes removed.
   */
  spikeFilter(x, dx_max, n) {
    var c = 0;
    if(x.length > 1) {
      for(var i = 1; i < x.length; i++) {
        if(Math.abs(x[i]-x[i-1]) > dx_max && c < n){
          c = c+1;
          x[i] = x[i-1];
        } else {
          c = 0;
        }
      }
    }
    return x;
  }

  /**
   * Calculates the magnitude (absolute value) of a complex number or a real number.
   *
   * @param {number|Object} num - A real number or an object with 'real' and 'imag' properties.
   * @returns {number} The magnitude of the number.
   */
  magnitude(num) {
    if(typeof num === 'object' && num.real !== undefined && num.imag !== undefined) {
      return Math.hypot(num.real, num.imag);
    } else {
      return Math.abs(num);
    }
  }

  /**
   * Compares two numbers (real or complex) according to Octave's rules.
   *
   * @param {number|Object} a - First number to compare.
   * @param {number|Object} b - Second number to compare.
   * @returns {number} -1 if a < b, 1 if a > b, 0 if equal.
   */
  compareComplex(a, b) {
    const mag_A = magnitude(a);
    const mag_B = magnitude(b);

    if(mag_A < mag_B) return -1;
    if(mag_A > mag_B) return 1;

    // Magnitudes are equal; compare real parts
    const real_A = (typeof a === 'object') ? a.real : a;
    const real_B = (typeof b === 'object') ? b.real : b;

    if(real_A < real_B) return -1;
    if(real_A > real_B) return 1;

    // Real parts are equal; compare imaginary parts
    const imag_A = (typeof a === 'object') ? a.imag : 0;
    const imag_B = (typeof b === 'object') ? b.imag : 0;

    if(imag_A < imag_B) return -1;
    if(imag_A > imag_B) return 1;

    // Numbers are equal
    return 0;
  }
  
  /**
   * Finds the minimum value in an array of numbers, which can include both real numbers and complex numbers.
   * Complex numbers are represented as objects with 'real' and 'imag' properties.
   * The comparison follows Octave's rules:
   * 1. Compare magnitudes (absolute values) of the numbers.
   * 2. If magnitudes are equal, compare real parts.
   * 3. If real parts are equal, compare imaginary parts.
   *
   * @param {Array<number|Object>} arr - An array of numbers or complex number objects.
   * @returns {number|Object} The minimum value found in the array.
   * @throws {TypeError} If the input is not an array.
   */
  min(arr) {
    if(!Array.isArray(arr)) {
      this.jsl.env.error('@min: '+language.string(190));
      return;
    }
    arr = arr.filter(num => !isNaN(num));
    
    // Separate real numbers and complex numbers
    const real_numbers = [];
    const complex_numbers = [];
    for(const num of arr) {
      if(typeof num === 'object' && num.real !== undefined && num.imag !== undefined) {
        complex_numbers.push(num);
      } else {
        real_numbers.push(num);
      }
    }

    // Find min among real numbers using existing function
    let min_real = real_numbers.length > 0 ? this.jsl.env.math.min(real_numbers) : null;

    // Find min among complex numbers
    let min_complex = complex_numbers.length > 0 ? complex_numbers[0] : null;
    for(let i = 1; i < complex_numbers.length; i++) {
      if(compareComplex(complex_numbers[i], min_complex) < 0) {
        min_complex = complex_numbers[i];
      }
    }

    // Compare min_real and min_complex
    if(min_real !== null && min_complex !== null) {
      return compareComplex(min_real, min_complex) < 0 ? min_real : min_complex;
    } else if(min_real !== null) {
      return min_real;
    } else {
      return min_complex;
    }
  }
    
  /**
   * Finds the maximum value in an array of numbers, which can include both real numbers and complex numbers.
   * Complex numbers are represented as objects with 'real' and 'imag' properties.
   * The comparison follows Octave's rules:
   * 1. Compare magnitudes (absolute values) of the numbers.
   * 2. If magnitudes are equal, compare real parts.
   * 3. If real parts are equal, compare imaginary parts.
   *
   * @param {Array<number|Object>} arr - An array of numbers or complex number objects.
   * @returns {number|Object} The maximum value found in the array.
   * @throws {TypeError} If the input is not an array.
   */
  max(arr) {
    if(!Array.isArray(arr)) {
      this.jsl.env.error('@max: '+language.string(190));
      return;
    }
    arr = arr.filter(num => !isNaN(num));
    
    // Separate real numbers and complex numbers
    const real_numbers = [];
    const complex_numbers = [];
    for(const num of arr) {
      if(typeof num === 'object' && num.real !== undefined && num.imag !== undefined) {
        complex_numbers.push(num);
      } else {
        real_numbers.push(num);
      }
    }

    // Find max among real numbers using existing function
    let max_real = real_numbers.length > 0 ? this.jsl.env.math.max(real_numbers) : null;

    // Find max among complex numbers
    let max_complex = complex_numbers.length > 0 ? complex_numbers[0] : null;
    for(let i = 1; i < complex_numbers.length; i++) {
      if(compareComplex(complex_numbers[i], max_complex) > 0) {
        max_complex = complex_numbers[i];
      }
    }

    // Compare max_real and max_complex
    if(max_real !== null && max_complex !== null) {
      return compareComplex(max_real, max_complex) > 0 ? max_real : max_complex;
    } else if(max_real !== null) {
      return max_real;
    } else {
      return max_complex;
    }
  }
  
  /**
   * Extracts the real part of a number or an array of numbers.
   * Handles mixed inputs containing both real numbers and complex numbers.
   *
   * @param {number|Object|Array<number|Object>} input - A number, complex number object, or array thereof.
   * @returns {number|Array<number>} The real part(s) of the input.
   * @throws {TypeError} If the input is not a number, complex number object, or array.
   */
  real(input) {
    if(Array.isArray(input)) {
      return input.map(real);
    } else if(typeof input === 'object' && input !== null && 'real' in input && 'imag' in input) {
      return real(input.real);
    } else if(typeof input === 'number') {
      return input;
    } else {
      this.jsl.env.error('@real: '+language.string(192));
    }
  }

  /**
   * Extracts the imaginary part of a number or an array of numbers.
   * Handles mixed inputs containing both real numbers and complex numbers.
   *
   * @param {number|Object|Array<number|Object>} input - A number, complex number object, or array thereof.
   * @returns {number|Array<number>} The imaginary part(s) of the input.
   * @throws {TypeError} If the input is not a number, complex number object, or array.
   */
  imag(input) {
    if(Array.isArray(input)) {
      return input.map(imag);
    } else if(typeof input === 'object' && input !== null && 'real' in input && 'imag' in input) {
      return imag(input.imag);
    } else if(typeof input === 'number') {
      return 0;
    } else {
      this.jsl.env.error('@imag: '+language.string(192));
    }
    return false;
  }
  
  /**
   * Performs cumulative trapezoidal integration on the provided data.
   * @param {...any} args - Arguments required for cumulative trapezoidal integration.
   * @returns {any} The result of the cumulative trapezoidal integration.
   */
  cumtrapz(...args) {
    return this.jsl.env.native_module.cumtrapz(...args);
  }
  
  /**
   * Performs trapezoidal integration on the provided data.
   * @param {...any} args - Arguments required for trapezoidal integration.
   * @returns {any} The result of the trapezoidal integration.
   */
  trapz(...args) {
    return this.jsl.env.native_module.trapz(...args);
  }
  
  /**
   * Compute the mean squared error (MSE) between two arrays.
   * @param {Array<number>} A - The first array.
   * @param {Array<number>} B - The second array.
   * @returns {number} - The mean squared error between A and B.
   * @throws {Error} - If A and B have different lengths or are not arrays.
   */
  mse(A, B) {
    if(!Array.isArray(A) || !Array.isArray(B)) {
      throw new Error("Both inputs must be arrays.");
    }

    if(A.length !== B.length) {
      throw new Error("Input arrays must have the same length.");
    }

    const n = A.length;
    const mse = A.reduce((sum, a, i) => {
      const diff = a - B[i];
      return sum + diff * diff;
    }, 0) / n;

    return mse;
  }
  
  /**
   * Calculates the coefficients of the characteristic polynomial of a square matrix.
   * @param {number[][]} matrix - A square matrix (2D array) for which the characteristic polynomial is computed.
   * @returns {number[]} - An array of coefficients of the characteristic polynomial.
   * @throws {Error} - Throws an error if the input is not a square matrix or has less than 2 rows/columns.
   */
  charpoly(matrix) {
    const n = matrix.length;
    const m = matrix[0].length;

    if(n !== m || n < 1) {
      throw new Error("Argument 'matrix' must be a square matrix.");
    }
    
    if(n == 1) {
      return [1, -matrix[0][0]];
    }
    
    let p = ones(n+1);
    let a1 = [...matrix];
    for(let k = 2; k <= n; k++) {
      p[k-1] = -1 * sum(this.jsl.env.math.diag(a1)) / (k - 1);
      a1 = this.jsl.env.math.multiply(matrix, plus(a1, 
        this.jsl.env.math.multiply(p[k-1], 
        this.jsl.env.math.diag(ones(n)))));
    }

    p[n] = -1 * sum(this.jsl.env.math.diag(a1)) / n;

    return p;
  }
}

exports.PRDC_JSLAB_LIB_MATH = PRDC_JSLAB_LIB_MATH;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={mathjs-doc.js}]
/**
 * @file JSLAB library math.js doc.
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB math.js doc.
 */
class PRDC_JSLAB_MATHJS_DOC {

  constructor() {
    
    /**
     * Test whether a value is a Complex number.
     * @name isComplex
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a Complex number, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */
     
    /**
     * Test whether a value is a BigNumber.
     * @name isBigNumber
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a BigNumber, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a Fraction.
     * @name isFraction
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a Fraction, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a Unit.
     * @name isUnit
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a Unit, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a Matrix.
     * @name isMatrix
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a Matrix, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a collection (Array or Matrix).
     * @name isCollection
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is an Array or Matrix, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a DenseMatrix.
     * @name isDenseMatrix
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a DenseMatrix, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a SparseMatrix.
     * @name isSparseMatrix
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a SparseMatrix, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a Range.
     * @name isRange
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a Range, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is an Index.
     * @name isIndex
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is an Index, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a boolean.
     * @name isBoolean
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a boolean, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a ResultSet.
     * @name isResultSet
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a ResultSet, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a Help object.
     * @name isHelp
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a Help object, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a Date.
     * @name isDate
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a Date object, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a RegExp.
     * @name isRegExp
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a RegExp object, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is an AccessorNode.
     * @name isAccessorNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is an AccessorNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is an ArrayNode.
     * @name isArrayNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is an ArrayNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is an AssignmentNode.
     * @name isAssignmentNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is an AssignmentNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a BlockNode.
     * @name isBlockNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a BlockNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a ConditionalNode.
     * @name isConditionalNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a ConditionalNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a ConstantNode.
     * @name isConstantNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a ConstantNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a FunctionAssignmentNode.
     * @name isFunctionAssignmentNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a FunctionAssignmentNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a FunctionNode.
     * @name isFunctionNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a FunctionNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is an IndexNode.
     * @name isIndexNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is an IndexNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a Node.
     * @name isNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a Node, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is an ObjectNode.
     * @name isObjectNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is an ObjectNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is an OperatorNode.
     * @name isOperatorNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is an OperatorNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a ParenthesisNode.
     * @name isParenthesisNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a ParenthesisNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a RangeNode.
     * @name isRangeNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a RangeNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a RelationalNode.
     * @name isRelationalNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a RelationalNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a SymbolNode.
     * @name isSymbolNode
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a SymbolNode, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is a Chain.
     * @name isChain
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if `x` is a Chain, false otherwise.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Subscribe to an event.
     * @name on
     * @kind function
     * @param { string } event - The event name to subscribe to.
     * @param { function } callback - The callback function to execute when the event occurs.
     * @returns { void }
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Unsubscribe from an event.
     * @name off
     * @kind function
     * @param { string } event - The event name to unsubscribe from.
     * @param { function } [callback] - The callback function to remove.
     * @returns { void }
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Subscribe to an event once.
     * @name once
     * @kind function
     * @param { string } event - The event name to subscribe to.
     * @param { function } callback - The callback function to execute when the event occurs.
     * @returns { void }
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Emit an event, triggering all bound callbacks.
     * @name emit
     * @kind function
     * @param { string } event - The event name to emit.
     * @param { * } [data] - The data to pass to the event handlers.
     * @returns { void }
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * An object containing functions for parsing and evaluating expressions.
     * @name expression
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Import functions or constants into math.js.
     * @name import
     * @kind function
     * @param { Object | Array } object - An object or array of objects with functions or constants to import.
     * @param { Object } [options] - Optional import options.
     * @returns { void }
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a new, isolated math.js instance.
     * @name create
     * @kind function
     * @param { Object } [config] - Optional configuration options.
     * @param { Function[] } [factories] - Optional list of factories to include.
     * @returns { PRDC_JSLAB_MATHJS_DOC } Returns a new instance of math.js.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Factory function to create new functions.
     * @name factory
     * @kind function
     * @param { string } name - The name of the function.
     * @param { string[] } dependencies - Array of dependency names.
     * @param { function } create - Function to create the new function.
     * @returns { function } Returns the created function.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the absolute value of a number.
     * @name abs
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - A number or array with numbers.
     * @returns { number | BigNumber | Complex | Array | Matrix } Returns the absolute value of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing access to a property or index.
     * @name AccessorNode
     * @kind function
     * @param { Node } object - The object being accessed.
     * @param { IndexNode } index - The index used to access the object.
     * @returns { AccessorNode } Returns a new AccessorNode.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse cosine of a value.
     * @name acos
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The arc cosine of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse hyperbolic cosine of a value.
     * @name acosh
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse hyperbolic cosine of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse cotangent of a value.
     * @name acot
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse cotangent of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse hyperbolic cotangent of a value.
     * @name acoth
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse hyperbolic cotangent of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse cosecant of a value.
     * @name acsc
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse cosecant of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse hyperbolic cosecant of a value.
     * @name acsch
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse hyperbolic cosecant of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Add two scalar values, `x + y`.
     * @name addScalar
     * @kind function
     * @param { number | BigNumber | Fraction | Complex } x - First value to add.
     * @param { number | BigNumber | Fraction | Complex } y - Second value to add.
     * @returns { number | BigNumber | Fraction | Complex } Sum of `x` and `y`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Logical AND. Returns true if both inputs are true.
     * @name and
     * @kind function
     * @param { boolean | Array | Matrix } x - First input.
     * @param { boolean | Array | Matrix } y - Second input.
     * @returns { boolean | Array | Matrix } Returns true when both `x` and `y` are true.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Apply a function to each entry in a matrix or array.
     * @name apply
     * @kind function
     * @param { Array | Matrix } x - The input array or matrix.
     * @param { number } dim - The dimension along which to apply the function.
     * @param { function } callback - The function to apply.
     * @returns { Array | Matrix } The result of applying the function along the specified dimension.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the argument of a complex number.
     * @name arg
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Array | Matrix } The argument of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * An array node representing an array in the expression tree.
     * @name ArrayNode
     * @kind function
     * @param { Node[] } items - An array of nodes.
     * @returns { ArrayNode } Returns a new ArrayNode.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse secant of a value.
     * @name asec
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse secant of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse hyperbolic secant of a value.
     * @name asech
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse hyperbolic secant of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse sine of a value.
     * @name asin
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse sine of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse hyperbolic sine of a value.
     * @name asinh
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse hyperbolic sine of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * An assignment node representing variable assignment.
     * @name AssignmentNode
     * @kind function
     * @param { Node } object - The symbol or AccessorNode to assign to.
     * @param { Node } value - The value to assign.
     * @returns { AssignmentNode } Returns a new AssignmentNode.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse tangent of a value.
     * @name atan
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse tangent of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse tangent of `y/x`.
     * @name atan2
     * @kind function
     * @param { number | BigNumber | Array | Matrix } y - Dividend.
     * @param { number | BigNumber | Array | Matrix } x - Divisor.
     * @returns { number | BigNumber | Array | Matrix } The inverse tangent of `y/x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the inverse hyperbolic tangent of a value.
     * @name atanh
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The inverse hyperbolic tangent of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Atomic mass constant, expressed in kg.
     * @name atomicMass
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Avogadro's number, approximately `6.022e23` mol<sup>-1</sup>.
     * @name avogadro
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Compute the Bell Numbers, `B(n)`.
     * @name bellNumbers
     * @kind function
     * @param { number } n - The input value.
     * @returns { number } Returns the nth Bell number.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * BigNumber constructor.
     * @name BigNumber
     * @kind function
     * @param { number | string | BigNumber } value - The numeric value.
     * @returns { BigNumber } Returns a new BigNumber instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a BigNumber with arbitrary precision.
     * @name bignumber
     * @kind function
     * @param { number | string | BigNumber } value - The numeric value.
     * @returns { BigNumber } Returns a BigNumber instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Format a number as binary.
     * @name bin
     * @kind function
     * @param { number | BigNumber } n - The number to format.
     * @returns { string } The binary representation of `n`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Bitwise AND operation.
     * @name bitAnd
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - First value.
     * @param { number | BigNumber | Array | Matrix } y - Second value.
     * @returns { number | BigNumber | Array | Matrix } Result of `x AND y`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Bitwise NOT operation.
     * @name bitNot
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Array | Matrix } Result of `NOT x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Bitwise OR operation.
     * @name bitOr
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - First value.
     * @param { number | BigNumber | Array | Matrix } y - Second value.
     * @returns { number | BigNumber | Array | Matrix } Result of `x OR y`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Bitwise XOR operation.
     * @name bitXor
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - First value.
     * @param { number | BigNumber | Array | Matrix } y - Second value.
     * @returns { number | BigNumber | Array | Matrix } Result of `x XOR y`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing a block of statements.
     * @name BlockNode
     * @kind function
     * @param { Object[] } blocks - An array of statements.
     * @returns { BlockNode } Returns a new BlockNode.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * The Bohr magneton in units of `J/T`.
     * @name bohrMagneton
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * The Bohr radius in meters.
     * @name bohrRadius
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * The Boltzmann constant in `J/K`.
     * @name boltzmann
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Parse a value into a boolean.
     * @name boolean
     * @kind function
     * @param { * } x - The value to parse.
     * @returns { boolean } The parsed boolean value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * The Catalan's constant.
     * @name catalan
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Calculate the cube root of a value.
     * @name cbrt
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Function input.
     * @returns { number | BigNumber | Complex | Array | Matrix } The cube root of `x`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Round a value towards plus infinity.
     * @name ceil
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Array | Matrix } The rounded value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a chained operation, allowing to chain methods.
     * @name chain
     * @kind function
     * @param { * } value - The initial value of the chain.
     * @returns { Chain } A chain object.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Chain constructor.
     * @name Chain
     * @kind function
     * @param { * } value - The initial value.
     * @returns { Chain } Returns a new Chain instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Classical electron radius in meters.
     * @name classicalElectronRadius
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Calculate the number of combinations of n items taken k at a time.
     * @name combinations
     * @kind function
     * @param { number | BigNumber } n - Total number of items.
     * @param { number | BigNumber } k - Number of items to choose.
     * @returns { number | BigNumber } Number of possible combinations.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the number of combinations with replacement of n items taken k at a time.
     * @name combinationsWithRep
     * @kind function
     * @param { number | BigNumber } n - Total number of items.
     * @param { number | BigNumber } k - Number of items to choose.
     * @returns { number | BigNumber } Number of possible combinations with replacement.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compare two values numerically.
     * @name compare
     * @kind function
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } x - First value to compare.
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } y - Second value to compare.
     * @returns { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } Returns 1 when x > y, -1 when x < y, and 0 when x == y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compare two strings using natural order.
     * @name compareNatural
     * @kind function
     * @param { string } x - First string to compare.
     * @param { string } y - Second string to compare.
     * @returns { number } Returns 1 when x > y, -1 when x < y, and 0 when x == y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compare two strings lexicographically.
     * @name compareText
     * @kind function
     * @param { string } x - First string to compare.
     * @param { string } y - Second string to compare.
     * @returns { number } Returns 1 when x > y, -1 when x < y, and 0 when x == y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compile an expression into a compiled function for faster evaluation.
     * @name compile
     * @kind function
     * @param { string | Object } expr - The expression to compile.
     * @returns { Object } A compiled expression that can be evaluated with `eval`.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a complex number.
     * @name complex
     * @kind function
     * @param { number | string | Complex } [re] - Real part or a string representation.
     * @param { number } [im] - Imaginary part.
     * @returns { Complex } Returns a Complex number.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Complex number constructor.
     * @name Complex
     * @kind function
     * @param { number | string | Complex } [re] - Real part or a string representation.
     * @param { number } [im] - Imaginary part.
     * @returns { Complex } A new Complex number.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the composition count of n into k parts.
     * @name composition
     * @kind function
     * @param { number | BigNumber } n - Total number of items.
     * @param { number | BigNumber } k - Number of parts.
     * @returns { number | BigNumber } Number of compositions.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Concatenate matrices or arrays along a specified dimension.
     * @name concat
     * @kind function
     * @param { Array | Matrix } a - First array or matrix.
     * @param { ...Array | ...Matrix } b - Other arrays or matrices.
     * @param { number | BigNumber } [dim=0] - Dimension along which to concatenate.
     * @returns { Array | Matrix } Concatenated array or matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing a conditional expression.
     * @name ConditionalNode
     * @kind function
     * @param { Node } condition - The condition expression.
     * @param { Node } trueExpr - Expression to evaluate when condition is true.
     * @param { Node } falseExpr - Expression to evaluate when condition is false.
     * @returns { ConditionalNode } A new ConditionalNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Conductance quantum in Siemens.
     * @name conductanceQuantum
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Compute the complex conjugate of a complex number.
     * @name conj
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Complex | Array | Matrix } The complex conjugate of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing a constant value.
     * @name ConstantNode
     * @kind function
     * @param { number | string | BigNumber | Fraction } value - The constant value.
     * @returns { ConstantNode } A new ConstantNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the cosine of a value.
     * @name cos
     * @kind function
     * @param { number | Complex | Unit | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The cosine of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the hyperbolic cosine of a value.
     * @name cosh
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The hyperbolic cosine of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the cotangent of a value.
     * @name cot
     * @kind function
     * @param { number | Complex | Unit | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The cotangent of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the hyperbolic cotangent of a value.
     * @name coth
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The hyperbolic cotangent of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Coulomb's constant in Nm^2/C^2.
     * @name coulomb
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Count the number of elements in a matrix or array.
     * @name count
     * @kind function
     * @param { Array | Matrix } x - The input array or matrix.
     * @returns { number } The number of elements.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a user-defined unit and register it with the Unit system.
     * @name createUnit
     * @kind function
     * @param { string } name - The name of the new unit.
     * @param { string | Object } definition - Definition of the unit.
     * @param { Object } [options] - Configuration options.
     * @returns { Unit } The created unit.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the cosecant of a value.
     * @name csc
     * @kind function
     * @param { number | Complex | Unit | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The cosecant of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the hyperbolic cosecant of a value.
     * @name csch
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The hyperbolic cosecant of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the conjugate transpose of a matrix.
     * @name ctranspose
     * @kind function
     * @param { Array | Matrix } x - The matrix to transpose.
     * @returns { Array | Matrix } The conjugate transpose of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the cube of a value.
     * @name cube
     * @kind function
     * @param { number | BigNumber | Complex | Unit | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Complex | Unit | Array | Matrix } The cube of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the cumulative sum of a matrix or array.
     * @name cumsum
     * @kind function
     * @param { Array | Matrix } x - The input array or matrix.
     * @param { number | BigNumber } [dim] - Dimension along which to calculate.
     * @returns { Array | Matrix } The cumulative sum.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test element-wise whether two values are equal.
     * @name deepEqual
     * @kind function
     * @param { * } x - First value to compare.
     * @param { * } y - Second value to compare.
     * @returns { boolean } Returns true if x and y are deep equal.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Dense matrix constructor.
     * @name DenseMatrix
     * @kind function
     * @param { Array } data - The data for the matrix.
     * @returns { DenseMatrix } A new DenseMatrix instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Take the derivative of an expression.
     * @name derivative
     * @kind function
     * @param { string | Node } expr - The expression to differentiate.
     * @param { string | Node } variable - The variable with respect to which to differentiate.
     * @param { Object } [options] - Optional options object.
     * @returns { Node } The derivative of the expression.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Deuteron mass in kilograms.
     * @name deuteronMass
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Calculate the differences between adjacent values in a matrix or array.
     * @name diff
     * @kind function
     * @param { Array | Matrix } x - Input array or matrix.
     * @param { number } [dim=0] - Dimension along which to calculate the difference.
     * @returns { Array | Matrix } The differences.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Divide two scalar values, x / y.
     * @name divideScalar
     * @kind function
     * @param { number | BigNumber | Fraction | Complex } x - Numerator.
     * @param { number | BigNumber | Fraction | Complex } y - Denominator.
     * @returns { number | BigNumber | Fraction | Complex } The result of division.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Divide two matrices element-wise.
     * @name dotDivide
     * @kind function
     * @param { Array | Matrix } x - Numerator matrix.
     * @param { Array | Matrix } y - Denominator matrix.
     * @returns { Array | Matrix } The element-wise division.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Multiply two matrices element-wise.
     * @name dotMultiply
     * @kind function
     * @param { Array | Matrix } x - First matrix.
     * @param { Array | Matrix } y - Second matrix.
     * @returns { Array | Matrix } The element-wise multiplication.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Exponentiate two matrices element-wise.
     * @name dotPow
     * @kind function
     * @param { Array | Matrix } x - Base matrix.
     * @param { Array | Matrix } y - Exponent matrix.
     * @returns { Array | Matrix } The element-wise exponentiation.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Euler's number, the base of natural logarithms.
     * @name e
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Efimov factor.
     * @name efimovFactor
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Calculate eigenvalues and eigenvectors of a matrix.
     * @name eigs
     * @kind function
     * @param { Array | Matrix } x - A square matrix.
     * @returns { Object } An object containing eigenvalues and eigenvectors.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Electric constant (vacuum permittivity) in F/m.
     * @name electricConstant
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Electron mass in kilograms.
     * @name electronMass
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Elementary charge in coulombs.
     * @name elementaryCharge
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Test whether two values are equal.
     * @name equal
     * @kind function
     * @param { * } x - First value to compare.
     * @param { * } y - Second value to compare.
     * @returns { boolean } Returns true if x equals y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether two scalar values are equal.
     * @name equalScalar
     * @kind function
     * @param { number | BigNumber | Fraction | Complex } x - First value.
     * @param { number | BigNumber | Fraction | Complex } y - Second value.
     * @returns { boolean } Returns true if x equals y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether two strings are equal.
     * @name equalText
     * @kind function
     * @param { string } x - First string.
     * @param { string } y - Second string.
     * @returns { boolean } Returns true if x equals y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the error function of a value.
     * @name erf
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Complex | Array | Matrix } The error function evaluated at x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the exponential of a value.
     * @name exp
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Exponent.
     * @returns { number | BigNumber | Complex | Array | Matrix } The exponential of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate exp(x) - 1.
     * @name expm1
     * @kind function
     * @param { number | BigNumber | Complex } x - Input value.
     * @returns { number | BigNumber | Complex } The result of exp(x) - 1.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the factorial of a value.
     * @name factorial
     * @kind function
     * @param { number | BigNumber | Array | Matrix } n - A non-negative integer.
     * @returns { number | BigNumber | Array | Matrix } The factorial of n.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Boolean value false.
     * @name false
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { boolean }
     */

    /**
     * Faraday constant in C/mol.
     * @name faraday
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Fermi coupling constant in GeV^-2.
     * @name fermiCoupling
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Compute the Fast Fourier Transform of a matrix or array.
     * @name fft
     * @kind function
     * @param { Array | Matrix } x - Input array or matrix.
     * @returns { Array | Matrix } The FFT of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Fibonacci heap data structure.
     * @name FibonacciHeap
     * @kind function
     * @param { function } [compare] - Comparison function.
     * @returns { FibonacciHeap } A new FibonacciHeap instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Filter the items in an array or matrix.
     * @name filter
     * @kind function
     * @param { Array | Matrix } x - The input array or matrix.
     * @param { function } test - The test function.
     * @returns { Array | Matrix } The filtered array or matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Fine-structure constant.
     * @name fineStructure
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * First radiation constant in Wm^2.
     * @name firstRadiation
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Round a value towards zero.
     * @name fix
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Array | Matrix } The rounded value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Flatten a multi-dimensional array or matrix into a single dimension.
     * @name flatten
     * @kind function
     * @param { Array | Matrix } x - The input array or matrix.
     * @returns { Array | Matrix } The flattened array or matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Round a value towards negative infinity.
     * @name floor
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Array | Matrix } The rounded value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Iterate over each element of a matrix or array.
     * @name forEach
     * @kind function
     * @param { Array | Matrix } x - The input array or matrix.
     * @param { function } callback - The function to execute on each element.
     * @returns { void }
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Format a value for display.
     * @name format
     * @kind function
     * @param { * } value - The value to format.
     * @param { Object | function } [options] - Formatting options or custom function.
     * @returns { string } The formatted value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a fraction.
     * @name fraction
     * @kind function
     * @param { number | string | Fraction } numerator - Numerator.
     * @param { number | string } [denominator] - Denominator.
     * @returns { Fraction } A new Fraction instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Fraction constructor.
     * @name Fraction
     * @kind function
     * @param { number | string | Fraction } numerator - Numerator.
     * @param { number | string } [denominator] - Denominator.
     * @returns { Fraction } A new Fraction instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing a function assignment in the expression tree.
     * @name FunctionAssignmentNode
     * @kind function
     * @param { string } name - The name of the function being assigned.
     * @param { string[] } params - An array of parameter names.
     * @param { Node } expr - The function expression.
     * @returns { FunctionAssignmentNode } A new FunctionAssignmentNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing a function call in the expression tree.
     * @name FunctionNode
     * @kind function
     * @param { string | SymbolNode } name - The name of the function or a SymbolNode.
     * @param { Node[] } args - An array of argument nodes.
     * @returns { FunctionNode } A new FunctionNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the gamma function of a value.
     * @name gamma
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } n - The input value.
     * @returns { number | BigNumber | Complex | Array | Matrix } The gamma of n.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * The molar gas constant, in units of J/(molK).
     * @name gasConstant
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Compute the greatest common divisor of two or more values.
     * @name gcd
     * @kind function
     * @param { ...number | ...BigNumber | Array | Matrix } args - Two or more integer numbers.
     * @returns { number | BigNumber | Array | Matrix } The greatest common divisor.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Get the data type of a matrix.
     * @name getMatrixDataType
     * @kind function
     * @param { Matrix } matrix - The input matrix.
     * @returns { string } The data type of the matrix elements.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Newtonian constant of gravitation, in m^3/(kg s^2).
     * @name gravitationConstant
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Acceleration due to gravity on Earth, in m/s^2.
     * @name gravity
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Hartree energy, in joules.
     * @name hartreeEnergy
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Test whether a value is a numeric value.
     * @name hasNumericValue
     * @kind function
     * @param { * } x - The value to test.
     * @returns { boolean } Returns true if x is numeric.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Help object constructor.
     * @name Help
     * @kind function
     * @param { * } value - The function or object to get help for.
     * @returns { Help } A new Help instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Format a number as hexadecimal.
     * @name hex
     * @kind function
     * @param { number | BigNumber } value - The value to format.
     * @returns { string } The hexadecimal representation.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the hypotenuse of a list of values.
     * @name hypot
     * @kind function
     * @param { ...number | ...BigNumber | Array | Matrix } args - The input values.
     * @returns { number | BigNumber | Array | Matrix } The hypotenuse.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * The imaginary unit 'i'.
     * @name i
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { Complex }
     */

    /**
     * Create an identity matrix.
     * @name identity
     * @kind function
     * @param { number | Array } size - The size of the matrix.
     * @param { string } [format] - The matrix format.
     * @returns { Matrix } An identity matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the inverse Fast Fourier Transform.
     * @name ifft
     * @kind function
     * @param { Array | Matrix } x - Input array or matrix.
     * @returns { Array | Matrix } The inverse FFT of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Get the imaginary part of a complex number.
     * @name im
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Array | Matrix } The imaginary part of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Immutable dense matrix constructor.
     * @name ImmutableDenseMatrix
     * @kind function
     * @param { Array } data - The data for the matrix.
     * @returns { ImmutableDenseMatrix } A new ImmutableDenseMatrix instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Index constructor for matrices.
     * @name Index
     * @kind function
     * @param { ...Range | ...number } ranges - Ranges or indices.
     * @returns { Index } A new Index instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing an index operation in the expression tree.
     * @name IndexNode
     * @kind function
     * @param { Node[] } dimensions - The indices.
     * @returns { IndexNode } A new IndexNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the intersection of two sets.
     * @name intersect
     * @kind function
     * @param { Array | Matrix } a - First set.
     * @param { Array | Matrix } b - Second set.
     * @returns { Array | Matrix } The intersection of a and b.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Inverse conductance quantum, in ohms.
     * @name inverseConductanceQuantum
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Calculate the modular inverse of a value.
     * @name invmod
     * @kind function
     * @param { number | BigNumber } a - The value.
     * @param { number | BigNumber } m - The modulus.
     * @returns { number | BigNumber } The modular inverse.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is an integer.
     * @name isInteger
     * @kind function
     * @param { number | BigNumber } x - The value to test.
     * @returns { boolean } Returns true if x is an integer.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is negative.
     * @name isNegative
     * @kind function
     * @param { number | BigNumber } x - The value to test.
     * @returns { boolean } Returns true if x is negative.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is positive.
     * @name isPositive
     * @kind function
     * @param { number | BigNumber } x - The value to test.
     * @returns { boolean } Returns true if x is positive.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a number is prime.
     * @name isPrime
     * @kind function
     * @param { number | BigNumber } x - The value to test.
     * @returns { boolean } Returns true if x is prime.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a value is zero.
     * @name isZero
     * @kind function
     * @param { number | BigNumber } x - The value to test.
     * @returns { boolean } Returns true if x is zero.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the Kullback-Leibler divergence between two distributions.
     * @name kldivergence
     * @kind function
     * @param { Array | Matrix } p - First probability distribution.
     * @param { Array | Matrix } q - Second probability distribution.
     * @returns { number } The KL divergence D<sub>KL</sub>(p || q).
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Von Klitzing constant, in ohms.
     * @name klitzing
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Compute the Kronecker product of two matrices.
     * @name kron
     * @kind function
     * @param { Array | Matrix } A - First matrix.
     * @param { Array | Matrix } B - Second matrix.
     * @returns { Matrix } The Kronecker product of A and B.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Natural logarithm of 10.
     * @name LN10
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Natural logarithm of 2.
     * @name LN2
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Base 10 logarithm of e.
     * @name LOG10E
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Base 2 logarithm of e.
     * @name LOG2E
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Test whether value x is larger than y.
     * @name larger
     * @kind function
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } x - First value.
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } y - Second value.
     * @returns { boolean | Array | Matrix } Returns true if x > y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether value x is larger than or equal to y.
     * @name largerEq
     * @kind function
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } x - First value.
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } y - Second value.
     * @returns { boolean | Array | Matrix } Returns true if x >= y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the least common multiple of two or more values.
     * @name lcm
     * @kind function
     * @param { ...number | ...BigNumber | Array | Matrix } args - Two or more integer numbers.
     * @returns { number | BigNumber | Array | Matrix } The least common multiple.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Count the number of leaf nodes in an expression tree.
     * @name leafCount
     * @kind function
     * @param { Node } node - The root node of the expression tree.
     * @returns { number } The number of leaf nodes.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Bitwise left shift operation.
     * @name leftShift
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - Value to be shifted.
     * @param { number | BigNumber | Array | Matrix } y - Amount of bits to shift.
     * @returns { number | BigNumber | Array | Matrix } The shifted value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the natural logarithm of the gamma function.
     * @name lgamma
     * @kind function
     * @param { number } n - The input value.
     * @returns { number } The natural logarithm of the gamma function at n.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the natural logarithm of a value.
     * @name log
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Value for which to calculate the logarithm.
     * @param { number | BigNumber | Complex } [base=e] - Base of the logarithm.
     * @returns { number | BigNumber | Complex | Array | Matrix } The logarithm of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the base-10 logarithm of a value.
     * @name log10
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Value for which to calculate the logarithm.
     * @returns { number | BigNumber | Complex | Array | Matrix } The base-10 logarithm of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the natural logarithm of 1 plus a value.
     * @name log1p
     * @kind function
     * @param { number | BigNumber } x - Input value.
     * @returns { number | BigNumber } The result of log(1 + x).
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the base-2 logarithm of a value.
     * @name log2
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Value for which to calculate the logarithm.
     * @returns { number | BigNumber | Complex | Array | Matrix } The base-2 logarithm of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Loschmidt constant at 0°C and 1 atm, in m^-3.
     * @name loschmidt
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Solve a linear system A * x = b where A is a lower triangular matrix.
     * @name lsolve
     * @kind function
     * @param { Matrix | Array } L - A lower triangular matrix.
     * @param { Matrix | Array } b - A column vector.
     * @returns { Matrix | Array } The solution vector x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Find all solutions of a linear system A * x = b where A is a lower triangular matrix.
     * @name lsolveAll
     * @kind function
     * @param { Matrix | Array } L - A lower triangular matrix.
     * @param { Matrix | Array } b - A column vector.
     * @returns { Array } An array of solutions.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the LU decomposition with partial pivoting.
     * @name lup
     * @kind function
     * @param { Matrix | Array } A - A square matrix.
     * @param { number } [threshold=1e-10] - Tolerance threshold.
     * @returns { Object } An object containing L, U, and P matrices.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Solve a linear system using LU decomposition.
     * @name lusolve
     * @kind function
     * @param { Matrix | Array } A - Coefficient matrix.
     * @param { Matrix | Array } b - Right-hand side vector or matrix.
     * @param { string } [order] - Matrix storage order.
     * @returns { Matrix | Array } The solution vector or matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Solve the Lyapunov equation A*X + X*A' = Q.
     * @name lyap
     * @kind function
     * @param { Matrix | Array } A - A square matrix.
     * @param { Matrix | Array } Q - A square matrix.
     * @returns { Matrix } Solution X of the Lyapunov equation.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the median absolute deviation of a set of values.
     * @name mad
     * @kind function
     * @param { Array | Matrix } array - Input array.
     * @param { number | BigNumber } [dim] - Dimension along which to compute.
     * @returns { number | BigNumber | Array | Matrix } The median absolute deviation.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Magnetic constant (vacuum permeability), in N/A^2.
     * @name magneticConstant
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Magnetic flux quantum, in Wb.
     * @name magneticFluxQuantum
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Map a function over the elements of a matrix or array.
     * @name map
     * @kind function
     * @param { Array | Matrix } x - The input array or matrix.
     * @param { function } callback - The function to apply.
     * @returns { Array | Matrix } The result after applying the callback.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a matrix.
     * @name matrix
     * @kind function
     * @param { Array | Matrix } [data] - The data for the matrix.
     * @param { string } [format] - The matrix format.
     * @returns { Matrix } A new Matrix instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Matrix constructor.
     * @name Matrix
     * @kind function
     * @param { Array | Matrix } [data] - The data for the matrix.
     * @param { string } [format] - The matrix format.
     * @returns { Matrix } A new Matrix instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a matrix from given columns.
     * @name matrixFromColumns
     * @kind function
     * @param { ...Array | ...Matrix } columns - Columns to construct the matrix.
     * @returns { Matrix } The constructed matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a matrix using a provided function.
     * @name matrixFromFunction
     * @kind function
     * @param { Array } size - The size of the matrix.
     * @param { function } callback - Function to generate matrix entries.
     * @returns { Matrix } The generated matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a matrix from given rows.
     * @name matrixFromRows
     * @kind function
     * @param { ...Array | ...Matrix } rows - Rows to construct the matrix.
     * @returns { Matrix } The constructed matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the arithmetic mean of a set of values.
     * @name mean
     * @kind function
     * @param { Array | Matrix } array - Input array.
     * @param { number | BigNumber } [dim] - Dimension along which to compute.
     * @returns { number | BigNumber | Array | Matrix } The mean value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the median of a set of values.
     * @name median
     * @kind function
     * @param { Array | Matrix } array - Input array.
     * @param { number | BigNumber } [dim] - Dimension along which to compute.
     * @returns { number | BigNumber | Array | Matrix } The median value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the modulus of two numbers.
     * @name mod
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - Dividend.
     * @param { number | BigNumber | Array | Matrix } y - Divisor.
     * @returns { number | BigNumber | Array | Matrix } The remainder after division.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the mode of a set of values.
     * @name mode
     * @kind function
     * @param { Array | Matrix } array - Input array.
     * @returns { Array | Matrix } The mode(s) of the array.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Molar mass constant, in kg/mol.
     * @name molarMass
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Molar mass of carbon-12, in kg/mol.
     * @name molarMassC12
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Molar Planck constant, in J·s/mol.
     * @name molarPlanckConstant
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Molar volume of an ideal gas at 1 atm and 0°C, in m³/mol.
     * @name molarVolume
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Compute the multinomial coefficient of a list of integers.
     * @name multinomial
     * @kind function
     * @param { ...number | Array } args - Integer numbers.
     * @returns { number } The multinomial coefficient.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Multiply two scalar values, x * y.
     * @name multiplyScalar
     * @kind function
     * @param { number | BigNumber | Fraction | Complex } x - First value.
     * @param { number | BigNumber | Fraction | Complex } y - Second value.
     * @returns { number | BigNumber | Fraction | Complex } The product of x and y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Neutron mass, in kilograms.
     * @name neutronMass
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Logical NOT operation.
     * @name not
     * @kind function
     * @param { boolean | Array | Matrix } x - Input value.
     * @returns { boolean | Array | Matrix } The logical negation of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the nth root of a value.
     * @name nthRoot
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } a - The value.
     * @param { number | BigNumber } [root=2] - The root.
     * @returns { number | BigNumber | Complex | Array | Matrix } The nth root of a.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the nth roots of a complex number.
     * @name nthRoots
     * @kind function
     * @param { number | Complex } a - The value.
     * @param { number | BigNumber } n - The degree of the root.
     * @returns { Array } An array of the n roots.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Nuclear magneton, in J/T.
     * @name nuclearMagneton
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * JavaScript null value.
     * @name null
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { null }
     */

    /**
     * Parse a value into a number.
     * @name number
     * @kind function
     * @param { * } value - The value to parse.
     * @returns { number } The numeric value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Convert a math.js data type to a numeric type.
     * @name numeric
     * @kind function
     * @param { * } value - The value to convert.
     * @returns { number | BigNumber | Complex } The numeric representation.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing an object in the expression tree.
     * @name ObjectNode
     * @kind function
     * @param { Object } properties - Object properties as nodes.
     * @returns { ObjectNode } A new ObjectNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Format a number as octal.
     * @name oct
     * @kind function
     * @param { number | BigNumber } value - The value to format.
     * @returns { string } The octal representation.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing an operator in the expression tree.
     * @name OperatorNode
     * @kind function
     * @param { string } op - The operator symbol.
     * @param { string } fn - The function name.
     * @param { Node[] } args - An array of argument nodes.
     * @param { boolean } [implicit=false] - Is the operator implicit?
     * @returns { OperatorNode } A new OperatorNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Logical OR operation.
     * @name or
     * @kind function
     * @param { boolean | Array | Matrix } x - First value.
     * @param { boolean | Array | Matrix } y - Second value.
     * @returns { boolean | Array | Matrix } The logical OR of x and y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing parentheses in the expression tree.
     * @name ParenthesisNode
     * @kind function
     * @param { Node } content - The node encapsulated by the parentheses.
     * @returns { ParenthesisNode } A new ParenthesisNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Parse and evaluate an expression.
     * @name parse
     * @kind function
     * @param { string | Object } expr - The expression to parse.
     * @returns { Node | Node[] } The parsed expression node(s).
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a parser with its own scope and functions.
     * @name parser
     * @kind function
     * @returns { Parser } A new Parser instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Parser constructor.
     * @name Parser
     * @kind function
     * @returns { Parser } A new Parser instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Select an element from a matrix or array based on its sorted position.
     * @name partitionSelect
     * @kind function
     * @param { Array | Matrix } x - The input array or matrix.
     * @param { number } k - The kth smallest value to select.
     * @param { function } [compare] - Optional comparison function.
     * @returns { number | BigNumber | Fraction | Complex } The selected element.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the number of permutations of n items taken k at a time.
     * @name permutations
     * @kind function
     * @param { number | BigNumber } n - Total number of items.
     * @param { number | BigNumber } [k] - Number of items to choose.
     * @returns { number | BigNumber } Number of possible permutations.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * The golden ratio, approximately 1.618.
     * @name phi
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * The mathematical constant pi.
     * @name pi
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Randomly pick one or more values from a list.
     * @name pickRandom
     * @kind function
     * @param { Array } array - Array to pick values from.
     * @param { number } [number] - Number of values to pick.
     * @returns { * | Array } Picked value(s).
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the pseudoinverse of a matrix.
     * @name pinv
     * @kind function
     * @param { Array | Matrix } x - A matrix.
     * @returns { Matrix } The pseudoinverse of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Planck charge, in coulombs.
     * @name planckCharge
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Planck constant, in joule seconds.
     * @name planckConstant
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Planck length, in meters.
     * @name planckLength
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Planck mass, in kilograms.
     * @name planckMass
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Planck temperature, in kelvin.
     * @name planckTemperature
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Planck time, in seconds.
     * @name planckTime
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Find roots of a univariate polynomial.
     * @name polynomialRoot
     * @kind function
     * @param { Array } coefficients - Coefficients of the polynomial.
     * @returns { Array } An array of roots.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the power of x to y, x^y.
     * @name pow
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Base.
     * @param { number | BigNumber | Complex | Array | Matrix } y - Exponent.
     * @returns { number | BigNumber | Complex | Array | Matrix } x raised to the power y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the product of a set of values.
     * @name prod
     * @kind function
     * @param { Array | Matrix } array - Input array.
     * @param { number | BigNumber } [dim] - Dimension along which to compute the product.
     * @returns { number | BigNumber | Array | Matrix } The product of all values.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Proton mass, in kilograms.
     * @name protonMass
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Compute the QR decomposition of a matrix.
     * @name qr
     * @kind function
     * @param { Matrix | Array } x - A matrix.
     * @returns { Object } An object containing Q and R matrices.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the quantile of a sequence.
     * @name quantileSeq
     * @kind function
     * @param { Array | Matrix } data - Input data.
     * @param { number | Array } prob - Probability or array of probabilities.
     * @param { boolean } [sorted=false] - Is data sorted?
     * @returns { number | Array } The quantile(s).
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Quantum of circulation, in m^2/s.
     * @name quantumOfCirculation
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Generate a random integer between min and max.
     * @name randomInt
     * @kind function
     * @param { number | BigNumber } [min] - Minimum value, inclusive.
     * @param { number | BigNumber } max - Maximum value, inclusive.
     * @returns { number | BigNumber } A random integer.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a range.
     * @name Range
     * @kind function
     * @param { * } start - Start of the range.
     * @param { * } end - End of the range.
     * @param { * } [step=1] - Step size.
     * @returns { Range } A new Range instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing a range in the expression tree.
     * @name RangeNode
     * @kind function
     * @param { Node } start - Start node.
     * @param { Node } end - End node.
     * @param { Node } [step] - Step node.
     * @returns { RangeNode } A new RangeNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Rationalize an expression.
     * @name rationalize
     * @kind function
     * @param { string | Node } expr - The expression to rationalize.
     * @param { Object } [scope] - Scope of variables.
     * @param { Object } [options] - Options object.
     * @returns { Object } An object with expression and denominator.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Get the real part of a complex number.
     * @name re
     * @kind function
     * @param { number | BigNumber | Complex | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Array | Matrix } The real part of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Reduced Planck constant, in joule seconds.
     * @name reducedPlanckConstant
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * A node representing a relational operation.
     * @name RelationalNode
     * @kind function
     * @param { string } condition - Relational condition.
     * @param { Node } params - Parameters.
     * @returns { RelationalNode } A new RelationalNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Replacer function for JSON serialization.
     * @name replacer
     * @kind function
     * @param { string } key - Property name.
     * @param { * } value - Property value.
     * @returns { * } The transformed value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Resize a matrix.
     * @name resize
     * @kind function
     * @param { Array | Matrix } x - The input matrix.
     * @param { Array } size - The new size.
     * @param { * } [defaultValue=0] - Default value for new entries.
     * @returns { Array | Matrix } The resized matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Resolve the value of a symbol or function.
     * @name resolve
     * @kind function
     * @param { string } name - The name to resolve.
     * @returns { * } The resolved value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * ResultSet constructor.
     * @name ResultSet
     * @kind function
     * @param { Array } entries - The entries in the result set.
     * @returns { ResultSet } A new ResultSet instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Reviver function for JSON deserialization.
     * @name reviver
     * @kind function
     * @param { string } key - Property name.
     * @param { * } value - Property value.
     * @returns { * } The transformed value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Bitwise right arithmetic shift operation.
     * @name rightArithShift
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - The value to shift.
     * @param { number | BigNumber | Array | Matrix } y - The amount to shift.
     * @returns { number | BigNumber | Array | Matrix } The shifted value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Bitwise right logical shift operation.
     * @name rightLogShift
     * @kind function
     * @param { number | BigNumber | Array | Matrix } x - The value to shift.
     * @param { number | BigNumber | Array | Matrix } y - The amount to shift.
     * @returns { number | BigNumber | Array | Matrix } The shifted value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Rotate the elements of a matrix.
     * @name rotate
     * @kind function
     * @param { Array | Matrix } x - The input matrix.
     * @param { number | BigNumber } [turns=1] - Number of 90-degree rotations.
     * @returns { Array | Matrix } The rotated matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a 2D rotation matrix.
     * @name rotationMatrix
     * @kind function
     * @param { number | BigNumber } theta - Rotation angle in radians.
     * @returns { Matrix } The rotation matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Rydberg constant, in m^-1.
     * @name rydberg
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Square root of 1/2.
     * @name SQRT1_2
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Square root of 2.
     * @name SQRT2
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Sackur-Tetrode constant at 1 atm, in J/K.
     * @name sackurTetrode
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Compute the Schur decomposition of a matrix.
     * @name schur
     * @kind function
     * @param { Matrix | Array } A - A square matrix.
     * @returns { Object } An object containing matrices U and T.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the secant of a value.
     * @name sec
     * @kind function
     * @param { number | Complex | Unit | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The secant of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the hyperbolic secant of a value.
     * @name sech
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The hyperbolic secant of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Second radiation constant, in m·K.
     * @name secondRadiation
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Create the Cartesian product of two or more sets.
     * @name setCartesian
     * @kind function
     * @param { ...Array | ...Matrix } sets - The sets to compute the product of.
     * @returns { Array | Matrix } The Cartesian product.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the difference between two sets.
     * @name setDifference
     * @kind function
     * @param { Array | Matrix } a - First set.
     * @param { Array | Matrix } b - Second set.
     * @returns { Array | Matrix } The difference a \ b.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Remove duplicate elements from a set.
     * @name setDistinct
     * @kind function
     * @param { Array | Matrix } a - Input set.
     * @returns { Array | Matrix } A set with distinct elements.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the intersection of two or more sets.
     * @name setIntersect
     * @kind function
     * @param { Array | Matrix } a - First set.
     * @param { Array | Matrix } b - Second set.
     * @param { ...Array | ...Matrix } [others] - Additional sets.
     * @returns { Array | Matrix } The intersection of the sets.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether a set is a subset of another set.
     * @name setIsSubset
     * @kind function
     * @param { Array | Matrix } a - Potential subset.
     * @param { Array | Matrix } b - Superset.
     * @returns { boolean } Returns true if a is a subset of b.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Count the multiplicity of an element in a multiset.
     * @name setMultiplicity
     * @kind function
     * @param { * } e - Element to count.
     * @param { Array | Matrix } multiset - The multiset.
     * @returns { number } The multiplicity of e.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the power set of a set.
     * @name setPowerset
     * @kind function
     * @param { Array | Matrix } set - The input set.
     * @returns { Array | Matrix } The power set.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Get the size of a set.
     * @name setSize
     * @kind function
     * @param { Array | Matrix } set - The input set.
     * @returns { number } The number of elements.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the symmetric difference of two sets.
     * @name setSymDifference
     * @kind function
     * @param { Array | Matrix } a - First set.
     * @param { Array | Matrix } b - Second set.
     * @returns { Array | Matrix } The symmetric difference.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the union of two or more sets.
     * @name setUnion
     * @kind function
     * @param { Array | Matrix } a - First set.
     * @param { Array | Matrix } b - Second set.
     * @param { ...Array | ...Matrix } [others] - Additional sets.
     * @returns { Array | Matrix } The union of the sets.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the sign of a number.
     * @name sign
     * @kind function
     * @param { number | BigNumber | Fraction | Complex | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Fraction | Complex | Array | Matrix } The sign of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Simplify an expression.
     * @name simplify
     * @kind function
     * @param { string | Node } expr - The expression to simplify.
     * @param { Object | Array | Function } [rules] - Simplification rules.
     * @param { Object } [scope] - Scope for variables.
     * @returns { Node } The simplified expression.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Simplify an expression containing constants.
     * @name simplifyConstant
     * @kind function
     * @param { Node } expr - The expression to simplify.
     * @param { Object } [options] - Simplification options.
     * @returns { Node } The simplified expression.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Perform core simplifications on an expression.
     * @name simplifyCore
     * @kind function
     * @param { Node } expr - The expression to simplify.
     * @returns { Node } The simplified expression.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the sine of a value.
     * @name sin
     * @kind function
     * @param { number | Complex | Unit | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The sine of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the hyperbolic sine of a value.
     * @name sinh
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The hyperbolic sine of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Sparse Linear Solver using LU decomposition.
     * @name slu
     * @kind function
     * @param { Matrix | Array } A - A sparse matrix.
     * @param { number } order - Ordering and analysis control parameter.
     * @param { number } threshold - Partial pivoting threshold.
     * @returns { Object } The LU decomposition.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether value x is smaller than y.
     * @name smaller
     * @kind function
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } x - First value.
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } y - Second value.
     * @returns { boolean | Array | Matrix } Returns true if x < y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether value x is smaller than or equal to y.
     * @name smallerEq
     * @kind function
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } x - First value.
     * @param { number | BigNumber | Fraction | Complex | Unit | string | Array | Matrix } y - Second value.
     * @returns { boolean | Array | Matrix } Returns true if x <= y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the Sparse LU decomposition of a matrix.
     * @name Spa
     * @kind function
     * @param { Matrix | Array } A - A sparse matrix.
     * @returns { Object } The LU decomposition.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a sparse matrix.
     * @name sparse
     * @kind function
     * @param { Array | Matrix } [data] - The data for the matrix.
     * @param { string } [datatype] - The data type.
     * @returns { SparseMatrix } A new SparseMatrix instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Sparse matrix constructor.
     * @name SparseMatrix
     * @kind function
     * @param { Object } [data] - The data for the matrix.
     * @returns { SparseMatrix } A new SparseMatrix instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Speed of light in vacuum, in m/s.
     * @name speedOfLight
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Split a unit into its numeric value and unit string.
     * @name splitUnit
     * @kind function
     * @param { Unit } unit - The unit to split.
     * @param { Array } parts - Array of units to split into.
     * @returns { Array } Array of units.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the square root of a value.
     * @name sqrt
     * @kind function
     * @param { number | BigNumber | Complex | Unit | Array | Matrix } x - Value for which to calculate the square root.
     * @returns { number | BigNumber | Complex | Unit | Array | Matrix } The square root of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the principal square root of a matrix.
     * @name sqrtm
     * @kind function
     * @param { Array | Matrix } x - A square matrix.
     * @returns { Matrix } The principal square root of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the square of a value.
     * @name square
     * @kind function
     * @param { number | BigNumber | Complex | Unit | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Complex | Unit | Array | Matrix } The square of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Remove singleton dimensions from an array or matrix.
     * @name squeeze
     * @kind function
     * @param { Array | Matrix } x - The input array or matrix.
     * @returns { Array | Matrix } The squeezed array or matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Compute the standard deviation of a set of values.
     * @name std
     * @kind function
     * @param { Array | Matrix } array - Input array.
     * @param { string } [normalization='unbiased'] - Normalization mode.
     * @param { number | BigNumber } [dim] - Dimension along which to compute.
     * @returns { number | BigNumber | Array | Matrix } The standard deviation.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Stefan-Boltzmann constant, in W/(m^2K^4).
     * @name stefanBoltzmann
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Stirling numbers of the second kind.
     * @name stirlingS2
     * @kind function
     * @param { number | BigNumber } n - Total number of objects.
     * @param { number | BigNumber } k - Number of non-empty subsets.
     * @returns { number | BigNumber } The Stirling number.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Parse a value into a string.
     * @name string
     * @kind function
     * @param { * } value - The value to convert.
     * @returns { string } The string representation of value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Get or set a subset of a matrix or array.
     * @name subset
     * @kind function
     * @param { Array | Matrix } x - The input matrix.
     * @param { Index } index - The index.
     * @param { * } [replacement] - The replacement value.
     * @param { boolean } [defaultValue] - Default value for missing entries.
     * @returns { * } The subset or updated matrix.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Solve the Sylvester equation A*X + X*B = C.
     * @name sylvester
     * @kind function
     * @param { Matrix | Array } A - A square matrix.
     * @param { Matrix | Array } B - A square matrix.
     * @param { Matrix | Array } C - A matrix.
     * @returns { Matrix } Solution X of the Sylvester equation.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * A node representing a symbol in the expression tree.
     * @name SymbolNode
     * @kind function
     * @param { string } name - The symbol name.
     * @returns { SymbolNode } A new SymbolNode instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether two expressions are symbolically equal.
     * @name symbolicEqual
     * @kind function
     * @param { Node } expr1 - First expression.
     * @param { Node } expr2 - Second expression.
     * @param { Object } [options] - Comparison options.
     * @returns { boolean } Returns true if expressions are symbolically equal.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the tangent of a value.
     * @name tan
     * @kind function
     * @param { number | Complex | Unit | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The tangent of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Calculate the hyperbolic tangent of a value.
     * @name tanh
     * @kind function
     * @param { number | Complex | Array | Matrix } x - Function input.
     * @returns { number | Complex | Array | Matrix } The hyperbolic tangent of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * The constant tau, equal to 2pi.
     * @name tau
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Thomson cross section, in m^2.
     * @name thomsonCrossSection
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Convert a unit to another unit.
     * @name to
     * @kind function
     * @param { Unit } x - The unit to be converted.
     * @param { Unit | string } unit - Target unit.
     * @returns { Unit } The converted unit.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Boolean value true.
     * @name true
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { boolean }
     */

    /**
     * Get the type of a variable.
     * @name typeOf
     * @kind function
     * @param { * } x - The variable.
     * @returns { string } The type of x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a typed-function.
     * @name typed
     * @kind function
     * @param { string } name - Function name.
     * @param { Object } signatures - Function signatures.
     * @returns { function } The typed function.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Invert the sign of a value.
     * @name unaryMinus
     * @kind function
     * @param { number | BigNumber | Fraction | Complex | Unit | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Fraction | Complex | Unit | Array | Matrix } The negated value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Unary plus operation.
     * @name unaryPlus
     * @kind function
     * @param { number | BigNumber | Fraction | Complex | Unit | Array | Matrix } x - Input value.
     * @returns { number | BigNumber | Fraction | Complex | Unit | Array | Matrix } The input value.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Test whether two values are unequal.
     * @name unequal
     * @kind function
     * @param { * } x - First value.
     * @param { * } y - Second value.
     * @returns { boolean | Array | Matrix } Returns true if x is not equal to y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Unit constructor.
     * @name Unit
     * @kind function
     * @param { number | BigNumber } value - The numeric value.
     * @param { string | Unit } unit - The unit string or Unit object.
     * @returns { Unit } A new Unit instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Create a unit.
     * @name unit
     * @kind function
     * @param { number | BigNumber } value - The numeric value.
     * @param { string | Unit } unit - The unit string or Unit object.
     * @returns { Unit } A new Unit instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * The base of natural logarithms, e.
     * @name E
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * The mathematical constant pi.
     * @name PI
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Solve a linear system A * x = b where A is an upper triangular matrix.
     * @name usolve
     * @kind function
     * @param { Matrix | Array } U - An upper triangular matrix.
     * @param { Matrix | Array } b - A column vector.
     * @returns { Matrix | Array } The solution vector x.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Find all solutions of a linear system A * x = b where A is an upper triangular matrix.
     * @name usolveAll
     * @kind function
     * @param { Matrix | Array } U - An upper triangular matrix.
     * @param { Matrix | Array } b - A column vector.
     * @returns { Array } An array of solutions.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Vacuum impedance, in ohms.
     * @name vacuumImpedance
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Compute the variance of a set of values.
     * @name variance
     * @kind function
     * @param { Array | Matrix } array - Input array.
     * @param { string } [normalization='unbiased'] - Normalization mode.
     * @param { number | BigNumber } [dim] - Dimension along which to compute.
     * @returns { number | BigNumber | Array | Matrix } The variance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Weak mixing angle.
     * @name weakMixingAngle
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Wien displacement constant, in m·K.
     * @name wienDisplacement
     * @kind member
     * @memberof PRDC_JSLAB_MATHJS_DOC
     * @type { number }
     */

    /**
     * Extended greatest common divisor for integers.
     * @name xgcd
     * @kind function
     * @param { number | BigNumber } a - An integer.
     * @param { number | BigNumber } b - An integer.
     * @returns { Array } An array [gcd, x, y] satisfying gcd = a*x + b*y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Logical XOR operation.
     * @name xor
     * @kind function
     * @param { boolean | Array | Matrix } x - First value.
     * @param { boolean | Array | Matrix } y - Second value.
     * @returns { boolean | Array | Matrix } The logical XOR of x and y.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Error thrown when an incorrect number of arguments is passed.
     * @name ArgumentsError
     * @kind function
     * @param { string } fn - Function name.
     * @param { number } count - Actual argument count.
     * @param { number } min - Minimum required arguments.
     * @param { number } [max] - Maximum allowed arguments.
     * @returns { ArgumentsError } A new ArgumentsError instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Error thrown when matrix dimensions mismatch.
     * @name DimensionError
     * @kind function
     * @param { number } actual - Actual dimension.
     * @param { number } expected - Expected dimension.
     * @param { string } [relation] - Relation between dimensions.
     * @returns { DimensionError } A new DimensionError instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */

    /**
     * Error thrown when an index is out of range.
     * @name IndexError
     * @kind function
     * @param { number } index - The invalid index.
     * @param { number } min - Minimum allowed index.
     * @param { number } max - Maximum allowed index.
     * @returns { IndexError } A new IndexError instance.
     * @memberof PRDC_JSLAB_MATHJS_DOC
     */
  }
}
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={matrix-math.js}]
/**
 * @file JSLAB library matrix math submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB matrix math submodule.
 */
class PRDC_JSLAB_MATRIX_MATH {

  /**
   * Constructs a matrix math submodule object with access to JSLAB's math functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    this.jsl = jsl;
  }
  
  /**
   * Creates a new matrix.
   * @param {Array} A - The matrix data.
   * @param {number} rows - Number of rows.
   * @param {number} cols - Number of columns.
   * @returns {PRDC_JSLAB_MATRIX} A new matrix instance.
   */
  new(A, rows, cols) {
    return new PRDC_JSLAB_MATRIX(this.jsl, A, rows, cols);
  }

  /**
   * Creates a matrix filled with a specific value.
   * @param {number} v - The value to fill the matrix with.
   * @param {number} rows - Number of rows.
   * @param {number} [cols=rows] - Number of columns.
   * @returns {PRDC_JSLAB_MATRIX} The filled matrix.
   */
  fill(v, rows, cols) {
    if(!cols) {
      cols = rows;
    }
    return new PRDC_JSLAB_MATRIX(this.jsl, 
      this.jsl.array.createFilledArray(rows * cols, v), rows, cols);
  }
  
  /**
   * Creates a matrix filled with NaN values.
   * @param {number} rows - Number of rows.
   * @param {number} [cols=rows] - Number of columns.
   * @returns {PRDC_JSLAB_MATRIX} The NaN-filled matrix.
   */
  NaNs(rows, cols) {
    if(!cols) {
      cols = rows;
    }
    return this.fill(NaN, rows, cols);
  }
  
  /**
   * Creates a matrix filled with ones.
   * @param {number} rows - Number of rows.
   * @param {number} [cols=rows] - Number of columns.
   * @returns {PRDC_JSLAB_MATRIX} The ones-filled matrix.
   */
  ones(rows, cols) {
    if(!cols) {
      cols = rows;
    }
    return this.fill(1, rows, cols);
  }
  
  /**
   * Creates a matrix filled with zeros.
   * @param {number} rows - Number of rows.
   * @param {number} [cols=rows] - Number of columns.
   * @returns {PRDC_JSLAB_MATRIX} The zeros-filled matrix.
   */
  zeros(rows, cols) {
    if(!cols) {
      cols = rows;
    }
    return this.fill(0, rows, cols);
  }
  
  /**
   * Creates a diagonal matrix from an array.
   * @param {Array} A - The array to create the diagonal matrix from.
   * @returns {PRDC_JSLAB_MATRIX} The diagonal matrix.
   */
  diag(A) {
    return new PRDC_JSLAB_MATRIX(this.jsl, 
      this.jsl.array.diag(A, A.length), A.length, A.length);
  }
  
  /**
   * Creates an identity matrix of a given size.
   * @param {number} size - The size of the identity matrix.
   * @returns {PRDC_JSLAB_MATRIX} The identity matrix.
   */
  eye(size) {
    return new PRDC_JSLAB_MATRIX(this.jsl, 
      this.jsl.array.diag(this.jsl.array.ones(size), size), size, size);
  }
  
  /**
   * Concatenates multiple matrices vertically (row-wise).
   * @param {...PRDC_JSLAB_MATRIX} args - Matrices to concatenate.
   * @returns {PRDC_JSLAB_MATRIX} The concatenated matrix.
   */
  concatRow(...args) {
    var N = args.length;
    var cols = args[0].cols;
    var rows = args.reduce((a, e) => a += e.rows, 0);
    var A = new Array(cols * rows).fill(0);
    
    var p = 0;
    for(var j = 0; j < cols; j++) {
      for(var k = 0; k < N; k++) {  
        var P = args[k].data.length / cols;
        for(var i = 0; i < P; i++) {
          A[p++] = args[k].data[j*P+i];
        }
      }
    }
    return this.new(A, rows, cols);
  }

  /**
   * Concatenates multiple matrices horizontally (column-wise).
   * @param {...PRDC_JSLAB_MATRIX} args - Matrices to concatenate.
   * @returns {PRDC_JSLAB_MATRIX} The concatenated matrix.
   */
  concatCol(...args) {
    var rows = args[0].rows;
    var A = args.map((a) => a.data).flat();
    return this.new(A, rows, A.length / rows);
  }

  /**
   * Checks if the provided object is a matrix.
   * @param {Object} A - The object to check.
   * @returns {boolean} True if A is a matrix, else false.
   */
  isMatrix(A) {
    return A instanceof PRDC_JSLAB_MATRIX;
  }
}

exports.PRDC_JSLAB_MATRIX_MATH = PRDC_JSLAB_MATRIX_MATH;

/**
 * Class for JSLAB matrix.
 */
class PRDC_JSLAB_MATRIX {
  
  #jsl;
  #rows;
  #cols;
  
  /**
   * Constructs a JSLAB matrix.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   * @param {Array} A - The matrix data.
   * @param {number} rows - Number of rows.
   * @param {number} cols - Number of columns.
   */
  constructor(jsl, A, rows, cols) {
    this.#jsl = jsl;
    this._set(A, rows, cols);
  }
  
  /**
   * Sets the matrix data and dimensions.
   * @param {Array} A - The matrix data.
   * @param {number} rows - Number of rows.
   * @param {number} cols - Number of columns.
   */
  _set(A, rows, cols) {
    this.rows = rows;
    this.cols = cols;
    if(!rows) {
      this.rows = A.length;
    }
    if(!cols) {
      this.cols = A[0].length;
    }
    if(Array.isArray(A[0])) {
      this.data = this.#jsl.array.transpose(A.flat(), this.rows, this.cols);
    } else {
      this.data = [...A];
    }
  }

  /**
   * Extracts a specific column from a matrix.
   * @param {number} index - The index of the column to extract.
   * @returns {Array} The extracted column as an array.
   */
  column(index) {
    return this.#jsl.array.column(this.toArray(), index);
  }

  /**
   * Extracts a specific row from a matrix.
   * @param {number} index - The index of the row to extract.
   * @returns {Array} The extracted row as an array.
   */
  row(index) {
    return this.#jsl.array.row(this.toArray(), index);
  }
  
  /**
   * Gets the length of the matrix along a specified dimension.
   * @param {number} dim - The dimension (0 for rows, 1 for columns).
   * @returns {number} The length along the specified dimension.
   */
  length(dim) {
    return this.size(dim);
  }
  
  /**
   * Gets the number of elements in the matrix.
   * @returns {number} The number of elements.
   */
  numel() {
    return this.rows * this.cols;
  }
  
  /**
   * Gets the size of the matrix along a specified dimension.
   * @param {number} dim - The dimension (0 for rows, 1 for columns).
   * @returns {number} The size along the specified dimension.
   */
  size(dim) {
    var s = [this.rows, this.cols];
    if(typeof dim == 'undefined') {
      return s;
    }
    return s[dim];
  }
  
  /**
   * Reshapes the matrix to the specified dimensions.
   * @param {number} rows - New number of rows.
   * @param {number} cols - New number of columns.
   * @returns {PRDC_JSLAB_MATRIX} The reshaped matrix.
   */
  reshape(rows, cols) {
    return this.#jsl.mat.new(this.#jsl.array.reshape(this.data, 
      rows, cols), rows, cols);
  }
  
  /**
   * Replicates the matrix a specified number of times.
   * @param {number} rowReps - Number of row repetitions.
   * @param {number} colReps - Number of column repetitions.
   * @returns {PRDC_JSLAB_MATRIX} The replicated matrix.
   */
  repmat(rowReps, colReps) {
    var cols;
    if(colReps > 1) {
      cols = this.#jsl.array.createFilledArray(colReps, this);
      cols = this.#jsl.mat.concatCol(...cols);
    } else {
      cols = this;
    }
    
    var A;
    if(rowReps > 1) {
      var rows = this.#jsl.array.createFilledArray(rowReps, cols);
      A = this.#jsl.mat.concatRow(...rows);
    } else {
      A = cols;
    }

    return A;
  }

  /**
   * Transposes the matrix.
   * @returns {PRDC_JSLAB_MATRIX} The transposed matrix.
   */
  transpose() {
    return this.#jsl.mat.new(this.#jsl.array.transpose(this.data, this.rows, this.cols), 
      this.cols, this.rows);
  }

  /**
   * Computes the inverse of the matrix.
   * @returns {PRDC_JSLAB_MATRIX} The inverse matrix.
   */
  inv() {
    return this.#jsl.mat.new(this.#jsl.env.math.inv(this.toArray()));
  }
  
  /**
   * Computes the determinant of the matrix.
   * @returns {number} The determinant.
   */
  det() {
    return this.#jsl.env.math.det(this.toArray());
  }

  /**
   * Computes the trace of the matrix (sum of diagonal elements).
   * @returns {number} The trace of the matrix.
   */
  trace() {
    return this.#jsl.env.math.trace(this.toArray());
  }

  /**
   * Computes the Frobenius norm of the matrix.
   * @returns {number} The Frobenius norm.
   */
  norm(p = 2) {
    return this.#jsl.env.math.norm(this.toArray(), p);
  }

  /**
   * Raises the matrix to a power.
   * @param {number} p - The exponent.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  powm(p) {
    return this.#jsl.mat.new(this.#jsl.env.math.pow(this.toArray(), p));
  }

  /**
   * Computes the matrix exponential.
   * @returns {PRDC_JSLAB_MATRIX} The exponential matrix.
   */
  expm() {
    return this.#jsl.mat.new(this.#jsl.env.math.expm(this.toArray())._data);
  }
  
  /**
   * Adds two matrices.
   * @param {PRDC_JSLAB_MATRIX} A - The matrix to add.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  add(A) {
    return this.#jsl.mat.new(this.#jsl.array.plus(this.data, A.data), 
      this.rows, this.cols);
  }

  /**
   * Adds two matrices (alias for add).
   * @param {PRDC_JSLAB_MATRIX} A - The matrix to add.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  plus(A) {
    return this.add(A);
  }

  /**
   * Subtracts matrix A from the current matrix.
   * @param {PRDC_JSLAB_MATRIX} A - The matrix to subtract.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  subtract(A) {
    return this.#jsl.mat.new(this.#jsl.array.minus(this.data, A.data), 
      this.rows, this.cols);
  }

  /**
   * Subtracts matrix A from the current matrix (alias for subtract).
   * @param {PRDC_JSLAB_MATRIX} A - The matrix to subtract.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  minus(A) {
    return this.subtract(A);
  }

  /**
   * Multiplies two matrices.
   * @param {PRDC_JSLAB_MATRIX} A - The matrix to multiply with.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  multiply(A) {
    return this.#jsl.mat.new(this.#jsl.array.multiply(this.data, A.data, this.rows, this.cols, A.cols), this.rows, A.cols);
  }
  
  /**
   * Solves a linear system.
   * @param {PRDC_JSLAB_MATRIX} B - The right-hand side matrix.
   * @returns {PRDC_JSLAB_MATRIX} The solution matrix.
   */
  linsolve(B) {
    return this.#jsl.mat.new(this.#jsl.array.linsolve(this.data, B.data, this.cols), this.rows, 1);
  }
  
  /**
   * Divides each element by another matrix or scalar.
   * @param {PRDC_JSLAB_MATRIX|number} A - The matrix or scalar to divide by.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  divideEl(A) {
    if(this.#jsl.mat.isMatrix(A)) {
      return this.#jsl.mat.new(this.#jsl.array.divideEl(this.data, A.data), 
        this.rows, this.cols);
    } else {
      return this.#jsl.mat.new(this.#jsl.array.scale(this.data, 1 / A), 
        this.rows, this.cols);
    }
  }

  /**
   * Multiplies each element by another matrix or scalar.
   * @param {PRDC_JSLAB_MATRIX|number} A - The matrix or scalar to multiply by.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  multiplyEl(A) {
    if(this.#jsl.mat.isMatrix(A)) {
      return this.#jsl.mat.new(this.#jsl.array.multiplyEl(this.data, A.data), 
        this.rows, this.cols);
    } else {
      return this.#jsl.mat.new(this.#jsl.array.scale(this.data, A), 
        this.rows, this.cols);
    }
  }

  /**
   * Raises each element to a power.
   * @param {number} p - The exponent.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  powEl(p) {
    return this.#jsl.mat.new(this.#jsl.array.powEl(this.data, p), 
      this.rows, this.cols);
  }

  /**
   * Applies a function to each element of the matrix.
   * @param {function} func - The function to apply.
   * @returns {PRDC_JSLAB_MATRIX} The resulting matrix.
   */
  elementWise(func) {
    return this.#jsl.mat.new(this.#jsl.array.elementWise((a) => func(a), this.data), 
      this.rows, this.cols);
  }
  
  /**
   * Computes the reciprocal of each element in the matrix.
   * @returns {PRDC_JSLAB_MATRIX} The matrix with reciprocals.
   */
  reciprocal() {
    return this.#jsl.mat.new(this.#jsl.array.reciprocal(this.data, this.rows * this.cols), 
      this.rows, this.cols);
  }
  
  /**
   * Computes the sum of all elements in the matrix.
   * @returns {number} The sum of all elements.
   */
  sum() {
    return this.#jsl.env.math.sum(this.toArray());
  }

  /**
   * Sorts the elements of the matrix.
   * @param {string} [order='asc'] - The order of sorting ('asc' or 'desc').
   * @returns {PRDC_JSLAB_MATRIX} The sorted matrix.
   */
  sort() {
    return this.#jsl.env.math.sort(this.data);
  }

  /**
   * Finds the minimum element in the matrix.
   * @returns {number} The minimum value.
   */
  min() {
    return this.#jsl.env.math.min(this.toArray());
  }

  /**
   * Finds the maximum element in the matrix.
   * @returns {number} The maximum value.
   */
  max() {
    return this.#jsl.env.math.max(this.toArray());
  }
  
  /**
   * Creates a clone of the current matrix.
   * @returns {PRDC_JSLAB_MATRIX} A cloned matrix instance.
   */
  clone() {
    return this.#jsl.mat.new(this.data, this.rows, this.cols);
  }

  /**
   * Retrieves elements based on row and column indices.
   * @param {...(number|_)} args - Row and column indices.
   * @returns {Array} The selected elements.
   */
  index(rows_in, cols_in) {
    var rows;
    var cols;
    if(rows_in === _) {
      rows = range(0, this.rows - 1);
    } else {
      rows = rows_in;
    }
    if(cols_in === _) {
      cols = range(0, this.cols - 1);
    } else {
      cols = cols_in;
    }
    if(!Array.isArray(rows)) {
      rows = [rows];
    }
    if(!Array.isArray(cols)) {
      cols = [cols];
    }
    var A = zeros(rows.length * cols.length);
    
    var k = 0;
    for(var j = 0; j < cols.length; j++) {
      for(var i = 0; i < rows.length; i++) {
        A[k++] = rows[i] + cols[j] * this.rows;
      }
    }
    
    return A;
  }
  
  /**
   * Sets a subset of the matrix elements.
   * @param {...*} args - Indices and values to set.
   */
  setSub(...args) {
    var A = args.map(function(a) {
      if(!Array.isArray(a) && a !== _) {
        a = [a];
      }
      return a;
    });
    
    var indices;
    var B;
    if(A.length == 3) {
      indices = this.index(A[0], A[1]);
      B = A[2];
    } else {
      indices = A[0];
      if(indices == _) {
        indices = range(0, this.rows * this.cols - 1);
      }
      B = A[1];
    }
    
    var j = 0;
    for(var i = 0; i < indices.length; i++) {
      if(this.#jsl.mat.isMatrix(B[0])) {
        this.data[indices[i]] = B[0].data[j++];
      } else if(Array.isArray(B) && B.length == indices.length) {
        this.data[indices[i]] = B[j++];
      } else {
        this.data[indices[i]] = B[0];
      }
    }
  }

  /**
   * Gets a subset of the matrix elements.
   * @param {...*} args - Indices to retrieve.
   * @returns {PRDC_JSLAB_MATRIX} The subset matrix.
   */
  getSub(...args) {
    var indices;
    var rows;
    var cols;
    var A = args.map(function(a) {
      if(!Array.isArray(a) && a !== _) {
        a = [a];
      }
      return a;
    });
    
    if(A.length == 1) {
      indices = A[0];
      rows = indices.length;
      cols = 1;
    } else {
      if(A[0] === _) {
        rows = this.rows;
      } else {
        rows = A[0].length;
      }
      if(A[1] === _) {
        cols = this.cols;
      } else {
        cols = A[1].length;
      }
      indices = this.index(A[0], A[1]);
    }
    
    var B = this.#jsl.array.createFilledArray(indices.length, 0);
    var j = 0;
    for(var i = 0; i < indices.length; i++) {
      B[j++] = this.data[indices[i]];
    }
    return this.#jsl.mat.new(B, rows, cols);
  }
  
  /**
   * Converts the matrix to a two-dimensional array.
   * @returns {Array} The matrix data as a two-dimensional array.
   */
  toArray() {
    return this.#jsl.array.reshape(this.data, this.rows, this.cols);
  }
  
  /**
   * Converts the matrix to a one-dimensional array.
   * @returns {Array} The matrix data as a one-dimensional array.
   */
  toFlatArray() {
    return this.data;
  }
  
  /**
   * Returns a string representation of the matrix.
   * @returns {string} The string representation of the matrix.
   */
  toString() {
    var str = 'Matrix([ \n';
    for(var i = 0; i < this.rows; i++) {
      str += '  [';
      for(var j = 0; j < this.cols; j++) {
        str += this.data[j * this.rows + i] + ', ';
      }
      str = str.slice(0, -2);
      str += '],\n';
    }
    str = str.slice(0, -2);
    str += '\n])';    
    return str;
  }
  
  /**
   * Returns a JSON representation of the matrix.
   * @returns {Array} The matrix data as a two-dimensional array.
   */
  toJSON() {
    return this.toArray();
  }
  
  /**
   * Returns a safe JSON representation of the matrix.
   * @returns {Array} The matrix data as a two-dimensional array.
   */
  toSafeJSON() {
    return this.toJSON();
  }
  
  /**
   * Returns a pretty string representation of the matrix.
   * @returns {string} The pretty string representation of the matrix.
   */
  toPrettyString() {
    return this.toString();
  }
}

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={mechanics.js}]
/**
 * @file JSLAB library mechanics submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB mechanics submodule.
 */
class PRDC_JSLAB_LIB_MECHANICS {
  
  /**
   * Constructs a mechanics submodule object with access to JSLAB's device functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }
  
  /**
   * Plots beam diagrams.
   * @param {Array} data Array of objects with x, y, title, xlabel, ylabel
   * @param {Object} [opts_in] Extra plotting options
   * @returns {Promise<{extrems: String[], context: Object}>}
   */
  async plotBeamDiagrams(data, opts_in = {}) {
    var context = await this.jsl.windows.openPlotlyjs();
    context.setTitle('Beam Diagrams');
    var plot_config = {
      responsive: true,
      scrollZoom: true,
      modeBarButtonsToAdd: [{
        name: 'Download plot as a svg',
        icon: context.Plotly.Icons.camera,
        click: function(gd) {
          context.Plotly.downloadImage(gd, {format: 'svg'});
        }
      }]
    };
    
    var opts = {
      n: 50,
      digits: 2,
      font: {
        family: 'Roboto',
        size: 18
      },
      ...opts_in
    };
    var extrems = [];
    
    var n = data.length;
    var traces = [];
    for(var i = 0; i < n; i++) {
      var [y_max, I_max] = maxi(data[i].y);
      extrems.push(`${data[i].title}: ${data[i].ylabel[0]}_max = ${y_max.toFixed(opts.digits)} ${data[i].ylabel[1]}, ${data[i].xlabel[0]} = ${data[i].x[I_max].toFixed(opts.digits)} ${data[i].xlabel[1]}`);
      
      var trace = {
        x: data[i].x,
        y: data[i].y,
        cliponaxis: false,
        mode: 'lines+markers',
        line: { 
          color: "#000", 
          width: 2 
        },
        xaxis: 'x' + (i > 0  ? (i+1) : ''),
        yaxis: 'y' + (i > 0  ? (i+1) : ''),
        showlegend: false
      };
      traces.push(trace);

      var xq = this.jsl.array.linspace(data[i].x[0], end(data[i].x), opts.n);
      var yq = this.jsl.math.interp(data[i].x, data[i].y, xq);
      var stem_trace = {
        x: xq.flatMap(x => [x, x, null]),
        y: yq.flatMap(y => [0, y, null]),
        cliponaxis: false,
        mode: 'lines',
        line: { 
          color: "#000", 
          width: 1 
        },
        xaxis: 'x' + (i > 0  ? (i+1) : ''),
        yaxis: 'y' + (i > 0  ? (i+1) : ''),
        showlegend: false
      };
      traces.push(stem_trace);
    }
    
    var plot_layout = {
      grid: { 
        rows: n, 
        columns: 1, 
        pattern: 'independent',
        ygap: 0.25
      },
      title: {},
      autosize: true,
      plot_bgcolor: "#fff",
      paper_bgcolor: "#fff",
      showlegend: false,
      font: opts.font,
      margin: {
        l: 60,
        r: 15,
        b: 60,
        t: 15,
        pad: 0
      }
    };
    
    for(var i = 0; i < n; i++) {
      plot_layout['xaxis' + (i > 0  ? (i+1) : '')] = {
        showgrid: true,
        zeroline: true,
        showline: true,
        automargin: true,
        mirror: 'ticks',
        ticks: 'inside',
        ticklen: 8,
        tickwidth: 0.5,
        tickcolor: '#000',
        linecolor: '#000',
        linewidth: 0.5,
        layer: "below traces",
        exponentformat: 'power'
      };
      if(i == (n-1)) {
        plot_layout['xaxis' + (i > 0  ? (i+1) : '')].title = {
          text: `${data[i].xlabel[0]} [${data[i].xlabel[1]}]`, 
          standoff: 0
        };
      }
      
      plot_layout['yaxis' + (i > 0 ? (i+1) : '')] = {
        showgrid: true,
        zeroline: true,
        showline: true,
        automargin: true,
        mirror: 'ticks',
        ticks: 'inside',
        ticklen: 8,
        tickwidth: 0.5,
        tickcolor: '#000',
        linecolor: '#000',
        linewidth: 0.5,
        layer: "below traces",
        title: {
          text: `${data[i].ylabel[0]} [${data[i].ylabel[1]}]`,
        },
        exponentformat: 'power'
      };
    }
    context.Plotly.newPlot(context.plot_cont, traces, plot_layout, plot_config);
    return { extrems, context };
  }
}

exports.PRDC_JSLAB_LIB_MECHANICS = PRDC_JSLAB_LIB_MECHANICS;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={networking-tcp.js}]
/**
 * @file JSLAB library networking TCP submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class representing a TCP client for handling network communications.
 */
class PRDC_JSLAB_TCP_CLIENT {
  
  /**
   * Creates an instance of the TCP client.
   * @param {Object} jsl Reference to the main JSLAB object.
   * @param {string} host - The host IP address or hostname to connect to.
   * @param {number} port - The port number to connect to.
   * @param {function} onConnectCallback - A callback to execute upon successful connection.
   */
  constructor(jsl, host, port, onConnectCallback) {
    var obj = this;
    this.jsl = jsl;
    this.host = host;
    this.port = port;
    this.onConnectCallback = onConnectCallback;
    this.onDataCallback;
    this.onErrorCallback;
    
    this.buffer = [];
    this.active = false;
    
    this._data_callback = false;
    
    this.com = this.jsl.env.net.createConnection(port, host);
    this.com.setTimeout(0);
    this.com.on('connect', function() {
      obj._onConnect();
    });
    this.com.on('data', function(data) {
      obj._onData(data);
    });
    this.com.on('error', function(err) {
      obj._onError(err);
    });
    this.com.on('close', function(err) {
      if(err) {
        obj._onError(err);
      }
    });
    this.com.on('end', function() {
      obj.active = false;
    });
    
    this.jsl.addForCleanup(this, function() {
      obj.close();
    });
  }
  
  /**
   * Handles successful connection establishment by setting the client's active status to true.
   */
  _onConnect() {
    this.active = true;
    if(this.jsl.format.isFunction(this.onConnectCallback)) {
      this.onConnectCallback();
    }
  }
  
  /**
   * Handles errors by setting the client's active status to false and possibly logging the error.
   * @param {Error} err - The error object that was thrown.
   */
  _onError(err) {
    this.active = false;
    if(this.jsl.format.isFunction(this.onErrorCallback)) {
      this.onErrorCallback(err);
    }
  }
  
  /**
   * Handles incoming data by appending it to the buffer.
   * @param {Buffer} data - The incoming data buffer.
   */
  _onData(data) {
    if(this._data_callback) {
      this.onDataCallback(data);
    } else {
      this.buffer.push(...data);
    }
  }
  
  /**
   * Sets the callback function to handle incoming data events.
   * @param {Function} callback - The function to be called when data is received.
   */
  setOnData(callback) {
    if(this.jsl.format.isFunction(callback)) {
      this.buffer = [];
      this.onDataCallback = callback;
      this._data_callback = true;
    }
  }
  
  /**
   * Sets the callback function to handle error events.
   * @param {Function} callback - The function to be called when an error occurs.
   */
  setOnError(callback) {
    if(this.jsl.format.isFunction(callback)) {
      this.onErrorCallback = callback;
    }
  }

  /**
   * Enables or disables keep-alive functionality on the underlying socket.
   * @param {boolean} [enable=true] - Whether to enable keep-alive.
   * @param {number} [initialDelay=0] - Delay in milliseconds before the first keep-alive probe is sent.
   */
  setKeepAlive(...args) {
    this.com.setKeepAlive(...args);
  }

  /**
   * Disables the Nagle algorithm, allowing data to be sent immediately.
   * @param {boolean} [noDelay=true] - Whether to disable the Nagle algorithm.
   */
  setNoDelay(...args) {
    this.com.setNoDelay(...args);
  }

  /**
   * Sets the socket timeout for inactivity.
   * @param {number} timeout - Timeout in milliseconds.
   * @param {Function} [callback] - Optional callback triggered on timeout.
   */
  setTimeout(...args) {
    this.com.setTimeout(...args);
  }

  /**
   * Reads a specified number of bytes from the buffer.
   * @param {number} [N=Infinity] - The number of bytes to read. Reads all available bytes if not specified.
   * @returns {Buffer} The data read from the buffer.
   */
  read(N = Infinity) {
    N = Math.min(N, this.buffer.length);
    return this.buffer.splice(0, N);
  }
  
  /**
   * Writes data to the TCP connection if the client is active.
   * @param {Buffer|string} data - The data to send over the TCP connection.
   */
  write(data) {
    if(this.active) {
      this.com.write(data);
    }
  }
  
  /**
   * Returns the number of bytes available in the buffer.
   * @returns {number} The number of available bytes.
   */
  availableBytes() {
    return this.buffer.length;
  }
  
  /**
   * Closes the TCP connection and cleans up resources.
   */
  close() {
    this.active = false;
    if(this.com) {
      this.com.destroy();
    }
  }
}

exports.PRDC_JSLAB_TCP_CLIENT = PRDC_JSLAB_TCP_CLIENT;

/**
 * Class representing a TCP server for handling network communications.
 */
class PRDC_JSLAB_TCP_SERVER {
  
  /**
   * Creates an instance of the TCP server.
   * @param {Object} jsl - Reference to the main JSLAB object.
   * @param {string} host - The host IP address or hostname to connect to.
   * @param {number} port - The port number to connect to.
   * @param {Function} onConnectCallback - Callback executed upon successful connection.
   */
  constructor(jsl, host, port, onConnectCallback) {
    const obj = this;
    this.jsl = jsl;
    this.host = host;
    this.port = port;
    this.sockets = {};
    this.sid = 0;
    
    this.onConnectCallback = onConnectCallback;
    this.onDataCallback = null;
    this.onErrorCallback = null;
    this.onDisconnectCallback = null;
    
    this.buffer = [];
    this.active = false;
    
    this._data_callback = false;
    
    this.server = this.jsl.env.net.createServer(function(socket) {
      obj._onConnect(socket);
      
      socket.on('data', function(data) {
        obj._onData(socket, data);
      });

      socket.on('end', function() {
        obj._onDisconnect(socket);
      });

      socket.on('error', function(err) {
        obj._onError(socket, err);
      });
    });
    
    this.server.listen(this.port, this.host, function() { 
      obj.active = true;
    });

    this.jsl.addForCleanup(this, function() {
      obj.close();
    });
  }
  
  /**
   * Handles new client connections.
   * @param {Object} socket - The connected socket.
   */
  _onConnect(socket) {
    this.sid += 1;
    this.sockets[this.sid] = socket;
    socket.sid = this.sid;

    if(this.jsl.format.isFunction(this.onConnectCallback)) {
      this.onConnectCallback(socket);
    }
  }
  
  /**
   * Handles socket errors.
   * @param {Object} socket - The socket that encountered an error.
   * @param {Error} err - The error object.
   */
  _onError(socket, err) {
    if(this.jsl.format.isFunction(this.onErrorCallback)) {
      this.onErrorCallback(socket, err);
    }
  }
  
  /**
   * Handles incoming data from sockets.
   * @param {Object} socket - The socket that received data.
   * @param {Buffer|string} data - The received data.
   */
  _onData(socket, data) {
    if(this.jsl.format.isFunction(this.onDataCallback)) {
      this.onDataCallback(socket, data);
    }
  }
  
  /**
   * Handles socket disconnections.
   * @param {Object} socket - The socket that disconnected.
   */
  _onDisconnect(socket) {
    if(this.jsl.format.isFunction(this.onDisconnectCallback)) {
      this.onDisconnectCallback(socket);
    }
  }
  
  /**
   * Sets the callback function to handle incoming data events.
   * @param {Function} callback - Function called when data is received.
   */
  setOnData(callback) {
    if(this.jsl.format.isFunction(callback)) {
      this.onDataCallback = callback;
    }
  }
  
  /**
   * Sets the callback function to handle error events.
   * @param {Function} callback - Function called when an error occurs.
   */
  setOnError(callback) {
    if(this.jsl.format.isFunction(callback)) {
      this.onErrorCallback = callback;
    }
  }
  
  /**
   * Sets the callback function to handle disconnection events.
   * @param {Function} callback - Function called when a socket disconnects.
   */
  setOnDisconnect(callback) {
    if(this.jsl.format.isFunction(callback)) {
      this.onDisconnectCallback = callback;
    }
  }
  
  /**
   * Writes data to a specific TCP connection.
   * @param {Object} socket - The socket to write data to.
   * @param {Buffer|string} data - The data to send over the TCP connection.
   */
  write(socket, data) {
    if(this.active && this.sockets[socket.sid]) {
      this.sockets[socket.sid].write(data);
    }
  }
  
  /**
   * Closes the TCP server and all active connections.
   */
  close() {
    this.active = false;
    if(this.server) {
      this.server.close();
    }
    for(const sid in this.sockets) {
      this.sockets[sid].destroy();
    }
    this.sockets = {};
  }
}

exports.PRDC_JSLAB_TCP_SERVER = PRDC_JSLAB_TCP_SERVER;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={networking-udp.js}]
/**
 * @file JSLAB library networking UDP submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class representing a UDP client for handling network communications.
 */
class PRDC_JSLAB_UDP {
  
  /**
   * Creates an instance of the UDP client.
   * @param {Object} jsl Reference to the main JSLAB object.
   * @param {string} host - The host IP address or hostname to connect to.
   * @param {number} port - The port number to connect to.
   */
  constructor(jsl, host, port) {
    var obj = this;
    this.jsl = jsl;
    this.host = host;
    this.port = port;
    
    this.active = false;
    
    this.com = this.jsl.env.udp.createSocket('udp4');
    this.com.connect(port, host, function(err) {
      if(err) {
        obj._onError(err);
      } else {
        obj._onConnect();
      }
    });
  }

  /**
   * Handles successful connection establishment by setting the client's active status to true.
   */
  _onConnect() {
    this.active = true;
  }
  
  /**
   * Handles errors by setting the client's active status to false and possibly logging the error.
   * @param {Error} err - The error object that was thrown.
   */
  _onError() {
    this.active = false;
  }
  
  /**
   * Sends data over the UDP connection if the client is active.
   * @param {Buffer|string} data - The data to send over the UDP connection.
   */
  write(data) {
    if(this.active) {
      this.com.write(data);
    }
  }
  
  /**
   * Closes the UDP connection and cleans up resources.
   */
  close() {
    var obj = this;
    this.active = false;
    this.com.close(function() {
      delete obj.com;
    });
  }
}

exports.PRDC_JSLAB_UDP = PRDC_JSLAB_UDP;

/**
 * Represents a UDP server that listens on a specific port.
 */
class PRDC_JSLAB_UDP_SERVER {
  
  /**
   * Initializes a UDP server that binds to the specified port and listens for incoming messages.
   * @param {Object} jsl Reference to the main JSLAB object.
   * @param {number} port - The port number on which the server will listen for incoming UDP packets.
   */
  constructor(jsl, port) {
    var obj = this;
    this.jsl = jsl;
    this.port = port;
    
    this.buffer = [];
    
    this._data_callback = false;
    
    this.com = this.jsl.env.udp.createSocket('udp4');
    
    this.com.on('message', function(msg) {
      obj._onData(msg);
    });
    
    this.com.bind(port);
    
    this.jsl.addForCleanup(this, function() {
      obj.close();
    });
  }
  
  /**
   * Called when data is received. Buffers the incoming data for later retrieval.
   * @param {Buffer} data - The received data buffer.
   */
  _onData(data) {
    if(this._data_callback) {
      this.onDataCallback(data);
    } else {
      this.buffer.push(...data);
    }
  }
  
  /**
   * Sets the callback function to handle incoming data events.
   * @param {Function} callback - The function to be called when data is received.
   */
  setOnData(callback) {
    if(this.jsl.format.isFunction(callback)) {
      this.buffer = [];
      this.onDataCallback = callback;
      this._data_callback = true;
    }
  }
  
  /**
   * Reads a specified number of bytes from the buffer.
   * @param {number} [N=Infinity] - The maximum number of bytes to read. Reads all available bytes by default.
   * @returns {Array} An array containing the first N bytes of buffered data.
   */
  read(N = Infinity) {
    N = Math.min(N, this.buffer.length);
    return this.buffer.splice(0, N);
  }
  
  /**
   * Returns the number of bytes available in the buffer.
   * @returns {number} The number of bytes currently stored in the buffer.
   */
  availableBytes() {
    return this.buffer.length;
  }
  
  /**
   * Closes the UDP server and releases any resources.
   */
  close() {
    var obj = this;
    this.com.close(function() {
      delete obj.com;
    });
  }
}

exports.PRDC_JSLAB_UDP_SERVER = PRDC_JSLAB_UDP_SERVER;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={networking-videocall.js}]
/**
 * @file JSLAB library networking video call submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
  
/**
 * Class representing a video call.
 */
class PRDC_JSLAB_VIDEOCALL {
  
  /**
   * Creates a new video call instance.
   * @param {string} type - The call type ('server' or 'client').
   * @param {string} video_source_type - The video source type ('webcam' or 'desktop').
   * @param {string} video_id - The video device or source ID.
   * @param {string} mic_id - The microphone device ID.
   * @param {string} tcp_host - The TCP host address.
   * @param {number} tcp_port - The TCP port number.
   * @param {object} opts - Additional configuration options.
   */
  constructor(jsl, type, video_source_type, video_id, mic_id, tcp_host, tcp_port, opts) {
    var obj = this;
    this.jsl = jsl;
    this.type = type;
    this.video_source_type = video_source_type;
    this.video_id = video_id;
    this.mic_id = mic_id;
    this.host = tcp_host;
    this.port = tcp_port;
    this.opts = opts || {};
    this.timeout = this.opts.timeout || 15000;
    
    this.is_initiator = (this.type == 'server');
    this.peer_connection;
    this.local_stream;
    this.remote_stream;
    this.incoming_buffer = '';
    
    this.jsl.addForCleanup(this, function() {
      obj.endCall();
    });
    
    this._init();
  }

  /**
   * Attempt to connect the client socket
   */
  _connectClient() {
    var obj = this;
    this.tcp_client = this.jsl.networking.tcp(this.host, this.port, function() {
      obj._setupClientHandlers();
    });
  }

  /**
   * Start a timeout waiting for signaling messages.
   */
  _startConnectionTimeout() {
    var obj = this;

    clearTimeoutIf(this.connection_timeout);
    this.connection_timeout = setTimeout(function() {
      obj._reconnectClient();
    }, this.timeout);
  }

  /**
   * Attempt to reconnect the client by closing the current connection and starting a new one.
   */
  _reconnectClient() {
    if(this.tcp_client) {
      try {
        this.tcp_client.close();
      } catch { }
    }
    this._connectClient();
  }
  
  /**
   * Initializes the video call by opening a window, setting up the UI, obtaining media, and creating the peer connection.
   */
  async _init() {
    var obj = this;
    
    this.win = await openWindowBlank();
    this.win.setTitle('Video call');
    this.win.document.body.innerHTML += '<video id="video"></video>';
    this.dom = this.win.document.getElementById('video');
    Object.assign(this.dom.style, {
      position: 'absolute',
      top: '50%',
      left: '50%',
      transform: 'translate(-50%, -50%)',
      width: '100%',
      height: '100%',
      objectFit: 'contain',
      background: 'url("../img/no-video.svg") center / 30% no-repeat',
    });
    await this._getLocalMedia();
    this._createPeerConnection();
    
    if(this.is_initiator) {
      this.tcp_server = this.jsl.networking.tcpServer(this.host, this.port, function(socket) {
        obj._setupServerSocketHandlers(socket);
      });
    } else {
      this._connectClient();
    }
  }
  
  /**
   * Sets up handlers for the server-side socket once a client connects.
   * @param {Object} socket - The connected socket.
   */
  _setupServerSocketHandlers(socket) {
    var obj = this;
    this.server_socket = socket;
    this.tcp_server.setOnData(function(socket, data) {
      if(socket.sid == obj.server_socket.sid) {
        obj._processIncomingData(data);
      }
    });
  }

  /**
   * Set up handlers for the client side once connected to server.
   */
  _setupClientHandlers() {
    var obj = this;
    this.tcp_client.setOnData(function(data) {
      obj._processIncomingData(data);
    });

    this._sendSignalingMessage({ type: 'request-offer' });
    this._startConnectionTimeout();
  }

  /**
   * Processes incoming data over TCP.
   * @param {string} data - The incoming data as a string.
   */
  _processIncomingData(data) {
    this.incoming_buffer += data.toString('utf8');
    let lines = this.incoming_buffer.split('\0');
    while(lines.length > 1) {
      let line = lines.shift().trim();
      if(line) {
        try {
          let msg = JSON.parse(line);
          this._handleSignalingMessage(msg);
        } catch { }
      }
    }
    
    this.incoming_buffer = lines[0];
  }

  /**
   * Sends a signaling message as JSON via TCP.
   * @param {Object} msg - The signaling message to send.
   */
  _sendSignalingMessage(msg) {
    const json_str = JSON.stringify(msg) + '\0';
    if(this.is_initiator) {
      if(this.server_socket) {
        this.tcp_server.write(this.server_socket, json_str);
      }
    } else {
      this.tcp_client.write(json_str);
    }
  }

  /**
   * Creates the PeerConnection and sets up handlers.
   */
  _createPeerConnection() {
    var obj = this;
    this.peer_connection = new RTCPeerConnection({});

    if(this.local_stream) {
      this.local_stream.getTracks().forEach(function(track) {
        obj.peer_connection.addTrack(track, obj.local_stream);
      });
    }

    this.peer_connection.ontrack = function(e) {
      obj.dom.srcObject = e.streams[0]; 
      obj.dom.play();
    };
    
    this.peer_connection.onicecandidate = function(e) {
      if(e.candidate) {
        obj._sendSignalingMessage({ type: 'candidate', candidate: e.candidate});
      }
    };
  }

  /**
   * Obtains the local media stream (video/audio) based on the provided options.
   */
  async _getLocalMedia() {
    var video_opts = this.opts.video || {};
    var mic_opts = this.opts.mic || {};
    
    var constraints = {};
    
    if(!this.video_source_type || !this.video_id) {
      constraints.video = false;
    } else if(this.video_source_type === 'webcam') {
      constraints.video = { 
        deviceId: { exact: this.video_id },
        ...video_opts
      };
    } else if(this.video_source_type === 'desktop') {
      constraints.video = {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: this.video_id,
          ...video_opts
        }
      };
    }
   
    if(!this.mic_id) {
      constraints.audio = false;
    } else {
      constraints.audio = {
        deviceId: { exact: this.mic_id },
        ...mic_opts
      };
    }
    
    try {
      if(constraints.audio || constraints.video) {
        this.local_stream = await this.jsl.env.navigator.mediaDevices.getUserMedia(constraints);
      } else {
        this.local_stream = new MediaStream();
      }
    } catch {
      this.jsl.env.error('@videocall: '+language.string(222));
    }
  }

  /**
   * Starts the call by creating and sending an offer if the instance is the initiator.
   */
  async _startCall() {
    if(!this.is_initiator) return;
    const offer = await this.peer_connection.createOffer({offerToReceiveVideo: true, offerToReceiveAudio: true});
    await this.peer_connection.setLocalDescription(offer);
    this._sendSignalingMessage({ type: 'offer', sdp: this.peer_connection.localDescription });
  }

  /**
   * Answers an incoming offer by creating and sending an answer if the instance is not the initiator.
   */
  async _answerCall() {
    const answer = await this.peer_connection.createAnswer();
    await this.peer_connection.setLocalDescription(answer);
    this._sendSignalingMessage({ type: 'answer', sdp: this.peer_connection.localDescription });
  }

  /**
   * Handles incoming signaling messages based on their type.
   * @param {Object} message - The signaling message received.
   */
  async _handleSignalingMessage(message) {
    if(!this.is_initiator) {
      this.connection_timeout = clearTimeoutIf(this.connection_timeout);
    }
    
    switch(message.type) {
      case 'request-offer':
        if(this.is_initiator) {
          await this._startCall();
        }
        break;
      case 'offer':
        if(!this.is_initiator) {
          await this.peer_connection.setRemoteDescription(message.sdp);
          await this._answerCall();
        }
        break;
      case 'answer':
        if(this.is_initiator) {
          await this.peer_connection.setRemoteDescription(message.sdp);
        }
        break;
      case 'candidate':
        this.peer_connection.addIceCandidate(message.candidate);
        break;
      case 'message':
        if(typeof this._onMessage == 'function') {
          this._onMessage(message.data);
        } else {
          disp(message.data);
        }
        break;
    }
  }
  
  /**
   * Sets a callback function to handle incoming messages.
   * @param {Function} callback - The function to call when a message is received.
   */
  setOnMessage(callback) {
    if(typeof callback == 'function') {
      this._onMessage = callback;
    }
  }
  
  /**
   * Sends a message to the connected peer.
   * @param {any} data - The data to send.
   */
  sendMessage(data) {
    this._sendSignalingMessage({ type: 'message', data: data });
  }
  
  /**
   * Toggles the local audio track on or off.
   * @param {boolean} mute - If true, mutes the audio; otherwise, unmutes.
   */
  toggleAudio(mute) {
    if(this.local_stream) {
      this.local_stream.getAudioTracks().forEach((track) => track.enabled = !mute);
    }
  }

  /**
   * Toggles the local video track on or off.
   * @param {boolean} disable - If true, disables the video; otherwise, enables it.
   */
  toggleVideo(disable) {
    if(this.local_stream) {
      this.local_stream.getVideoTracks().forEach((track) => track.enabled = !disable);
    }
  }

  /**
   * Ends the call by closing peer connections and media streams.
   */
  endCall() {
    if(!this.is_initiator) {
      this.connection_timeout = clearTimeoutIf(this.connection_timeout);
    }
    
    if(this.peer_connection) {
      this.peer_connection.close();
    }
    if(this.local_stream) {
      this.local_stream.getTracks().forEach((track) => track.stop());
    }
    if(this.remote_stream) {
      this.remote_stream.getTracks().forEach((track) => track.stop());
    }

    if(this.tcp_server) {
      this.tcp_server.close();
    }
    if(this.tcp_client) {
      this.tcp_client.close();
    }
  }
}

exports.PRDC_JSLAB_VIDEOCALL = PRDC_JSLAB_VIDEOCALL;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={networking.js}]
/**
 * @file JSLAB library networking submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

var { PRDC_JSLAB_TCP_CLIENT, PRDC_JSLAB_TCP_SERVER } = require('./networking-tcp');
var { PRDC_JSLAB_UDP, PRDC_JSLAB_UDP_SERVER } = require('./networking-udp');
var { PRDC_JSLAB_VIDEOCALL } = require('./networking-videocall');

/**
 * Class for JSLAB networking submodule.
 */
class PRDC_JSLAB_LIB_NETWORKING {
  
  /**
   * Create submodule object.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;

    /**
     * XMODEM CRC table
     * @type {Array}
     */
    this.CRC_TABLE_XMODEM = [
      0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 
      0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 
      0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
      0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
      0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
      0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
      0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
      0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
      0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
      0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
      0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
      0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
      0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
      0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
      0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
      0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
      0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
      0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
      0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
      0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
      0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
      0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
      0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
      0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
      0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
      0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
      0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
      0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
      0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
      0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
      0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
      0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
    ];
  }
  
  /**
   * Checks if the environment is currently online.
   * @returns {boolean} `true` if online, otherwise `false`.
   */
  isOnline() {
    return this.jsl.env.online;
  }
  
  /**
   * Calculates the CRC-16/XMODEM checksum of a byte array.
   * @param {Uint8Array} byte_array - The input data as a byte array.
   * @returns {number} The CRC-16/XMODEM checksum as a numeric value.
   */
  crc16xmodem(byte_array) {
    let crc = 0x0000;
    for(let i = 0; i < byte_array.length; i++) {
      crc = (crc << 8) ^ this.CRC_TABLE_XMODEM[((crc >> 8) ^ byte_array[i]) & 0xFF];
    }
    return crc & 0xFFFF;
  }

  /**
   * Retrieves the primary IPv4 address of the current machine.
   * @returns {string} The IP address if found, otherwise an empty string.
   */
  getIP() {
    return Object.values(this.jsl.env.os.networkInterfaces())
      .reduce(function(r, list) { return r.concat(
      list.reduce(function(rr, i) { return rr.concat(
      i.family === 'IPv4' && !i.internal && i.address || []); }, []));}, [])[0];    
  }

  /**
   * Attempts to establish a TCP connection to the specified host and port to check reachability.
   * @param {string} host - The IP address or hostname to ping.
   * @param {number} port - The port number to use for the connection.
   * @param {number} [timeout=1000] - The timeout in milliseconds before the attempt is considered failed.
   * @returns {Promise<boolean>} A promise that resolves to `true` if the connection is successful, `false` otherwise.
   */
  async pingAddressTCP(host, port, timeout = 1000) {
    var obj = this;
    return new Promise(function(resolve) {
      const socket = obj.jsl.env.net.createConnection(port, host);
      socket.setTimeout(timeout);
      socket.on('connect', function() {
         socket.end();
         resolve(true);
      });
      socket.on('timeout', function() {
         socket.destroy();
         resolve(false);
      });
      socket.on('error', function() {
         socket.destroy();
         resolve(false);
      });
    });
  }

  /**
   * Executes a ping command to check if an IP address is reachable.
   * @param {string} host - The IP address or hostname to ping.
   * @param {number} timeout - The timeout in milliseconds for the ping command.
   */
  async pingAddress(host, timeout) {
    return new Promise((resolve) => {
      exec('ping -n 1 -w '+timeout+' '+host, function(error, stdout, stderr) {
        if(error || stderr) {
          resolve(false);
        } else {
          resolve(stdout.includes('Reply from'));
        }
      });
    });
  }

  /**
   * Executes a ping command synchronized to check if an IP address is reachable.
   * @param {string} host - The IP address or hostname to ping.
   * @param {number} timeout - The timeout in milliseconds for the ping command.
   */
  pingAddressSync(host, timeout) {
    try {
      var stdout = execSync('ping -n 1 -w '+timeout+' '+host);
      return stdout.includes('Reply from');
    } catch {
      return false;
    }
  }

  /**
   * Finds the first unused port within a specified range, checking sequentially from `port` to `max_port`.
   * @param {number} port - The starting port number to check.
   * @param {number} min_port - The minimum port number in the range.
   * @param {number} max_port - The maximum port number in the range.
   */
  async findFirstUnusedPort(port, min_port, max_port) {
    let currentPort = port;

    while(true) {
      const inUse = await this.jsl.env.tcpPortUsed.check(port);
      if(!inUse) {
        return currentPort;
      }

      currentPort++;
      if(currentPort > max_port) {
        currentPort = min_port;
      }
    }
  }

  /**
   * Converts an IPv4 address to its decimal equivalent.
   * @param {string} ip - The IPv4 address in dot-decimal notation.
   * @param {number} [subnets=4] - The number of subnets in the IP address, default is 4.
   * @returns {number} The decimal equivalent of the IPv4 address.
   */
  ip2dec(ip, subnets = 4) {
    const octets = ip.split('.').map(Number).reverse();
    let value = 0;
    for(let i = 0; i < subnets; i++) {
      value += octets[i]*Math.pow(256,i);
    }
    return value;
  }
  
  /**
   * Creates a TCP client for communication with a specified host and port.
   * @param {string} host - The hostname or IP address to connect to.
   * @param {number} port - The port number on the host to connect to.
   * @param {function} onConnectCallback - A callback function that is called when the connection is successfully established.
   * @returns {PRDC_JSLAB_TCP_CLIENT} An instance of the TCP client with event handlers set up.
   */
  tcp(host, port, onConnectCallback) {
    return new PRDC_JSLAB_TCP_CLIENT(this.jsl, host, port, onConnectCallback);
  }
   
  /**
   * Creates a TCP server to listen on a specified port.
   * @param {string} host - The hostname or IP address.
   * @param {number} port - The port number.
   * @param {function} onConnectCallback - A callback function that is called when the connection is successfully established.
   * @returns {PRDC_JSLAB_TCP_SERVER} An instance of the TCP server.
   */
  tcpServer(...args) {
    return new PRDC_JSLAB_TCP_SERVER(this.jsl, ...args);
  }
  
  /**
   * Creates a UDP client for sending data to a specified host and port.
   * @param {string} host - The hostname or IP address to connect to.
   * @param {number} port - The port number to connect to.
   * @returns {PRDC_JSLAB_UDP} An instance of the UDP client.
   */
  udp(host, port) {
    return new PRDC_JSLAB_UDP(this.jsl, host, port);
  }
   
  /**
   * Creates a UDP server to listen on a specified port.
   * @param {number} port - The port number to listen on.
   * @returns {PRDC_JSLAB_UDP_SERVER} An instance of the UDP server.
   */
  udpServer(port) {
    return new PRDC_JSLAB_UDP_SERVER(this.jsl, port);
  }
   
  /**
   * Initializes and returns a new video call instance.
   * @param {string} type - The call type ('server' or 'client').
   * @param {string} video_source_type - The video source type ('webcam' or 'desktop').
   * @param {string} video_id - The video device or source ID.
   * @param {string} mic_id - The microphone device ID.
   * @param {string} tcp_host - The TCP host address.
   * @param {number} tcp_port - The TCP port number.
   * @param {object} opts - Additional configuration options.
   * @returns {PRDC_JSLAB_VIDEOCALL} The created video call object.
   */
  videoCall(type, video_source_type, video_id, mic_id, tcp_host, tcp_port, opts) {
    return new PRDC_JSLAB_VIDEOCALL(this.jsl, type, video_source_type, 
      video_id, mic_id, tcp_host, tcp_port, opts);
  }
}

exports.PRDC_JSLAB_LIB_NETWORKING = PRDC_JSLAB_LIB_NETWORKING;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={non-blocking.js}]
/**
 * @file JSLAB library non blocking functions submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB non blocking functions submodule.
 */
class PRDC_JSLAB_LIB_NON_BLOCKING {
  
  /**
   * Initializes a new instance of the non-blocking functions submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }

  /**
   * Executes a given function in a non-blocking while loop.
   * @param {Function} fn A function that returns a boolean value; when false, the loop exits.
   */
  nbwhile(fn) {
    var obj = this;
    function fnw() {
      if(!obj.jsl.basic.checkStopLoop()) {
        if(!fn()) {
          obj.jsl.env.setImmediate(fnw);
        }
      } else {
        obj.jsl.env.error('@nbwhile: '+language.string(125));
      }
    }
    this.jsl.env.setImmediate(fnw);
  }

  /**
   * Executes a given function once in a non-blocking manner.
   * @param {Function} fn The function to be executed.
   */
  nbrun(fn) {
    if(!this.jsl.basic.checkStopLoop()) {
      this.jsl.env.setImmediate(fn);
    } else {
      this.jsl.env.error('@nbrun: '+language.string(125));
    }
  }

  /**
   * Schedules the next block of code to be executed in a non-blocking manner.
   * @param {Function} fn The function to execute next.
   */
  nbnext(fn) {
    var obj = this;
    function fnw() {
      if(!obj.jsl.basic.checkStopLoop()) {
        fn();
      } else {
        obj.jsl.env.error('@nbnext: '+language.string(125));
      }
    }
    this.jsl.env.setImmediate(fnw);
  }

  /**
   * Waits for a specified number of milliseconds in a non-blocking manner.
   * @param {Number} ms The number of milliseconds to wait.
   * @returns {Promise<void>} A promise that resolves after the specified time has elapsed.
   */
  waitMSeconds(ms) {
    if(!this.jsl.basic.checkStopLoop()) {
      return new Promise(function(resolve, reject) { setTimeout(resolve, ms) });
    } else {
      this.jsl.env.error('@waitMSeconds: '+language.string(125), true);
    }
    return false;
  }
  
  /**
   * Waits for a specified number of seconds in a non-blocking manner.
   * @param {Number} s The number of seconds to wait.
   * @returns {Promise<void>} A promise that resolves after the specified time has elapsed.
   */
  waitSeconds(s) {
    if(!this.jsl.basic.checkStopLoop()) {
      return waitMSeconds(s*1000); 
    } else {
      this.jsl.env.error('@waitSeconds: '+language.string(125), true);
    }
    return false;
  }

  /**
   * Waits for a specified number of minutes in a non-blocking manner.
   * @param {Number} min The number of minutes to wait.
   * @returns {Promise<void>} A promise that resolves after the specified time has elapsed.
   */
  waitMinutes(min) {
    if(!this.jsl.basic.checkStopLoop()) {
      return waitMSeconds(min*60*1000);
    } else {
      this.jsl.env.error('@waitMinutes: '+language.string(125), true);
    }
    return false;
  }

  /**
   * Clears the specified interval if it exists.
   * @param {number|undefined} timeout - The interval ID to be cleared.
   * @returns {boolean} Always returns false.
   */
  clearIntervalIf(timeout) {
    if(timeout) {
      clearInterval(timeout);
    }
    return false;
  }
  
  /**
   * Clears the specified timeout if it exists.
   * @param {number|undefined} timeout - The timeout ID to be cleared.
   * @returns {boolean} Always returns false.
   */
  clearTimeoutIf(timeout) {
    if(timeout) {
      clearTimeout(timeout);
    }
    return false;
  }
  
  /**
   * Initializes a new worker with the specified module path.
   * @param {string} path - The path to the module to configure the worker.
   * @returns {Worker} The initialized Worker instance.
   */
  initWorker(path) {
    var worker = new Worker(app_path + "/js/sandbox/init-worker.js");
    worker.postMessage({
      type: 'configureWorker', 
      module_path: path
    });
    return worker;
  }
}

exports.PRDC_JSLAB_LIB_NON_BLOCKING = PRDC_JSLAB_LIB_NON_BLOCKING;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={om-link.js}]
/**
 * @file JSLAB OpenModelicaLink submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

const zmq = require('zeromq');
const fs = require('fs');
const path = require('path');
const os = require('os');
const { exec, execSync } = require('child_process');
const { XMLParser } = require('fast-xml-parser');

/**
 * Class for JSLAB OpenModelicaLink.
 */
class PRDC_JSLAB_OPENMODELICA_LINK {
  
  /**
   * Initializes a new instance of the OpenModelicaLink.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    this.jsl = jsl;
  }
    
  /**
   * Starts the interaction with an external executable by initializing the necessary environment and parameters.
   * Launches the executable with the appropriate command-line arguments for interaction via ZMQ.
   * Waits for a port file to be created to establish the ZMQ communication.
   * @param {string} exe - Path to the executable to be run, defaults to the OpenModelica compiler if not provided.
   */
  async start(exe) {
    var obj = this;
    this.exe = exe;
    
    this.pid = 0;
    this.active = false;
    this.requester = null;
    this.portfile = '';
    
    this.filename = '';
    this.modelname = '';
    this.xmlfile = '';
    this.resultfile = '';
    this.csvfile = '';
    this.mat_temp_dir = '';
    this.simulation_options = {};
    this.quantities_list = [];
    this.parameter_list = {};
    this.continuous_list = {};
    this.input_list = {};
    this.output_list = {};
    this.mapped_names = {};
    this.override_variables = {};
    this.sim_opt_override = {};
    this.input_flag = false;
    this.linear_options = {
      startTime: '0.0',
      stopTime: '1.0',
      numberOfIntervals: '500',
      stepSize: '0.002',
      tolerance: '1e-6'
    };
    this.linearfile = '';
    this.linear_flag = false;
    this.linear_modelname = '';
    this.linear_inputs = '';
    this.linear_outputs = '';
    this.linear_states = '';
    this.linear_quantity_list = [];

    const random_string = Math.random().toString(36).substring(7);
    let cmd, portfile;

    if(process.platform === 'win32') {
      exe = exe || path.join(process.env.OPENMODELICAHOME, 'bin', 'omc.exe');
      cmd = `START /b "" "${exe}" --interactive=zmq +z=jslab.${random_string}`;
      portfile = path.join(os.tmpdir(), `openmodelica.port.jslab.${random_string}`);
    } else {
      exe = exe || 'omc';
      cmd = `${exe} --interactive=zmq -z=jslab.${random_string} &`;
      portfile = path.join(os.tmpdir(), `openmodelica.${process.env.USER}.port.jslab.${random_string}`);
    }

    this.portfile = portfile;
    
    var [flag1, pids1] = isProgramRunning('omc.exe');
    var omc_process = exec(cmd);
    await waitMSeconds(200);
    var [flag2, pids2] = isProgramRunning('omc.exe');
    this.pid = pids2.filter(function(e) {
      return !pids1.includes(e)
    });
    
    while(true) {
      await waitMSeconds(10);
      if(fs.existsSync(this.portfile)) {
        const filedata = fs.readFileSync(this.portfile, 'utf-8');
        this.requester = new zmq.Request();
        this.requester.connect(filedata);
        this.active = true;
        break;
      }
    }
  }
  
  /**
   * Sends an expression to be evaluated by the external executable through the ZMQ connection and waits for the result.
   * Parses the response using a dedicated expression parser.
   * @param {string} expr - The expression to be evaluated.
   * @returns {Promise<any>} - A promise that resolves with the parsed result of the expression evaluation.
   * @throws {Error} - Throws an error if there is no active connection.
   */
  async sendExpression(expr) {
    if(this.active) {
      await this.requester.send(expr);
      const [result] = await this.requester.receive();
      return this.parseExpression(result.toString());
    } else {
      this.jsl.env.error("@sendExpression: "+language.string(201));
      return false;
    }
  }
  
  /**
   * Initializes and configures a Modelica system with the specified parameters and libraries.
   * Loads necessary files and prepares the environment for simulation.
   * @param {string} filename - The path to the Modelica file.
   * @param {string} modelname - The name of the Modelica model.
   * @param {string[]} [libraries=[]] - An array of library paths to load.
   * @param {string} [command_line_options=''] - Additional command-line options for the simulation.
   */
  async ModelicaSystem(filename, modelname, libraries = [], command_line_options = '') {
    if(!filename || !modelname) {
      this.jsl.env.error('@ModelicaSystem: '+language.string(203));
      return false;
    }

    if(command_line_options) {
      const cmd_exp = await this.sendExpression(`setcommand_line_options("${command_line_options}")`);
      if(cmd_exp === 'false') {
        this.jsl.env.error('@ModelicaSystem: '+ await this.sendExpression("getErrorString()"));
        return false;
      }
    }

    const filepath = path.normalize(filename).replace(/\\/g, '/');
    const load_file_msg = await this.sendExpression(`loadFile("${filepath}")`);
    if(load_file_msg === 'false') {
      this.jsl.env.error('@ModelicaSystem: '+ await this.sendExpression("getErrorString()"));
      return false;
    }

    for(const lib of libraries) {
      let libmsg;
      if(fs.existsSync(lib)) {
        libmsg = await this.sendExpression(`loadFile("${lib}")`);
      } else {
        libmsg = await this.sendExpression(`loadModel(${lib})`);
      }
      if(libmsg === 'false') {
        this.jsl.env.error('@ModelicaSystem: '+ await this.sendExpression("getErrorString()"));
        return false;
      }
    }

    this.filename = filename;
    this.modelname = modelname;
    this.mat_temp_dir = fs.mkdtempSync(path.join(os.tmpdir(), 'OpenModelicaLink-'));
    await this.sendExpression('cd("' + this.mat_temp_dir + '")');
    await this.BuildModelicaModel();
    return true;
  }
  
  /**
   * Builds the Modelica model by sending the appropriate build command and parsing the resulting XML file.
   */
  async BuildModelicaModel() {
    const build_model_result = await this.sendExpression(`buildModel(${this.modelname})`);
    if(!build_model_result) {
      this.jsl.env.error('@BuildModelicaModel: '+ await this.sendExpression("getErrorString()"));
      return false;
    }

    this.xmlfile = path.join(this.mat_temp_dir, build_model_result[1]);
    this.xmlparse();
    return true;
  }
  
  /**
   * Retrieves the working directory used for temporary files and simulations.
   * @returns {string} - The path to the working directory.
   */
  getWorkDirectory() {
    return this.mat_temp_dir;
  }

  /**
   * Parses the XML file generated by the Modelica compiler to extract simulation parameters and variables.
   */
  xmlparse() {
    if(fs.existsSync(this.xmlfile)) {
      const xml_data = fs.readFileSync(this.xmlfile, 'utf-8');
      const parser = new XMLParser({ ignoreAttributes: false, attributeNamePrefix: '' });
      const xDoc = parser.parse(xml_data);

      // default_experiment
      const default_experiment = xDoc.fmiModelDescription.DefaultExperiment;
      if(default_experiment) {
        this.simulation_options.startTime = default_experiment.startTime || '0.0';
        this.simulation_options.stopTime = default_experiment.stopTime || '1.0';
        this.simulation_options.stepSize = default_experiment.stepSize || '0.002';
        this.simulation_options.tolerance = default_experiment.tolerance || '1e-6';
        this.simulation_options.solver = default_experiment.solver || '';
      }

      // scalar_variables
      const scalar_variables = xDoc.fmiModelDescription.ModelVariables.ScalarVariable || [];
      const fields = ['name', 'isValueChangeable', 'description', 'variability', 'causality', 'alias', 'aliasVariable'];
      for(let k = 0; k < scalar_variables.length; k++) {
        const item = scalar_variables[k];
        let scalar = {};
        fields.forEach(field => {
          scalar[field] = item[field] || '';
        });

        if(item.Real) {
          scalar.value = item.Real.start || '';
        }

        this.processVariable(scalar);
      }
    } else {
      this.jsl.env.error('@xmlparse: '+language.string(204));
      return false;
    }
    return true;
  }
  
  /**
   * Processes a scalar variable from the XML file and categorizes it based on its properties.
   * @param {Object} scalar - The scalar variable to process.
   */
  processVariable(scalar) {
    const name = scalar.name;
    const value = scalar.value;

    if(!this.linear_flag) {
      if(scalar.variability === 'parameter') {
        this.parameter_list[name] = value;
      } else if(scalar.variability === 'continuous') {
        this.continuous_list[name] = value;
      } else if(scalar.causality === 'input') {
        this.input_list[name] = value;
      } else if(scalar.causality === 'output') {
        this.output_list[name] = value;
      }
    }

    if(this.linear_flag) {
      if(scalar.alias === 'alias') {
        if(name.startsWith('x')) {
          this.linear_states.push(name.slice(3, -1));
        } else if(name.startsWith('u')) {
          this.linear_inputs.push(name.slice(3, -1));
        } else if(name.startsWith('y')) {
          this.linear_outputs.push(name.slice(3, -1));
        }
      }
      this.linear_quantity_list.push(scalar);
    } else {
      this.quantities_list.push(scalar);
    }
  }
  
  /**
   * Retrieves a list of quantities based on the provided arguments.
   * @param {string[]} [args] - An array of quantity names to retrieve. If omitted, returns all quantities.
   * @returns {Object[]} - An array of quantity objects.
   */
  getQuantities(args) {
    if(args && args.length > 0) {
      const tmpresult = [];
      for(let n = 0; n < args.length; n++) {
        for(let q = 0; q < this.quantities_list.length; q++) {
          if(this.quantities_list[q].name === args[n]) {
            tmpresult.push(this.quantities_list[q]);
          }
        }
      }
      return tmpresult;
    } else {
      return this.quantities_list;
    }
  }
  
  /**
   * Retrieves a list of linearized quantities based on the provided arguments.
   * @param {string[]} [args] - An array of linear quantity names to retrieve. If omitted, returns all linear quantities.
   * @returns {Object[]} - An array of linear quantity objects.
   */
  getLinearQuantities(args) {
    if(args && args.length > 0) {
      const tmpresult = [];
      for(let n = 0; n < args.length; n++) {
        for(let q = 0; q < this.linear_quantity_list.length; q++) {
          if(this.linear_quantity_list[q].name === args[n]) {
            tmpresult.push(this.linear_quantity_list[q]);
          }
        }
      }
      return tmpresult;
    } else {
      return this.linear_quantity_list;
    }
  }
  
  /**
   * Retrieves simulation parameters based on the provided arguments.
   * @param {string|string[]} [args] - A single parameter name or an array of parameter names to retrieve. If omitted, returns all parameters.
   * @returns {Object|any} - An object containing the requested parameters or a single parameter value.
   */
  getParameters(args) {
    if(args && args.length > 0) {
      if(Array.isArray(args)) {
        const param = {};
        for(let n = 0; n < args.length; n++) {
          param[args[n]] = this.parameter_list[args[n]];
        }
        return param;
      } else {
        return this.parameter_list[args];
      }
    } else {
      return this.parameter_list;
    }
  }
  
  /**
   * Retrieves input variables based on the provided arguments.
   * @param {string|string[]} [args] - A single input name or an array of input names to retrieve. If omitted, returns all inputs.
   * @returns {Object|any} - An object containing the requested inputs or a single input value.
   */
  getInputs(args) {
    if(args && args.length > 0) {
      if(Array.isArray(args)) {
        const inputs = {};
        for(let n = 0; n < args.length; n++) {
          inputs[args[n]] = this.input_list[args[n]];
        }
        return inputs;
      } else {
        return this.input_list[args];
      }
    } else {
      return this.input_list;
    }
  }
  
  /**
   * Retrieves output variables based on the provided arguments.
   * @param {string|string[]} [args] - A single output name or an array of output names to retrieve. If omitted, returns all outputs.
   * @returns {Object|any} - An object containing the requested outputs or a single output value.
   */
  getOutputs(args) {
    if(args && args.length > 0) {
      if(Array.isArray(args)) {
        const outputs = {};
        for(let n = 0; n < args.length; n++) {
          outputs[args[n]] = this.output_list[args[n]];
        }
        return outputs;
      } else {
        return this.output_list[args];
      }
    } else {
      return this.output_list;
    }
  }
  
  /**
   * Retrieves continuous variables based on the provided arguments.
   * @param {string|string[]} [args] - A single continuous variable name or an array of names to retrieve. If omitted, returns all continuous variables.
   * @returns {Object|any} - An object containing the requested continuous variables or a single value.
   */
  getContinuous(args) {
    if(args && args.length > 0) {
      if(Array.isArray(args)) {
        const continuous = {};
        for(let n = 0; n < args.length; n++) {
          continuous[args[n]] = this.continuous_list[args[n]];
        }
        return continuous;
      } else {
        return this.continuous_list[args];
      }
    } else {
      return this.continuous_list;
    }
  }
  
  /**
   * Retrieves simulation options based on the provided arguments.
   * @param {string|string[]} [args] - A single simulation option name or an array of names to retrieve. If omitted, returns all simulation options.
   * @returns {Object|any} - An object containing the requested simulation options or a single option value.
   */
  getSimulationOptions(args) {
    if(args && args.length > 0) {
      if(Array.isArray(args)) {
        const simoptions = {};
        for(let n = 0; n < args.length; n++) {
          simoptions[args[n]] = this.simulation_options[args[n]];
        }
        return simoptions;
      } else {
        return this.simulation_options[args];
      }
    } else {
      return this.simulation_options;
    }
  }
  
  /**
   * Retrieves linearization options based on the provided arguments.
   * @param {string|string[]} [args] - A single linearization option name or an array of names to retrieve. If omitted, returns all linearization options.
   * @returns {Object|any} - An object containing the requested linearization options or a single option value.
   */
  getLinearizationOptions(args) {
    if(args && args.length > 0) {
      if(Array.isArray(args)) {
        const linoptions = {};
        for(let n = 0; n < args.length; n++) {
          linoptions[args[n]] = this.linear_options[args[n]];
        }
        return linoptions;
      } else {
        return this.linear_options[args];
      }
    } else {
      return this.linear_options;
    }
  }
  
  /**
   * Sets simulation parameters based on the provided arguments.
   * @param {string|string[]} args - A single parameter assignment (e.g., "param=5") or an array of assignments.
   */
  setParameters(args) {
    if(args && args.length > 0) {
      if(!Array.isArray(args)) {
        args = [args];
      }
      args.forEach(arg => {
        const val = arg.replace(/\s+/g, "");
        const [key, value] = val.split("=");
        if(key in this.parameter_list) {
          this.parameter_list[key] = value;
          this.override_variables[key] = value;
        } else {
          this.jsl.env.error('@setParameters: ' + key + language.string(209));
        }
      });
    }
  }
  
  /**
   * Sets simulation options based on the provided arguments.
   * @param {string|string[]} args - A single simulation option assignment (e.g., "stepSize=0.01") or an array of assignments.
   */
  setSimulationOptions(args) {
    if(args && args.length > 0) {
      if(!Array.isArray(args)) {
        args = [args];
      }
      args.forEach(arg => {
        const val = arg.replace(/\s+/g, "");
        const [key, value] = val.split("=");
        if(key in this.simulation_options) {
          this.simulation_options[key] = value;
          this.sim_opt_override[key] = value;
        } else {
          this.jsl.env.error('@setSimulationOptions: ' + key + language.string(210));
        }
      });
    }
  }
  
  /**
   * Sets linearization options based on the provided arguments.
   * @param {string|string[]} args - A single linearization option assignment or an array of assignments.
   */
  setLinearizationOptions(args) {
    if(args && args.length > 0) {
      if(!Array.isArray(args)) {
        args = [args];
      }
      args.forEach(arg => {
        const val = arg.replace(/\s+/g, "");
        const [key, value] = val.split("=");
        if(key in this.linear_options) {
          this.linear_options[key] = value;
        } else {
          this.jsl.env.error('@setLinearizationOptions: ' + key + language.string(211));
        }
      });
    }
  }
  
  /**
   * Sets input variables based on the provided arguments.
   * @param {string|string[]} args - A single input assignment (e.g., "input1=10") or an array of assignments.
   */
  setInputs(args) {
    if(args && args.length > 0) {
      if(!Array.isArray(args)) {
        args = [args];
      }
      args.forEach(arg => {
        const val = arg.replace(/\s+/g, "");
        const [key, value] = val.split("=");
        if(key in this.input_list) {
          this.input_list[key] = value;
          this.input_flag = true;
        } else {
          this.jsl.env.error('@setInputs: ' + key + language.string(212));
        }
      });
    }
  }
  
  /**
   * Creates a CSV file containing input data for the simulation.
   */
  createcsvData() {
    this.csvfile = path.join(this.mat_temp_dir, `${this.modelname}.csv`);
    const file_id = fs.openSync(this.csvfile, 'w');
    const fields = Object.keys(this.input_list);
    let header = `time,${fields.join(",")},end\n`;
    fs.writeSync(file_id, header);

    let time = [];
    let tmpcsvdata = {};

    fields.forEach(field => {
      let var_data = this.input_list[field] || "0";
      try {
        var_data = eval(var_data.replace(/\[|\]|\(|\)/g, match => {
          return match === '[' || match === ']' ? '{' : '{';
        }));
      } catch {
        var_data = [[0, 0]]; // Default to 0 if evaluation fails
      }
      tmpcsvdata[field] = var_data;

      if(var_data.length > 1) {
        var_data.forEach(entry => {
          time.push(entry[0]);
        });
      }
    });

    if(time.length === 0) {
      time = [parseFloat(this.simulation_options.startTime), parseFloat(this.simulation_options.stopTime)];
    }

    const sorted_time = time.sort((a, b) => a - b);
    let previous_value = {};

    sorted_time.forEach(t => {
      let line = `${t},`;
      fields.forEach((field) => {
        let data = tmpcsvdata[field];
        let value = previous_value[field] || 0;

        if(Array.isArray(data)) {
          for(let j = 0; j < data.length; j++) {
            if(data[j][0] === t) {
              value = data[j][1];
              data.splice(j, 1);
              tmpcsvdata[field] = data;
              break;
            }
          }
          previous_value[field] = value;
        }
        line += `${value},`;
      });
      line += "0\n";
      fs.writeSync(file_id, line);
    });

    fs.closeSync(file_id);
  }
  
  /**
   * Runs the simulation with optional result file and simulation flags.
   * @param {string} [resultfile=''] - The name of the result file to generate.
   * @param {string} [sim_flags=''] - Additional simulation flags.
   */
  async simulate(resultfile = '', sim_flags = '') {
    let r = resultfile ? ` -r=${resultfile}` : '';
    this.resultfile = resultfile ? path.join(this.mat_temp_dir, resultfile) : path.join(this.mat_temp_dir, `${this.modelname}_res.mat`);

    if(fs.existsSync(this.xmlfile)) {
      let getexefile;
      if(process.platform === 'win32') {
        getexefile = path.join(this.mat_temp_dir, `${this.modelname}.exe`);
      } else {
        getexefile = path.join(this.mat_temp_dir, this.modelname);
      }

      if(fs.existsSync(getexefile)) {
        let overridevar = '';
        if(Object.keys(this.override_variables).length || Object.keys(this.sim_opt_override).length) {
          const allOverrides = { ...this.override_variables, ...this.sim_opt_override };
          const fields = Object.keys(allOverrides);
          const tmpoverride1 = fields.map(field => `${field}=${allOverrides[field]}`);
          overridevar = ` -override=${tmpoverride1.join(',')}`;
        }

        let csvinput = '';
        if(this.input_flag) {
          this.createcsvData();
          csvinput = ` -csvInput=${this.csvfile}`;
        }

        const final_simulation_exe = `"${getexefile}"${overridevar}${csvinput}${r}${sim_flags}`;
        execSync(final_simulation_exe, { cwd: this.mat_temp_dir });
      } else {
        this.jsl.env.error('@simulate: '+language.string(205));
      }
    } else {
      this.jsl.env.error('@simulate: '+language.string(206));
    }
  }
  
  /**
   * Performs linearization of the model and retrieves the linear matrices.
   * @returns {Array<Object>} - An array containing the A, B, C, and D matrices.
   */
  async linearize() {
    const linres = await this.sendExpression("setcommand_line_options(\"+generateSymbolicLinearization\")");
    if(linres && linres[0] === "false") {
      this.jsl.env.error('@simulate: '+language.string(207)+ await this.sendExpression("getErrorString()"));
      return false;
    }

    const fields = Object.keys(this.override_variables);
    const tmpoverride1 = fields.map(field => `${field}=${this.override_variables[field]}`);
    const tmpoverride2 = tmpoverride1.length ? ` -override=${tmpoverride1.join(',')}` : "";

    const lin_fields = Object.keys(this.linear_options);
    const tmpoverride1lin = lin_fields.map(field => `${field}=${this.linear_options[field]}`);
    const overridelinear = tmpoverride1lin.join(',');

    let csvinput = '';
    if(this.input_flag) {
      this.createcsvData();
      csvinput = `-csvInput=${this.csvfile.replace(/\\/g, '/')}`;
    }

    const linexpr = `linearize(${this.modelname},${overridelinear},sim_flags="${csvinput}  ${tmpoverride2}")`;
    const res = await this.sendExpression(linexpr);
    this.resultfile = res.resultFile;
    this.linear_modelname = `linear_${this.modelname}`;
    this.linearfile = path.join(this.mat_temp_dir, `${this.linear_modelname}.mo`).replace(/\\/g, '/');
    if(fs.existsSync(this.linearfile)) {
      const loadmsg = await this.sendExpression(`loadFile("${this.linearfile}")`);
      if(loadmsg && loadmsg[0] === "false") {
        this.jsl.env.error('@linearize: '+ await this.sendExpression("getErrorString()"));
        return false;
      }

      const cNames = await this.sendExpression("getClassNames()");
      const buildmodelexpr = `buildModel(${cNames[0]})`;
      const buildModelmsg = await this.sendExpression(buildmodelexpr);
      if(buildModelmsg && buildModelmsg.length > 0) {
        this.linear_flag = true;
        this.xmlfile = path.join(this.mat_temp_dir, buildModelmsg[1]);
        this.linear_quantity_list = [];
        await this.xmlparse();
        return this.getLinearMatrix();
      } else {
        this.jsl.env.error('@linearize: '+ await this.sendExpression("getErrorString()"));
        return false;
      }
    }
    return true;
  }
  
  /**
   * Retrieves the linear A, B, C, and D matrices.
   * @returns {Array<Object>} - An array containing the A, B, C, and D matrices.
   */
  getLinearMatrix() {
    const matrix_A = {};
    const matrix_B = {};
    const matrix_C = {};
    const matrix_D = {};

    this.linear_quantity_list.forEach(item => {
      const name = item.name;
      const value = item.value;

      if(item.variability === "parameter") {
        if(name.startsWith('A')) {
          matrix_A[name] = value;
        } else if(name.startsWith('B')) {
          matrix_B[name] = value;
        } else if(name.startsWith('C')) {
          matrix_C[name] = value;
        } else if(name.startsWith('D')) {
          matrix_D[name] = value;
        }
      }
    });

    return [matrix_A, matrix_B, matrix_C, matrix_D];
  }
  
  /**
   * Converts linear matrix data into a two-dimensional array format.
   * @param {Object} matrix_name - The linear matrix object to convert.
   * @returns {number[][]|number} - The converted matrix as a 2D array or 0 if empty.
   */
  getLinearMatrixValues(matrix_name) {
    if(Object.keys(matrix_name).length > 0) {
      const fields = Object.keys(matrix_name);
      const last_field = fields[fields.length - 1];
      const rows = parseInt(last_field.charAt(2), 10);
      const columns = parseInt(last_field.charAt(4), 10);
      const tmp_matrix = Array.from({ length: rows }, () => Array(columns).fill(0));

      fields.forEach(field => {
        const r = parseInt(field.charAt(2), 10) - 1;
        const c = parseInt(field.charAt(4), 10) - 1;
        const val = parseFloat(matrix_name[field]);
        tmp_matrix[r][c] = val;
      });

      return tmp_matrix;
    } else {
      return 0;
    }
  }
  
  /**
   * Retrieves the linear input variables.
   * @returns {string|boolean} - The linear input variables or false if the model is not linearized.
   */
  getlinear_inputs() {
    if(this.linear_flag) {
      return this.linear_inputs;
    } else {
      this.jsl.env.error("@getlinear_inputs: "+language.string(202));
      return false;
    }
  }
  
  /**
   * Retrieves the linear output variables.
   * @returns {string|boolean} - The linear output variables or false if the model is not linearized.
   */
  getlinear_outputs() {
    if(this.linear_flag) {
      return this.linear_outputs;
    } else {
      this.jsl.env.error("@getlinear_outputs: "+language.string(202));
      return false;
    }
  }
  
  /**
   * Retrieves the linear state variables.
   * @returns {string|boolean} - The linear state variables or false if the model is not linearized.
   */
  getlinear_states() {
    if(this.linear_flag) {
      return this.linear_states;
    } else {
      this.jsl.env.error("@getlinear_states: "+language.string(202));
      return false;
    }
  }
  
  /**
   * Retrieves simulation solutions based on the provided arguments and result file.
   * @param {string|string[]} [args] - A single variable name or an array of names to retrieve solutions for. If omitted, retrieves all variables.
   * @param {string} [resultfile=this.resultfile] - The path to the result file.
   * @returns {Promise<any>} - A promise that resolves with the simulation results or an error message.
   */
  async getSolutions(args, resultfile = this.resultfile) {
    resultfile = resultfile.replace(/\\/g, '/');
    if(fs.existsSync(resultfile)) {
      if(args && args.length > 0) {
        const variables = `{${args.join(',')}}`;
        const simresult = await this.sendExpression(`readSimulationResult("${resultfile}", ${variables})`);
        await this.sendExpression("closeSimulationResultFile()");
        return simresult;
      } else {
        const variables = await this.sendExpression(`readSimulationResultVars("${resultfile}")`);
        await this.sendExpression("closeSimulationResultFile()");
        return variables;
      }
    } else {
      this.jsl.env.error('@getSolutions: ' + language.string(208) + resultfile);
      return false;
    }
  }
  
  /**
   * Creates valid variable names by replacing invalid characters and categorizes them based on the structure name.
   * @param {string} name - The original variable name.
   * @param {any} value - The value of the variable.
   * @param {string} structname - The structure name (e.g., 'continuous', 'parameter').
   */
  createValidNames(name, value, structname) {
    const tmpname = name.replace(/[^a-zA-Z0-9]/g, '_'); // Replace invalid characters with underscore
    this.mapped_names[tmpname] = name;

    if(structname === 'continuous') {
      this.continuous_list[tmpname] = value;
    } else if(structname === 'parameter') {
      this.parameter_list[tmpname] = value;
    } else if(structname === 'input') {
      this.input_list[tmpname] = value;
    } else if(structname === 'output') {
      this.output_list[tmpname] = value;
    }
  }
  
  /**
   * Parses a given expression string into structured data based on predefined formats.
   * Handles various formats including single and nested lists, records, and single elements.
   * @param {string} args - The expression string to parse.
   * @returns {Array|Object|string} - The parsed data which could be an array, an object, or a string.
   */
  parseExpression(args) {
    // Use regular expressions to match strings and key parts of the expression
    const final = args.match(/"(.*?)"|[{}()=]|-?\d+(\.\d+)?([eE][+-]?\d+)?|[a-zA-Z_][a-zA-Z0-9_.]*/g);
    
    if(final.length > 1) {
      if(final[0] === "{" && final[1] !== "{") {
        // Handle single-level list
        let buff = [];
        for(let i = 0; i < final.length; i++) {
          if(!["{", "}", ")", "(", ","].includes(final[i])) {
            const value = final[i].replace(/"/g, "");
            buff.push(value);
          }
        }
        return buff;

      } else if(final[0] === "{" && final[1] === "{") {
        // Handle nested lists
        let buff = [];
        let tmp = [];
        for(let i = 1; i < final.length - 1; i++) {
          if(final[i] === "{") {
            tmp = [];
          } else if(final[i] === "}") {
            buff.push(tmp);
            tmp = [];
          } else {
            tmp.push(final[i].replace(/"/g, ""));
          }
        }
        return buff;

      } else if(final[0] === "record") {
        // Handle record structure
        let result = {};
        for(let i = 2; i < final.length - 2; i++) {
          if(final[i] === "=") {
            const key = final[i - 1];
            const value = final[i + 1].replace(/"/g, "");
            result[key] = value;
          }
        }
        return result;

      } else if(final[0] === "fail") {
        // Handle failure case
        return this.sendExpression("getErrorString()");
      } else {
        // Return as a simple string if no special cases match
        return args.replace(/"/g, "");
      }
    } else if(final.length === 1) {
      // Handle single element case
      return final[0].replace(/"/g, "");
    } else {
      // Handle empty result
      return args.replace(/"/g, "");
    }
  }

  /**
   * Closes the current session safely by cleaning up resources such as temporary files and network connections.
   * Terminates any active processes and removes temporary port files.
   */
  async close() {
    if(this.portfile && fs.existsSync(this.portfile)) {
      fs.unlinkSync(this.portfile);
    }

    if(this.active) {
      await this.requester.close();
      this.active = false;
    }
    
    killProcess(this.pid);
  }
}

exports.PRDC_JSLAB_OPENMODELICA_LINK = PRDC_JSLAB_OPENMODELICA_LINK;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={optim-rcmiga.js}]
/**
 * @file JSLAB library optim Real Coded Mixed Integer Genetic Algorithm submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 * @version 0.0.1
 */
 
/**
 * Class for Real Coded Mixed Integer Genetic Algorithm - RCMIGA.
 */
class PRDC_JSLAB_OPTIM_RCMIGA {

  /**
   * Creates an instance of PRDC_JSLAB_LIB_OPTIM_RCMIGA.
   * @param {Object} problem - The optimization problem definition.
   * @param {Object} opts - Configuration options for the algorithm.
   */
  constructor(problem, opts) {
    this.flag = 'preinit';
    this.problem = problem;
    this.opts = opts;
    this.state = {};
    this.selection = {};
    this.solution = {};
    this.constrained = problem.constrained;
    this.stoped = 0;

    this.checkInputs();
    if(this.bounded) {
      this.opts.lbm = repCol(this.opts.lb, opts.PopulationSize);
      this.opts.ubm = repCol(this.opts.ub, opts.PopulationSize);
    }
    
    this.opts.a = opts.a ?? 0;
    this.opts.b_real = opts.b_real ?? 0.15;
    this.opts.b_integer = opts.b_integer ?? 0.35;
    this.opts.p_real = opts.p_real ?? 10;
    this.opts.p_integer = opts.p_integer ?? 4;
    this.opts.UseVectorized = opts.UseVectorized ?? false;
    this.opts.UseParallel = opts.UseParallel ?? false;
    this.opts.Display = opts.Display ?? 'iter';
    
    // Inicijalizacija
    this.flag = 'init';
    this.outputFcn();
    this.state.StartTime = tic;
    this.state.StallTime = tic;
    this.state.StallGenerations = 1;
    this.state.RandSeed = 'rcmiga';
    this.state.Generation = 0;
      
    this.rand = seedRandom(this.state.RandSeed);
  }

  /**
   * Executes the optimization process.
   */
  async run(parallel_context, parallel_setup_fun) {
    if(this.opts.UseParallel) {
      this.parallel_context = parallel_context;
      this.parallel_setup_fun = parallel_setup_fun;
      parallel.terminate();
    }
    
    this.initState();
    this.initPopulation();
    await this.updateState();
    
    this.flag = 'iter';
    this.outputFcn();
    this.createPlotFcn();
    this.plotFcn();
    
    // Optimizacija
    var nvars = this.problem.nvars;
    var newPopulation = zeros(nvars * this.opts.PopulationSize);
    var stop = 0;
    while(!stop) { // Petlja za optimizaciju
      // Merenje vremena
      this.state.GenTime = tic;
      
      // Elitizam
      if(this.state.ReproductionCount.elite > 0) {
        var [S, I] = sorti(this.state.FunVal);
        this.selection.current_elite = getSub(I, this.selection.elite);
        setSub(newPopulation, index(range(0, nvars - 1), 
          this.selection.elite, nvars), getSub(this.state.Population, 
          index(range(0, nvars - 1), this.selection.current_elite, nvars)));      
      }
      
      //  Selekcija
      this.state.parents = this.selectionFcn();

      // Ukrstanje
      setSub(newPopulation, index(range(0, nvars - 1), 
        this.selection.children, nvars), this.crossoverFcn());
      
      // Mutacija
      setSub(newPopulation, index(range(0, nvars - 1), 
        this.selection.mutants, nvars), this.mutationFcn());
      
      // Provera granica
      this.state.Population = [...newPopulation];
      this.integerRestriction();
      if(this.bounded) {
        this.checkBounds();
      }
      
      // Odredjivanje vrednosti funkcije prilagodjenosti i ogranicenja
      this.state.Generation = this.state.Generation + 1;
      await this.updateState();

      // Prikaz stanja
      stop = this.stoppingCriteria(); // Kriterijumi zaustavljanja
      this.outputFcn();
      this.plotFcn();
      await waitMSeconds(5);
    }
    
    this.solution.generations = this.state.Generation;
    var [x_min, I] = mini(this.state.FunVal);
    this.solution.feasible = 1;
    if(this.constrained && this.state.ConSumVal[I] > 0) {
      this.solution.feasible = 0;
    }
    this.solution.x = getSub(this.state.Population, 
      index(range(0, nvars - 1), I, nvars));
    this.solution.fval = this.problem.fitnessfcn(this.solution.x);
    this.solution.StoppingCriteria = stop;
    
    this.flag = 'done';
    this.outputFcn();
  }
  
  /**
   * Validates the input parameters and options.
   */
  checkInputs() {
    if(typeof this.problem.nonlconfcn === 'function') {
      this.constrained = 1;
    }
    if(typeof this.problem.IntCon === 'undefined') {
      this.problem.IntCon = [];
    }
    
    this.bounded = true;
    if(typeof this.opts.lb === 'undefined' || typeof this.opts.ub === 'undefined') {
      this.bounded = false;
      if(typeof this.opts.InitalUnboundedRange === 'undefined') {
        this.opts.InitalUnboundedRange = createFilledArray(this.problem.nvars, [0, 1]);
      }
    } else if((this.problem.lb && this.problem.lb.length != this.problem.nvars) || 
        (this.problem.ub && this.problem.ub.length != this.problem.nvars)) {
      throw new Error('Problem bounds have invalid dimension!');
    }

    if(this.opts.UseVectorized) {
      if(this.opts.UseParallel == true){
        disp('Option UseParallel is ignored while option UseVectorized is true.');
      } else if(this.opts.UseParallel != false){
        disp('Option UseParallel must be true or false.');
      }
    } else {
      if(![true, false].includes(this.opts.UseParallel)) {
        throw new Error('Option UseParallel must be true or false!');
      }
    }
  }
  
  /**
   * Creates the initial population.
   */
  creationFcn() {
    return this.creationMixedUniform();
  }
    
  /**
   * Selects individuals from the population.
   */
  selectionFcn() {
    return this.binaryTournamentSelection();
  }
    
  /**
   * Performs crossover between selected parents.
   */
  crossoverFcn() {
    return this.laplaceMixedCrossover();
  }
    
  /**
   * Mutates individuals in the population.
   */
  mutationFcn() {
    return this.powerMixedMutation();
  }

  /**
   * Initializes the plotting function.
   */
  createPlotFcn() {
    
  }
  
  /**
   * Updates the graphical plot with current optimization status.
   */
  plotFcn() {
    this.displayPlot();
  }

  /**
   * Renders the optimization plot.
   */
  displayPlot() {

  }

  /**
   * Handles button events to stop the optimization process.
   */
  buttonCallback() {
    this.stoped = 1;
  } 
    
  /**
   * Manages the output display based on configuration.
   */
  outputFcn() {
    if(['iter', 'final'].includes(this.opts.Display)) {
      this.displayOutput();
    }
  }
  
  /**
   * Displays the current state of optimization.
   */
  displayOutput() {
    if(this.opts.Display === 'iter') {
      switch(this.flag) {
        case 'init':
          disp(' Optimization is initialized!');
          if(this.opts.UseVectorized) {
            disp(' Vectorized functions evaluation in use.');
          } else if(this.opts.UseParallel){
            disp(' Parallel functions evaluation in use.');
          }
          break;
        case 'iter':
          if(this.state.Generation === 0 || this.state.Generation % 20 === 0) {
            if(this.constrained) {
              dispMonospaced('\n                        Best        Max           Stall');
              dispMonospaced('   Generation           f(x)     Constraint    Generations');
            } else {
              dispMonospaced('\n                        Best       Stall');
              dispMonospaced('   Generation           f(x)    Generations');
            }
          }

          let fval_s = num2str(this.state.Best[this.state.Generation], 5);
          if(this.constrained) {
            if(!this.state.Feasible[this.state.Generation]) {
              fval_s += '*';
            }
            dispMonospaced(
              `   ${num2str(this.state.Generation, 0).padStart(10)}   ${
              fval_s.padStart(12)}   ${
              num2str(max(this.state.ConSumVal), 2).padStart(12)}   ${
              num2str(this.state.StallGenerations, 0).padStart(12)}`
            );
          } else {
            dispMonospaced(
              `   ${num2str(this.state.Generation, 0).padStart(10)}   ${
              fval_s.padStart(12)}   ${
              num2str(this.state.StallGenerations, 0).padStart(12)}`
            );
          }
          break;
        case 'done':
          var str = '\nOptimization is done';
          if(this.constrained) {
            if(this.state.Feasible[this.state.Generation]) {
              str += ', solution found';
            } else {
              str += ', no feasible solution found';
            }
          }
          disp(` ${str}, stopping criteria = ${this.solution.StoppingCriteria}!\n`);
          break;
      }
    } else if(this.opts.Display === 'final') {
      if(this.flag === 'done') {
        var str = '\nOptimization is done';
        if(this.constrained) {
          if(this.state.Feasible[this.state.Generation]) {
            str += ', solution found';
          } else {
            str += ', no feasible solution found';
          }
        }
        disp(` ${str}, stopping criteria = ${this.solution.StoppingCriteria}!\n`);
      }
    }
  }
  
  /**
   * Creates the initial population with mixed uniform distribution.
   */
  creationMixedUniform() {
    var lb = this.opts.lb;
    var ub = this.opts.ub;
    if(!this.bounded) {
      lb = this.opts.InitalUnboundedRange.map((v) => v[0]);
      ub = this.opts.InitalUnboundedRange.map((v) => v[1]);
    }
    var N = this.problem.IntCon.length;
    var population = arrayRand(lb, ub, 
      this.problem.nvars, this.opts.PopulationSize, this.rand);
    if(N) {
      var r = arrayRandi([0, 1], N, this.opts.PopulationSize, this.rand);
      var I = index(this.problem.IntCon, 
        range(0, this.opts.PopulationSize - 1), this.problem.nvars);
      
      setSub(population, I, plus(fix(getSub(population, I)), r));
    }
    return population;
  }
  
  /**
   * Performs binary tournament selection of parents.
   */
  binaryTournamentSelection() {
    var parents = zeros(this.state.nParents);
    var r1 = arrayRandi([0, this.opts.PopulationSize-1], 2, 
      this.state.nParents, this.rand);
    var r2 = arrayRandi([0, this.opts.PopulationSize-1], 2, 
      this.state.nParents, this.rand);
    var neq = elementWise((a, b) => a > b, r1, r2);
    var I1 = indexOfAll(neq, true); // closer r2
    var I2 = indexOfAll(neq, false); // closer r1
    setSub(parents, I1, getSub(r2, I1));
    setSub(parents, I2, getSub(r1, I2));
    return parents;
  }
  
  /**
   * Executes Laplace mixed crossover to generate offspring.
   */
  laplaceMixedCrossover() {
    var N = this.problem.IntCon.length;
    var nvars = this.problem.nvars;
    var iParents = this.state.parents;
    var nChildren = this.state.ReproductionCount.children;
    var nParents = this.state.parentsCount.crossover;
    var sParents = this.state.parentsSelection.crossover;
    
    var b = scale(ones(nvars * nChildren/2), this.opts.b_real);
    if(N) {
      setSub(b, index(this.problem.IntCon, range(0, nChildren/2 - 1), nvars), 
        scale(ones(N * nChildren/2), this.opts.b_integer));
    }
    var u = arrayRand(zeros(nvars), ones(nvars), nvars, nChildren/2, this.rand);
    var r = arrayRand(zeros(nvars), ones(nvars), nvars, nChildren/2, this.rand);
    var beta = elementWise((x, y) => this.opts.a-x*log10(y), b, u); // a-b*log10(u)
    var I = indexOfAll(r.map((ri) => ri > 0.5), true);
    setSub(beta, I, elementWise((x, y) => this.opts.a+x*log10(y), 
      getSub(b, I),  getSub(u, I))); // a+b*log10(u)
    
    var mother = getSub(this.state.Population, index(range(0, nvars - 1), 
      getSub(iParents, getSub(sParents, range(0, nParents/2-1))), nvars));
    var father = getSub(this.state.Population, index(range(0, nvars - 1), 
      getSub(iParents, getSub(sParents, range(nParents/2, nParents-1))), nvars));
    var children = plus(concatRow(nvars, mother, father), 
      elementWise((a, b, c) => a*abs(b-c), 
      repCol(beta, 2), repCol(mother, 2), repCol(father, 2)));
    return children;
  }
  
  /**
   * Applies power mixed mutation to selected individuals.
   */
  powerMixedMutation() {
    var N = this.problem.IntCon.length;
    var nvars = this.problem.nvars;
    var nMutants = this.state.ReproductionCount.mutants;
    var sParents = this.state.parentsSelection.mutation;

    var p = scale(ones(nvars * nMutants), this.opts.p_real);
    if(N) {
      setSub(p, index(this.problem.IntCon, range(0, nMutants - 1), nvars), 
        scale(ones(N * nMutants), this.opts.p_integer));
    }
    var s1 = arrayRand(zeros(nvars), ones(nvars), nvars, nMutants, this.rand);
    var r = arrayRand(zeros(nvars), ones(nvars), nvars, nMutants, this.rand);
    var s = elementWise((a, b) => Math.pow(a, b), s1, p);
     
    var parents = getSub(this.state.Population, 
      getSub(sParents, index(range(0, nvars - 1), sParents, nvars)));
    var mutants;
    
    if(!this.bounded) {
      mutants = elementWise((a, b, c) => c < 0.5 ? a + b : a - b, parents, s, r);
    } else {
      var ubm = repCol(this.opts.ub, nMutants);
      var lbm = repCol(this.opts.lb, nMutants);
      var t = elementWise((a, b, c) => (a - b)/(c - a), parents, this.opts.lb, this.opts.ub);
      mutants = elementWise((a, b, c) => a+b*(a-c), parents, s, lbm);
      
      var I = indexOfAll(elementWise((a, b) => a < b, t, r), true);
      setSub(mutants, I, elementWise((a, b, c) => a-b*(c-a), 
        getSub(parents, I), getSub(s, I), getSub(ubm, I)));
    }

    return mutants;
  }
  
  /**
   * Applies Gaussian mutation to selected individuals.
   */
  gaussianMutation() {
    
  }
  
  /**
   * Ensures integer constraints are met for specific variables.
   */
  integerRestriction() {
    var N = this.problem.IntCon.length;
    if(N) {
      var I = index(this.problem.IntCon, 
        [...this.selection.children, ...this.selection.mutants], this.problem.nvars);
      var p = getSub(this.state.Population, I);
      
      var r = arrayRandi([0, 1], N, 
        this.state.ReproductionCount.children + 
        this.state.ReproductionCount.mutants, this.rand);
      
      var Is = indexOfAll(neg(isInteger(p)), true);
      setSub(p, Is, plus(fix(getSub(p, Is)), getSub(r, Is)));
      setSub(this.state.Population, I, p);
    }
  }
  
  /**
   * Checks and enforces variable bounds within the population.
   */
  checkBounds() {   
    this.state.Population = elementWise((a, b, c) => min([max([a, b]), c]), 
      this.state.Population, this.opts.lbm, this.opts.ubm);
  }
  
  /**
   * Evaluates whether stopping criteria have been met.
   * @returns {number} Code indicating the reason to stop or continue.
   */
  stoppingCriteria() {
    var stop = 0;
    var gen = this.state.Generation;
    
    if(gen > 0) {
      if(this.state.Best[gen] < this.state.Best[gen - 1] || 
          !this.state.Feasible[gen] || 
          this.state.Feasible[gen] > this.state.Feasible[gen - 1]) {
        this.state.StallTime = tic;
        this.state.StallGenerations = 1;
      } else {
        this.state.StallGenerations = this.state.StallGenerations + 1;
      }
    }
    
    if(gen >= (this.opts.MaxGenerations - 1)) {   
      // 1 - Maksimalni broj generacija ostvaren
      stop = 1;
    } else if(toc(this.state.StartTime) >= this.opts.MaxTime) {
      // 2 - Proteklo maksimalno vreme trajanja optimizacije
      stop = 2;
    } else if(this.state.Feasible[gen] && 
        this.state.Best[gen] <= this.opts.FitnessLimit) {
      // 3 - Funkcija prilagodjenosti dostiglja ciljanu vrednost
      stop = 3;
    } else if(gen > (this.opts.MaxStallGenerations - 2) && 
        this.state.Feasible[gen - (this.opts.MaxStallGenerations - 2)] && 
        this.state.Feasible[gen] && 
        ((this.state.Best[gen - (this.opts.MaxStallGenerations - 2)] -
        this.state.Best[gen]) <= this.opts.FunctionTolerance)) {
      // 4 - Promena vrednosti funkcija manja od tolerancije
      stop = 4;
    } else if(this.state.StallGenerations >= this.opts.MaxStallGenerations) {
      // 5 - Bez promene vrednosti funkcije kroz odredjeni broj generacija
      stop = 5;
    } else if(toc(this.state.StallTime) >= this.opts.MaxStallTime) {
      // 6 - Bez promene vrednosti funkcije odredjeno vreme
      stop = 6;
    } else if(this.stoped) {
      // 7 - Korisnik zaustavlja proces
      stop = 7;
    }
    return stop;
  }
  
  /**
   * Initializes the population for the optimization process.
   */
  initPopulation() {
    this.state.Population = this.creationFcn();
    this.integerRestriction();
    if(this.bounded) {
      this.checkBounds();
    }
  }
  
  /**
   * Initializes the internal state of the algorithm.
   */
  initState() {
    // Merenje vremena
    this.state.GenTime = tic;
    
    this.state.FunVal = zeros(this.opts.PopulationSize);
    
    this.state.ConSumVal = zeros(this.opts.PopulationSize);
    this.state.Best = zeros(this.opts.MaxGenerations);
    this.state.Feasible = ones(this.opts.MaxGenerations);
    this.state.Time = zeros(this.opts.MaxGenerations);
    this.state.x = zeros(this.opts.MaxGenerations * this.problem.nvars);

    this.state.ReproductionCount = {};
    this.state.ReproductionCount.elite = this.opts.EliteCount;
    this.state.ReproductionCount.children = fix(this.opts.CrossoverFraction * 
      (this.opts.PopulationSize - this.opts.EliteCount));

    if(mod(this.state.ReproductionCount.children, 2) != 0) {
      this.state.ReproductionCount.children = this.state.ReproductionCount.children - 1;
    }

    this.state.ReproductionCount.mutants = this.opts.PopulationSize - 
      (this.state.ReproductionCount.elite + this.state.ReproductionCount.children);

    this.state.parentsCount = {};
    this.state.parentsCount.crossover = this.state.ReproductionCount.children;
    this.state.parentsCount.mutation = this.state.ReproductionCount.mutants;
    this.state.nParents = this.state.parentsCount.crossover + 
      this.state.parentsCount.mutation;

    this.state.parentsSelection = {};
    this.state.parentsSelection.crossover = range(0, 
      this.state.parentsCount.crossover - 1);
    this.state.parentsSelection.mutation = plus(
      this.state.parentsCount.crossover, 
      range(0, this.state.parentsCount.mutation - 1));
    
    this.selection.elite = range(0, this.state.ReproductionCount.elite - 1);
    this.selection.children = plus(this.state.ReproductionCount.elite, 
      range(0, this.state.ReproductionCount.children - 1));
    this.selection.mutants = plus((this.state.ReproductionCount.elite + 
      this.state.ReproductionCount.children), 
      range(0, this.state.ReproductionCount.mutants - 1));

    if(this.constrained) {
      this.state.ConSize = [
        this.problem.nonlconfcn(zeros(this.problem.nvars)).length, this.opts.PopulationSize];
      
      this.state.ConVal = zeros(this.state.ConSize[0] * this.state.ConSize[1]);
      this.state.ConNormVal = zeros(this.state.ConSize[0] * this.state.ConSize[1]);
    }
  }
  
  /**
   * Updates the current state of the algorithm based on evaluations.
   */
  async updateState() {
    await this.evalFitnessFcn();
    if(this.constrained) {
      await this.evalConstraintsFcn();
      this.updatePenalty();
    }
    this.state.Time[this.state.Generation] = toc(this.state.GenTime);
    var i;
    [this.state.Best[this.state.Generation], i] = mini(this.state.FunVal);
    setSub(this.state.x, index(range(0, this.problem.nvars - 1), 
       this.state.Generation,  this.problem.nvars), 
       getSub(this.state.Population, 
       index(range(0, this.problem.nvars - 1), i,  this.problem.nvars)));
    
    if(this.constrained && this.state.ConSumVal[i] > 0) {
      this.state.Feasible[this.state.Generation] = 0;
    }
  }
  
  /**
   * Updates penalty values based on constraint violations.
   */
  updatePenalty() {
    if(any(this.state.ConSumVal.map((a) => a == 0))) {
      if(this.state.Generation == 0) {
        var [s, i] = sorti(this.state.FunVal);
        this.selection.current_elite = getSub(i, this.selection.elite);
      }
      var fmin;
      if(this.state.ReproductionCount.elite > 0) {
        // Ne moze da bude bolje od najgore elitne jedinke
        fmin = max(getSub(this.state.FunVal, this.selection.current_elite));
      } else {
        // Ne moze da bude bolje od najbolje jedinike
        fmin = min(getSub(this.state.FunVal, this.selection.current_elite));
      }
      var I1 = indexOfAll(elementWise((a, b) => a > 0 && b <= fmin, 
        this.state.ConSumVal, this.state.FunVal), true);
      var I2 = indexOfAll(elementWise((a, b) => a > 0 && b > fmin, 
        this.state.ConSumVal, this.state.FunVal), true);
      setSub(this.state.FunVal, I1, plus(fmin, 
        getSub(this.state.ConSumVal, I1)));
      setSub(this.state.FunVal, I2, plus(getSub(this.state.FunVal, I2), 
        getSub(this.state.ConSumVal, I2)));
    } else {
      this.state.FunVal = this.state.ConSumVal;
    }
  }
  
  /**
   * Evaluates the fitness function for the current population.
   */
  async evalFitnessFcn() {
    var obj = this;
    var nvars = this.problem.nvars;
    
    var p;
    var n;
    if(this.state.ReproductionCount.elite > 0 && this.state.Generation > 0) {
      p = getSub(this.state.Population, index(range(0, nvars - 1), 
        [...this.selection.children, ...this.selection.mutants], nvars));
      n = this.state.ReproductionCount.children + this.state.ReproductionCount.mutants;
    } else {
      p = this.state.Population;
      n = this.opts.PopulationSize;
    }
    
    var val;
    if(this.opts.UseVectorized) {
      val = this.problem.fitnessfcn(p);
    } else {
      if(this.opts.UseParallel) {
        val = await parallel.parfor(0, n-1, 1, parallel.getProcessorsNum(), 
          this.parallel_context, this.parallel_setup_fun, `function(i) {
            var fun = ${obj.problem.fitnessfcn.toString()};
            return fun(getSub(${JSON.stringify(p)}, index(range(0, ${nvars} - 1), i, ${nvars})));
        }`);
      } else {
        val = zeros(n);
        for(var i = 0; i < n; i++) {
          val[i] = this.problem.fitnessfcn(getSub(p, index(range(0, nvars - 1), i, nvars)));
        }
      }
    }
    
    if(this.state.ReproductionCount.elite > 0 && this.state.Generation > 0) {
      this.state.FunVal = [...getSub(this.state.FunVal, this.selection.current_elite), ...val];
    } else {
      this.state.FunVal = val;
    }
  }
  
  /**
   * Evaluates constraint functions for the current population.
   */
  async evalConstraintsFcn() {
    var obj = this;
    var nvars = this.problem.nvars;
    
    var p;
    var n;
    var m = this.state.ConSize[0];
    if(this.state.ReproductionCount.elite > 0 && this.state.Generation > 0) {
      p = getSub(this.state.Population, index(range(0, nvars - 1), 
        [...this.selection.children, ...this.selection.mutants], nvars));
      n = this.state.ReproductionCount.children + this.state.ReproductionCount.mutants;
    } else {
      p = this.state.Population;
      n = this.opts.PopulationSize;
    }
    
    var val;
    if(this.opts.UseVectorized) {
      val = obj.problem.nonlconfcn(p);
    } else {
      if(this.opts.UseParallel) {
        val = await parallel.parfor(0, n-1, 1, parallel.getProcessorsNum(), 
          this.parallel_context, this.parallel_setup_fun, `function(i) {
            var fun = ${obj.problem.nonlconfcn.toString()};
            return fun(getSub(${JSON.stringify(p)}, index(range(0, ${nvars} - 1), i, ${nvars})));
        }`);
        val = val.flat();
      } else {
        m = this.state.ConSize[0];
        val = zeros(m * n);
        for(var i = 0; i < n; i++) {
          setSub(val, index(range(0, m - 1), i, m), 
            this.problem.nonlconfcn(getSub(p, 
            index(range(0, nvars - 1), i, nvars))));
        }
      }
    }
    if(this.state.ReproductionCount.elite > 0 && this.state.Generation > 0) {
      this.state.ConVal = concatCol(m, getSub(this.state.ConVal, 
        index(range(0, m - 1), this.selection.current_elite, m)), val);
    } else {
      this.state.ConVal = val;
    }
    this.normConstraintsFcn();
    this.state.ConSumVal = sumCol(this.state.ConNormVal, m, this.opts.PopulationSize);
  }
  
  /**
   * Normalizes constraint values to maintain consistent scaling.
   */
  normConstraintsFcn() {
    var ConNormVal = this.state.ConVal;
    var sNaN = indexOfAll(isNaN(ConNormVal), true);
    var sInf = indexOfAll(isInfinity(ConNormVal), true);
    var sNeg = indexOfAll(isNegative(ConNormVal), true);
    
    setSub(ConNormVal, sNaN, zeros(sNaN.length));
    setSub(ConNormVal, sInf, zeros(sInf.length));
    setSub(ConNormVal, sNeg, zeros(sNeg.length));

    var m = this.state.ConSize[0];
    var n = this.opts.PopulationSize;
    
    if(this.state.Generation == 0 || 
        (this.state.Generation > 0 && 
        this.state.Feasible[this.state.Generation-1])) {
      
      // Use first values of the first generation for normalization of
      // constraints until there is a feasible solution
      var l = elementWise((a) => Math.sqrt(a), 
        sumRow(elementWise((a) => Math.pow(a, 2), ConNormVal), m, n));
      var I = indexOfAll(l, 0);
      setSub(l, I, ones(I.length));
      if(isEmpty(this.l)) {
        this.l = l;
      } else {
        var s = indexOfAll(elementWise((a, b) => a > b, this.l, l), true);
        setSub(this.l, s, getSub(l, s));
      }
      
      this.lm = repCol(this.l, n);
    }

    setSub(ConNormVal, sNaN, getSub(this.lm, sNaN));
    setSub(ConNormVal, sInf, getSub(this.lm, sInf));
    this.state.ConNormVal = divideEl(ConNormVal, this.lm);
  }
}

exports.PRDC_JSLAB_OPTIM_RCMIGA = PRDC_JSLAB_OPTIM_RCMIGA;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={optim.js}]
/**
 * @file JSLAB library optim submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
var { PRDC_JSLAB_OPTIM_RCMIGA } = require('./optim-rcmiga');

/**
 * Class for JSLAB optim submodule.
 */
class PRDC_JSLAB_LIB_OPTIM {
  
  /**
   * Initializes the optim submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }
  
  /**
   * Minimizes an unconstrained function using a coordinate descent-like Powell algorithm.
   * @param {function} fnc Function to be minimized. Accepts an array of size N and returns a scalar.
   * @param {Array} x0 Initial guess for the parameters as an array of size N.
   * @param {Object} [options] Optional parameters:
   *   - eps: Convergence threshold (default: 1e-6)
   *   - alpha: Initial step size scaling factor (default: 0.001)
   *   - stepSize: Finite difference step size for gradient estimation (default: 1e-6)
   *   - maxIterations: Maximum number of iterations to prevent infinite loops (default: 1000)
   * @return {Object} An object with two fields:
   *   - argument: The parameter array that minimizes the function.
   *   - fncvalue: The function value at the minimized parameters.
   */
  optimPowell(fnc, x0, options = {}) {
    const {
      eps = 1e-6,
      alpha = 0.001,
      stepSize = 1e-6,
      maxIterations = 1000
    } = options;

    let convergence = false;
    let x = x0.slice(); // Create a copy of the initial guess
    let currentAlpha = alpha; // Current step size scaling factor

    let pfx = Infinity; // Previous function value initialized to Infinity
    let fx = fnc(x); // Current function value

    let iteration = 0;
    let dx;
    
    while(!convergence && iteration < maxIterations) {
      iteration++;
      const indices = shuffleIndices(x);
      convergence = true; // Assume convergence until a significant update is found

      // Iterate over each variable in shuffled order
      for(let i = 0; i < indices.length; i++) {
        const idx = indices[i];

        // Estimate the derivative (gradient) using finite differences
        x[idx] += stepSize;
        const fxi = fnc(x);
        x[idx] -= stepSize;
        dx = (fxi - fx) / stepSize;

        // Check convergence based on the derivative
        if(Math.abs(dx) > eps) {
          convergence = false;
        }

        // Update the parameter by moving against the gradient
        x[idx] -= currentAlpha * dx;

        // Update the function value after the parameter change
        fx = fnc(x);
      }

      // Adaptive step size adjustment
      if(fx < pfx) {
        currentAlpha *= 1.1; // Increase step size if improvement
      } else {
        currentAlpha *= 0.7; // Decrease step size if no improvement
      }
      pfx = fx;

      // Optional: Log progress every 100 iterations
      if(options.disp && iteration % 100 === 0) {
        this.jsl.env.disp(`Iteration ${iteration}: f(x) = ${fx}`);
      }
    }

    return { x, fx };
  }
  
  /**
   * Performs optimization using the Nelder-Mead algorithm.
   * @param {Function} f - The objective function to minimize. It should accept an array of numbers and return a scalar value.
   * @param {number[]} x0 - An initial guess for the parameters as an array of numbers.
   * @param {Object} [parameters] - Optional parameters to control the optimization process.
   * @param {number} [parameters.maxIterations=x0.length * 200] - Maximum number of iterations to perform.
   * @param {number} [parameters.nonZeroDelta=1.05] - Scaling factor for non-zero initial steps in the simplex.
   * @param {number} [parameters.zeroDelta=0.001] - Initial step size for parameters that are initially zero.
   * @param {number} [parameters.minErrorDelta=1e-6] - Minimum change in function value to continue iterations.
   * @param {number} [parameters.minTolerance=1e-5] - Minimum change in parameters to continue iterations.
   * @param {number} [parameters.rho=1] - Reflection coefficient.
   * @param {number} [parameters.chi=2] - Expansion coefficient.
   * @param {number} [parameters.psi=-0.5] - Contraction coefficient.
   * @param {number} [parameters.sigma=0.5] - Reduction coefficient.
   * @param {Array<Object>} [parameters.history] - Optional array to store the history of simplex states for analysis.
   *
   * @returns {{ fx: number, x: number[] }} An object containing:
   *   - `fx`: The minimum function value found.
   *   - `x`: The parameters corresponding to the minimum function value.
   */
  optimNelderMead(...args) {
    return this.jsl.env.fmin.nelderMead(...args);
  }
  
  /**
   * Performs optimization using the Conjugate Gradient method.
   * @param {Function} f - The objective function to minimize. It should accept an array of numbers and return a scalar value and its gradient.
   * @param {number[]} initial - An initial guess for the parameters as an array of numbers.
   * @param {Object} [params] - Optional parameters to control the optimization process.
   * @param {number} [params.maxIterations=initial.length * 20] - Maximum number of iterations to perform.
   * @param {Array<Object>} [params.history] - Optional array to store the history of optimization steps for analysis.
   *
   * @returns {{ fx: number, x: number[], fxprime: number[] }} An object containing:
   *   - `fx`: The minimum function value found.
   *   - `x`: The parameters corresponding to the minimum function value.
   *   - `fxprime`: The gradient of the function at the minimum.
   */
  optimConjugateGradient(...args) {
    return this.jsl.env.fmin.conjugateGradient(...args);
  }
  
  /**
   * Performs optimization using the Gradient Descent method.
   * @param {Function} f - The objective function to minimize. It should accept an array of numbers and return a scalar value and its gradient.
   * @param {number[]} initial - An initial guess for the parameters as an array of numbers.
   * @param {Object} [params] - Optional parameters to control the optimization process.
   * @param {number} [params.maxIterations=initial.length * 100] - Maximum number of iterations to perform.
   * @param {number} [params.learnRate=0.001] - Learning rate or step size for each iteration.
   * @param {Array<Object>} [params.history] - Optional array to store the history of optimization steps for analysis.
   *
   * @returns {{ fx: number, x: number[], fxprime: number[] }} An object containing:
   *   - `fx`: The minimum function value found.
   *   - `x`: The parameters corresponding to the minimum function value.
   *   - `fxprime`: The gradient of the function at the minimum.
   */
  optimGradientDescent(...args) {
    return this.jsl.env.fmin.gradientDescent(...args);
  }
  
  /**
   * Performs optimization using the Gradient Descent method with Wolfe Line Search.
   * @param {Function} f - The objective function to minimize. It should accept an array of numbers and return a scalar value and its gradient.
   * @param {number[]} initial - An initial guess for the parameters as an array of numbers.
   * @param {Object} [params] - Optional parameters to control the optimization process.
   * @param {number} [params.maxIterations=initial.length * 100] - Maximum number of iterations to perform.
   * @param {number} [params.learnRate=1] - Initial learning rate or step size for the line search.
   * @param {number} [params.c1=1e-3] - Parameter for the Armijo condition in Wolfe Line Search.
   * @param {number} [params.c2=0.1] - Parameter for the curvature condition in Wolfe Line Search.
   * @param {Array<Object>} [params.history] - Optional array to store the history of optimization steps for analysis, including line search details.
   * @returns {{ fx: number, x: number[], fxprime: number[] }} An object containing:
   *   - `fx`: The minimum function value found.
   *   - `x`: The parameters corresponding to the minimum function value.
   *   - `fxprime`: The gradient of the function at the minimum.
   */
  optimGradientDescentLineSearch(...args) {
    return this.jsl.env.fmin.gradientDescentLineSearch(...args);
  }
    
  /**
   * Performs root finding using the Bisection method.
   * @param {Function} f - The function for which to find a root. It should accept a number and return a number.
   * @param {number} a - The start of the interval. Must satisfy f(a) and f(b) have opposite signs.
   * @param {number} b - The end of the interval. Must satisfy f(a) and f(b) have opposite signs.
   * @param {Object} [parameters] - Optional parameters to control the root-finding process.
   * @param {number} [parameters.maxIterations=100] - Maximum number of iterations to perform.
   * @param {number} [parameters.tolerance=1e-10] - Tolerance for convergence. The method stops when the interval width is below this value.
   * @returns {number} The root found within the interval [a, b].
   */
  optimBisect(...args) {
    return this.jsl.env.fmin.bisect(...args);
  }
  
  /**
   * Performs search using the Nelder-Mead algorithm.
   * @param {Function} f - The objective function to minimize. It should accept an array of numbers and return a scalar value.
   * @param {number[]} x0 - An initial guess for the parameters as an array of numbers.
   * @param {Object} [parameters] - Optional parameters to control the optimization process.
   * @param {number} [parameters.maxIterations=x0.length * 200] - Maximum number of iterations to perform.
   * @param {number} [parameters.nonZeroDelta=1.05] - Scaling factor for non-zero initial steps in the simplex.
   * @param {number} [parameters.zeroDelta=0.001] - Initial step size for parameters that are initially zero.
   * @param {number} [parameters.minErrorDelta=1e-6] - Minimum change in function value to continue iterations.
   * @param {number} [parameters.minTolerance=1e-5] - Minimum change in parameters to continue iterations.
   * @param {number} [parameters.rho=1] - Reflection coefficient.
   * @param {number} [parameters.chi=2] - Expansion coefficient.
   * @param {number} [parameters.psi=-0.5] - Contraction coefficient.
   * @param {number} [parameters.sigma=0.5] - Reduction coefficient.
   * @param {Array<Object>} [parameters.history] - Optional array to store the history of simplex states for analysis.
   *
   * @returns {{ fx: number, x: number[] }} An object containing:
   *   - `fx`: The minimum function value found.
   *   - `x`: The parameters corresponding to the minimum function value.
   */
  fminsearch(...args) {
    return this.jsl.env.fmin.nelderMead(...args);
  }
  
  /**
   * Finds the minimum of a univariate function within a specified interval using a bracketing method.
   * @param {function} func - The function to minimize. Should accept a single number and return a number.
   * @param {number} a - The lower bound of the interval.
   * @param {number} b - The upper bound of the interval.
   * @param {number} [tol=1e-5] - The tolerance for convergence (optional).
   * @returns {{ fx: number, x: number[]}} An object containing:
   *   - `fx`: The minimum function value found.
   *   - `x`: The x-value where the function attains its minimum within [a, b].
   */
  fminbnd(func, a, b, tol = 1e-5) {
    const eps = 1e-10;  // A small value to prevent division by zero or to avoid precision issues.
    const golden_ratio = (3 - Math.sqrt(5)) / 2;

    let x = a + golden_ratio * (b - a);
    let w = x;
    let v = w;
    let fx = func(x);
    let fw = fx;
    let fv = fw;

    let d = 0;
    let e = 0;

    while(Math.abs(b - a) > tol) {
      const m = 0.5 * (a + b);
      const tol1 = tol * Math.abs(x) + eps;
      const tol2 = 2 * tol1;

      // Check for convergence
      if(Math.abs(x - m) <= tol2 - 0.5 * (b - a)) {
        break;
      }

      let u;
      let useGolden = true;

      // Try parabolic interpolation
      if(Math.abs(e) > tol1) {
        const r = (x - w) * (fx - fv);
        const q = (x - v) * (fx - fw);
        const p = (x - v) * q - (x - w) * r;
        const q2 = 2 * (q - r);
        const q2abs = Math.abs(q2);
        if(q2abs > eps) {
          u = x - p / q2;
          if(a + tol1 <= u && u <= b - tol1 && Math.abs(u - x) < 0.5 * Math.abs(e)) {
            useGolden = false;
          }
        }
      }

      // If parabolic interpolation is not used, fall back to golden section
      if(useGolden) {
        if(x < m) {
          u = x + golden_ratio * (b - x);
        } else {
          u = x - golden_ratio * (x - a);
        }
        e = d;
      } else {
        e = d;
      }

      const fu = func(u);

      // Update a, b, v, w, x
      if(fu <= fx) {
        if(u < x) b = x;
        else a = x;
        v = w; fv = fw;
        w = x; fw = fx;
        x = u; fx = fu;
      } else {
        if(u < x) a = u;
        else b = u;
        if(fu <= fw || w === x) {
          v = w; fv = fw;
          w = u; fw = fu;
        } else if(fu <= fv || v === x || v === w) {
          v = u; fv = fu;
        }
      }
    }

    return { x, fx };
  }
  
  /**
   * Creates an instance of PRDC_JSLAB_LIB_OPTIM_RCMIGA.
   * @param {Object} problem - The optimization problem definition.
   * @param {Object} opts - Configuration options for the algorithm.
   */
  rcmiga(...args) {
    return new PRDC_JSLAB_OPTIM_RCMIGA(...args);
  }

}

exports.PRDC_JSLAB_LIB_OPTIM = PRDC_JSLAB_LIB_OPTIM;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={parallel.js}]
/**
 * @file JSLAB library parallel submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
 /**
 * Class for JSLAB parallel submodule.
 */
class PRDC_JSLAB_PARALLEL {

  /**
   * Constructs parallel submodule object with access to JSLAB's parallel functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    this.jsl = jsl;
    this.worker_pool = [];
    this.task_queue = [];
    this.is_initialized = false;
  }
  
  /**
   * Retrieves the number of logical processors available.
   * @returns {number} Number of processors.
   */
  getProcessorsNum() {
    return this.jsl.env.processors_number || 4;
  }
  
  /**
   * Generates the worker's internal script.
   * @param {Object} [context={}] - Optional context to pass to the work_function.
   * @param {Function|String} work_function_str - The work function to execute.
   * @param {Function|String} [setup_function_str] - Optional setup function to execute on init.
   */
  workerFunction(context = {}, setup_function_str = "") {
    return `
      
      self.addEventListener("message", async function(e) {
        if(e.data.type === 'execute') {
          try {
            const { work_fun_str, args } = e.data;

            // Reconstruct the work function
            const work_function = new Function('return ' + work_fun_str)();

            // Execute the work function with provided arguments
            const result = await work_function(...args);

            // Send back the result
            self.postMessage({ type: 'result', result });
          } catch(err) {
            self.postMessage({ type: 'error', error: err });
          }
        }
      });

      // Assign context variables
      Object.assign(self, ${JSON.stringify(context)});
            
      // Reconstruct and execute the setup function if provided
      (async () => {
        const __setup = ${setup_function_str || 'null'};
        if (typeof __setup === 'function') {
          await __setup.call(self);
        }
        self.postMessage({ type: 'ready' });
      })();
    `;
  }

  /**
   * Initializes the worker pool with the specified number of workers.
   * @param {number} num_workers - Number of workers to initialize.
   * @param {Object} [context={}] - Optional context to pass to the work_function.
   * @param {Function|String} [setup_function_str] - Optional setup function to execute on init.
   */
  init(num_workers, context = {}, setup_function_str = "") {
    if(this.is_initialized) return;

    if(!num_workers || num_workers <= 0) {
      num_workers = this.getProcessorsNum();
    }

    const worker_script = `
      ${this.jsl.getWorkerInit()}
      ${this.workerFunction(context, setup_function_str)}
    `;
    
    if(config.DEBUG_PARALLEL_WORKER_SETUP_FUN) {
      this.jsl._console.log(worker_script);
    }
    
    const blob = new Blob([worker_script], { type: 'application/javascript' });
    const blobURL = URL.createObjectURL(blob);

    for(let i = 0; i < num_workers; i++) {
      const worker = new Worker(blobURL);
      worker.busy = false;
      worker.ready = false;
      this.worker_pool.push(worker);
    }

    this.is_initialized = true;
  }

  /**
   * Assigns tasks from the queue to available workers.
   */
  assignTasksToWorkers() {
    for(const worker of this.worker_pool) {
      if(!worker.busy && this.task_queue.length > 0) {
        const task = this.task_queue.shift();
        worker.busy = true;
        
        if(config.DEBUG_PARALLEL_WORKER_WORK_FUN) {
          this.jsl._console.log(task);
        }
    
        function executeTask() {
          worker.postMessage({
            type: 'execute',
            work_fun_str: task.work_function_str,
            args: task.args,
          });
        }
        
        worker.onmessage = (e) => {
          if(e.data.type === 'ready') {
            worker.ready = true;
            executeTask();
          } else if(e.data.type === 'result') {
            task.resolve(e.data.result);
          } else if(e.data.type === 'error') {
            task.reject(new Error(e.data.error));
          }
          worker.busy = false;
          this.assignTasksToWorkers();
        };

        worker.onerror = (e) => {
          task.reject(new Error(e.message));
          worker.busy = false;
          this.assignTasksToWorkers();
        };
        
        if(worker.ready) {
          executeTask();
        }
      }
    }
  }

  /**
   * Enqueues a task to be executed by the worker pool.
   * @param {Object} context - Context variables to assign in the worker.
   * @param {Function|String} [setup_function] - Optional setup function to execute on init.
   * @param {Array} args - Arguments to pass to the work_function.
   * @param {Function|String} work_function - The work function to execute.
   * @param {boolean} reset_workers - Wether to reset all workers or not.
   * @returns {Promise} - Resolves with the result of the work_function.
   */
  run(context = {}, setup_function = null, args = [], work_function, reset_workers = false) {
    var setup_function_str = setup_function;
    if(typeof setup_function_str !== 'string') {
      setup_function_str = this.jsl.eval.rewriteCode(this.jsl.eval.getFunctionBody(setup_function)).code;
    }
    var work_function_str = work_function;
    if(typeof work_function_str !== 'string') {
      work_function_str = work_function.toString();
    }
    if(reset_workers) {
      this.terminate();
    }
    if(!this.is_initialized) {
      this.init(0, context, setup_function_str);
    }
    return new Promise((resolve, reject) => {
      this.task_queue.push({
        work_function_str,
        args,
        resolve,
        reject,
      });

      this.assignTasksToWorkers();
    });
  }

  /**
   * Executes a parallel for loop by dividing the iteration range among workers.
   *
   * @param {number} start - The initial value of the loop counter.
   * @param {number} end - The terminating value of the loop counter.
   * @param {number} [step=1] - The amount by which to increment the loop counter each iteration.
   * @param {number} [num_workers=this.getProcessorsNum()] - The number of workers to use.
   * @param {Object} [context={}] - Optional context to pass to the work_function.
   * @param {Function} [setup_function=null] - Optional setup function to execute before work_function.
   * @param {Function} work_function - The function to execute on each iteration.
   * @param {boolean} reset_workers - Wether to reset all workers or not.
   * @returns {Promise<Array>} - A promise that resolves to an array of results.
   */
  async parfor(start, end, step = 1, num_workers, context, 
      setup_function, work_function, reset_workers = false) {
    var setup_function_str = this.jsl.eval.rewriteCode(this.jsl.eval.getFunctionBody(setup_function)).code;
    if(reset_workers) {
      this.terminate();
    }
    if(!this.is_initialized) {
      this.init(num_workers, context, setup_function_str);
    }

    if(step === 0) {
      this.jsl.env.error('@parfor: '+language.string(197));
    }

    const isAscending = (end - start) * step > 0;

    if(!isAscending) {
      this.jsl.env.error('@parfor: '+language.string(198));
    }
    
    const total_items = Math.ceil(Math.abs((end - start) / step)) + 1;
    const chunk_size = Math.ceil(total_items / num_workers);
    const tasks = [];

    const task_function = async function(chunk_start, chunk_end, step, work_fun_str) {
      const work_function = new Function('return ' + work_fun_str)();
      const results = [];
      for(let i = chunk_start; i <= chunk_end; i += step) {
        const result = await work_function(i);
        results.push(result);
      }
      return results;
    };
    var task_function_str = task_function.toString();
    
    for(let worker_index = 0; worker_index < num_workers; worker_index++) {
      const chunk_start_index = worker_index * chunk_size;
      const chunk_end_index = Math.min(chunk_start_index + chunk_size, total_items);

      if(chunk_start_index >= chunk_end_index) {
        break;
      }

      const chunk_start = start + chunk_start_index * step;
      let chunk_end = start + (chunk_end_index * step) - step;

      if(chunk_end > end) {
        chunk_end = end;
      }
      
      var work_function_str = work_function;
      if(typeof work_function == 'function') {
        work_function_str = work_function.toString();
      }
      
      const task = this.run(
        context,
        setup_function_str,   
        [chunk_start, chunk_end, step, work_function_str],
        task_function_str
      );

      tasks.push(task);
    }

    const nested_results = await Promise.all(tasks);
    return nested_results.flat();
  }

  /**
   * Terminates all workers and resets the worker pool.
   */
  terminate() {
    for(const worker of this.worker_pool) {
      worker.terminate();
    }
    this.worker_pool = [];
    this.task_queue = [];
    this.is_initialized = false;
  }
}

exports.PRDC_JSLAB_PARALLEL = PRDC_JSLAB_PARALLEL;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={path.js}]
/**
 * @file JSLAB library path submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB path submodule.
 */
class PRDC_JSLAB_LIB_PATH {
  
  /**
   * Initializes a new instance of the path submodule, providing access to path manipulation utilities.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }

  /**
   * Extracts the directory of file.
   * @param {String} path The filesystem path from which to extract the directory.
   * @returns {String} The directory from the given path.
   */
  getDir(path) {
    return this.jsl.env.pathDirName(path);
  }
  
  /**
   * Extracts the name of the directory from a given filesystem path.
   * @param {String} path The filesystem path from which to extract the directory name.
   * @returns {String} The name of the directory from the given path.
   */
  getDirName(path) {
    return path.replaceAll('\\','/').match(/([^\/]*)\/*$/)[1];
  }
  
  /**
   * Retrieves the platform-specific path separator character.
   * @returns {String} The path separator character used by the system.
   */
  pathSep() {
    return this.jsl.env.pathSep();
  }
  
  /**
   * Determines if the current path is absolute.
   * @returns {boolean} True if the current path is absolute, false otherwise.
   */
  isAbsolutePath() {
    return this.jsl.env.pathIsAbsolute();
  }
  
  /**
   * Joins all given path segments together using the platform-specific separator as a delimiter.
   * @param {...string} paths The path segments to join.
   * @returns {string} The combined path.
   */
  pathJoin(...args) {
    return this.jsl.env.pathJoin(...args);
  }
  
  /**
   * Retrieves the file name from the provided file path.
   * @param {string} path - The complete file path.
   * @returns {string} The file name extracted from the path.
   */
  pathFileName(path) {
    return this.jsl.env.pathFileName(path);
  }

  /**
   * Returns the last portion of a path, similar to the Unix `basename` command.
   * @param {string} path - The file path to process.
   * @returns {string} The last segment of the path.
   */
  pathBaseName(path) {
    return this.jsl.env.pathBaseName(path);
  }
  
  /**
   * Retrieves the file extension from the provided file path.
   * @param {string} path - The complete file path.
   * @returns {string} The file extension extracted from the path.
   */
  pathFileExt(path) {
    return this.jsl.env.pathExtName(path);
  }
  
  /**
   * Retrieves the file extension from the provided file path.
   * @param {string} path - The complete file path.
   * @returns {string} The file extension extracted from the path.
   */
  pathExtName(path) {
    return this.jsl.env.pathExtName(path);
  }
  
  /**
   * Resolves a sequence of path segments into an absolute path using the environment's path resolver.
   * @param {string} path - The path or sequence of paths to resolve.
   * @returns {string} - The resolved absolute path.
   */
  pathResolve(path) {
    return this.jsl.env.pathResolve(path);
  }
  
  /**
   * Computes the relative path from one path to another. 
   * @param {string} from - The starting path.
   * @param {string} to - The target path.
   * @returns {string} - The relative path from the `from` path to the `to` path.
   */
  pathRelative(from, to) {
    return this.jsl.env.pathRelative(from, to);
  }
  
  /**
   * Normalizes a given path, resolving '..' and '.' segments using the environment's path normalizer.
   * @param {string} path - The path to normalize.
   * @returns {string} - The normalized path.
   */
  pathNormalize(path) {
    return this.jsl.env.pathNormalize(path);
  }
  
  /**
   * Compares two file paths after resolving them to their absolute forms to check if they refer to the same location.
   * @param {string} path1 - The first file path to compare.
   * @param {string} path2 - The second file path to compare.
   * @returns {boolean} Returns true if both paths resolve to the same absolute path, otherwise false.
   */
  comparePaths(path1, path2) {
    return this.jsl.env.pathResolve(path1) === this.jsl.env.pathResolve(path2);
  }
  
  /**
   * Generates a unique filesystem path by appending a number to the input path if the original path exists.
   * @param {String} path The base path for which a unique version is required.
   * @returns {String} A unique filesystem path based on the input path.
   */
  getUniquePath(path) {
    var i = 0;
    var unique_path = path;
    while(fs.existsSync(unique_path)) {
      i = i+1;
      unique_path = path+i;
    }
    return unique_path;
  }
  
  /**
   * Generates a unique filename by appending a number to the original path if it already exists.
   * @param {string} path - The original file path.
   * @param {string} ext - The original file extension.
   * @returns {string} A unique folder path.
   */
  getUniqueFilename(filename, ext) {
    var i = 0;
    var unique_filename = filename+'.'+ext;
    while(fs.existsSync(unique_filename)) {
      i = i+1;
      unique_filename = filename+i+'.'+ext;
    }
    return unique_filename;
  }
}

exports.PRDC_JSLAB_LIB_PATH = PRDC_JSLAB_LIB_PATH;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={presentation.js}]
/**
 * @file JSLAB library presentation submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB presentation submodule.
 */
class PRDC_JSLAB_LIB_PRESENTATION {
  
  /**
   * Constructs a presentation submodule object with access to JSLAB's functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }

  /**
   * Opens an existing presentation in a new window and returns its context.
   * @param {String} file_path - Absolute or relative path to the presentation directory.
   * @param {String} type - Type of presentation.
   * @returns {Promise<Window>} Resolves to the window context of the opened presentation.
   */
  async openPresentation(file_path, type) {
    file_path = this._getPath('openPresentation', file_path);
    if(this._checkPresentation('editPresentation', file_path)) {
      var obj = this;
      var name = this.jsl.env.pathBaseName(file_path);
      if(type == 'standalone') {
        var url = this.jsl.env.pathJoin(file_path, 'index.html')
        var wid = this.jsl.windows.openWindow(url);
      } else {
        var url = await this._startPresentation(this.jsl.env.pathJoin(file_path, name + '.exe'));
        var wid = this.jsl.windows.openWindow('url.html');
      }
      await this.jsl.windows.open_windows[wid].ready;
      var context = this.jsl.windows.open_windows[wid].context;
      var fullscreen = false;
      if(type == 'standalone') {
        while(typeof context.presentation == 'undefined') {
          await this.jsl.non_blocking.waitMSeconds(1);
        }
        context.document.addEventListener('keydown', (event) => {
          if(event.key == 'F11') {
            fullscreen = !fullscreen;
            obj.jsl.windows.open_windows[wid].setFullscreen(fullscreen);
          }
        });
      } else {
        context.document.getElementById('webview').src = url;
        context.webview.addEventListener('ipc-message', (e) => {
          if(e.args[0].key !== undefined) {
            if(e.args[0].key == 'F11') {
              fullscreen = !fullscreen;
              obj.jsl.windows.open_windows[wid].setFullscreen(fullscreen);
            }
          }
        });
      }
      this.jsl.windows.open_windows[wid].setTitle(file_path + ' - Presentation - JSLAB | PR-DC');
      return context;
    }
  }
  
  /**
   * Opens the presentation editor for the specified project and returns its context.
   * @async
   * @param {String} file_path - Absolute or relative path to the presentation directory.
   * @param {String} type - Type of presentation.
   * @returns {Promise<Window>} Resolves to the window context of the editor window.
   */
  async editPresentation(file_path, type) {
    file_path = this._getPath('editPresentation', file_path);
    if(this._checkPresentation('editPresentation', file_path)) {
      var name = this.jsl.env.pathBaseName(file_path);
      if(type == 'standalone') {
        var url = this.jsl.env.pathJoin(file_path, 'index.html')
      } else {
        var url = await this._startPresentation(this.jsl.env.pathJoin(file_path, name + '.exe'));
      }
      var wid = this.jsl.windows.openWindow('presentation-editor.html');
      await this.jsl.windows.open_windows[wid].ready;
      var context = this.jsl.windows.open_windows[wid].context;
      while(typeof context.presentation_editor == 'undefined') {
        await this.jsl.non_blocking.waitMSeconds(1);
      }
      context.presentation_editor.setPath(file_path, url);
      this.jsl.windows.open_windows[wid].setTitle(file_path + ' - Presentation editor - JSLAB | PR-DC');
      return context;
    }
  }
  
  /**
   * Creates a new presentation project on disk and optionally opens it in the editor.
   * @param {String} file_path - Target directory where the presentation project will be created.
   * @param {Object} [opts_in] Extra options
   * @param {Boolean} [open_editor=true] - If true, automatically opens the new project in the editor.
   */
  createPresentation(file_path, opts_in = {}, open_editor = true) {
    file_path = this._getPath('createPresentation', file_path);
    var name = this.jsl.env.pathBaseName(file_path);
    var presentation_config = {
      "jslab_version": this.jsl.context.version,
      "slide_width": 1920,
      "slide_height": 1080,
      ...opts_in
    }
    this.jsl.env.makeDirectory(file_path);
    this.jsl.env.makeDirectory(this.jsl.env.pathJoin(file_path, 'res/'));
    this.jsl.env.makeDirectory(this.jsl.env.pathJoin(file_path, 'res/internal/'));

    var js = this.jsl.env.readFileSync(this.jsl.env.pathJoin(app_path, 'js/windows/presentation.js')).toString();
    js = js.replace('%presentation_config%', JSON.stringify(presentation_config, false, 2));
    this.jsl.file_system.writeFile(this.jsl.env.pathJoin(file_path, 'res/internal/presentation.js'), js);
    
    this.jsl.file_system.copyFile(this.jsl.env.pathJoin(app_path, 'dev/portable_server/portable_server.exe'),
      this.jsl.env.pathJoin(file_path, name + '.exe'));
    this.jsl.file_system.copyFile(this.jsl.env.pathJoin(app_path, 'css/presentation.css'),
      this.jsl.env.pathJoin(file_path, 'res/internal/presentation.css'));
    
    this.jsl.file_system.writeFile(this.jsl.env.pathJoin(file_path, 'main.css'), '');
    this.jsl.file_system.writeFile(this.jsl.env.pathJoin(file_path, 'main.js'), '');
    this.jsl.file_system.writeFile(this.jsl.env.pathJoin(file_path, 'res/internal/config.json'), JSON.stringify(presentation_config, false, 2));
    
    var presentation_scripts = '';
    var presentation_stylesheets = '';
    if(opts_in.hasOwnProperty('modules')) {
      var handled = new Set();
      for(var module of opts_in.modules) {
        var module = (module === 'plot-json') ? 'plot' : module;
        if(handled.has(module)) continue;
        handled.add(module);
    
        if(module == 'img-pdf') {
          this.jsl.file_system.copyFile(this.jsl.env.pathJoin(app_path, 'lib/pdfjs-dist-3.11.174/pdf.min.js'), this.jsl.env.pathJoin(file_path, 'res/pdf.min.js'));
          this.jsl.file_system.copyFile(this.jsl.env.pathJoin(app_path, 'lib/pdfjs-dist-3.11.174/pdf.worker.min.js'), this.jsl.env.pathJoin(file_path, 'res/pdf.worker.min.js'));
          presentation_scripts += `
  <script type="text/javascript" src="./res/pdf.min.js"></script>
  <script type="text/javascript" src="./res/pdf.worker.min.js"></script>
`;
        } else if(module == 'plot') {
          this.jsl.file_system.copyFile(this.jsl.env.pathJoin(app_path, 'lib/plotly-2.24.2/plotly-2.24.2.min.js'), this.jsl.env.pathJoin(file_path, 'res/plotly-2.24.2.min.js'));
          presentation_scripts += `
  <script type="text/javascript" src="./res/plotly-2.24.2.min.js"></script>
`;
        } else if(module == 'ui') {
          this.jsl.file_system.copyFile(this.jsl.env.pathJoin(app_path, 'css/ui.css'), this.jsl.env.pathJoin(file_path, 'res/ui.css'));
          this.jsl.file_system.copyFile(this.jsl.env.pathJoin(app_path, 'js/windows/ui.js'), this.jsl.env.pathJoin(file_path, 'res/ui.js'));
          presentation_stylesheets += `
  <link rel="stylesheet" type="text/css" href="./res/ui.css" />
`;
          presentation_scripts += `
  <script type="text/javascript" src="./res/ui.js"></script>
`;
        } else if(module == 'latex') {
          this.jsl.file_system.copyFile(this.jsl.env.pathJoin(app_path, 'js/windows/mathjax-config.js'), this.jsl.env.pathJoin(file_path, 'res/mathjax-config.js'));
          this.jsl.file_system.copyFolder(this.jsl.env.pathJoin(app_path, 'lib/tex-mml-chtml-3.2.0'), this.jsl.env.pathJoin(file_path, 'res/tex-mml-chtml-3.2.0'));
          presentation_scripts += `
  <script type="text/javascript" src="./res/mathjax-config.js"></script>
  <script type="text/javascript" src="./res/tex-mml-chtml-3.2.0/tex-mml-chtml-3.2.0.js"></script>
`;
        } else if(module == 'scene-3d-json') {
          this.jsl.file_system.copyFolder(this.jsl.env.pathJoin(app_path, 'lib/three.js-r162'), this.jsl.env.pathJoin(file_path, 'res/three.js-r162'));
          presentation_scripts += `
  <script type="importmap">
    {
      "imports": {
        "three": "./res/three.js-r162/build/three.module.js",
        "three/addons/": "./res/three.js-r162/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three'; 
    window.THREE = THREE;
  </script>
`;
        }
      }        
    }
    var html = this.jsl.env.readFileSync(this.jsl.env.pathJoin(app_path, 'html/presentation.html')).toString();
    html = html.replace('%presentation_scripts%', presentation_scripts);
    html = html.replace('%presentation_stylesheets%', presentation_stylesheets);
    this.jsl.file_system.writeFile(this.jsl.env.pathJoin(file_path, 'index.html'), html);
    
    if(open_editor) {
      this.editPresentation(file_path);
    }
  }

  /**
   * Packages an existing presentation directory into a ZIP archive beside it.
   * @param {String} file_path - Path to the presentation directory to be archived.
   */
  packPresentation(file_path) {
    file_path = this._getPath('packPresentation', file_path);
    if(this._checkPresentation('packPresentation', file_path)) {
      var dest = this.jsl.env.pathResolve(this.jsl.env.pathJoin(file_path, '..', this.jsl.env.pathBaseName(file_path) + '.zip'));
      this.jsl.env.execSync(`${this.jsl.env.bin7zip} a -tzip "${dest}" "${this.jsl.env.pathJoin(file_path, '*')}"`);
      this.jsl.env.disp('@packPresentation: ' + language.string(241) + dest);
    }
  }

  /**
   * Converts an existing presentation to standalone presentation.
   * @param {String} file_path - Path to the presentation directory to be archived.
   */
  makeStandalonePresentation(file_path) {
    file_path = this._getPath('makeStandalonePresentation', file_path);
    if(this._checkPresentation('makeStandalonePresentation', file_path)) {
      var html_file = this.jsl.env.pathJoin(file_path, 'index.html');
      var html = this.jsl.env.readFileSync(html_file).toString();
      
      var reImagePdf = /<img-pdf\b[^>]*?\bsrc\s*=\s*["']([^"']+)["'][^>]*>/gi;
      var rePlotJson = /<plot-json\b[^>]*?\bsrc\s*=\s*["']([^"']+)["'][^>]*>/gi;
      var reScene3dJson = /<scene-3d-json\b[^>]*?\bsrc\s*=\s*["']([^"']+)["'][^>]*>/gi;
      
      var assets = new Set();
      for(var re of [reImagePdf, rePlotJson, reScene3dJson]) {
        let m;
        while((m = re.exec(html)) !== null) {
          var rel = m[1].trim();
          if(!rel) continue;
          assets.add(rel);
        }
      }

      for(var file of [...assets]) {
        this._fileToBuffer(file_path, file);
      }
    }
  }

  /**
   * Converts an presentation to PDF format.
   * @param {String} file_path - Path to the presentation directory.
   * @param {Boolean} run_make_standalone - Whether to run makeStandalonePresentation method or not.
   */
  async presentationToPdf(file_path, run_make_standalone = true) {
    file_path = this._getPath('presentationToPdf', file_path);
    if(this._checkPresentation('presentationToPdf', file_path)) {
      if(run_make_standalone) {
        this.makeStandalonePresentation(file_path);
      }
      var win = await this.openPresentation(file_path, 'standalone');
      var p = win.presentation;
      p._interpolateAllSlides();
      win.setSize(p.config.slide_width, p.config.slide_height);
      await waitMSeconds(200);
      while(typeof win.presentation == 'undefined') {
        await this.jsl.non_blocking.waitMSeconds(1);
      }
      win.setOpacity(0);
      for(var i = 0; i < win.presentation.total_slides; i++) {
        win.presentation.setSlide(i);
        await this._waitForSlide(win, win.presentation.slides[i]);
        await waitMSeconds(1);
      }
      win.presentation.setSlide(0);
      var pdf = await this.jsl.windows.printWindowToPdf(win.wid, {
        margins: { top: 0, right: 0, bottom: 0, left: 0 },
        printBackground: true,
        landscape: false,
        pageSize: {
          width: p.config.slide_width / 96, 
          height: p.config.slide_height / 96
        }
      });
      var name = this.jsl.env.pathBaseName(file_path);
      var dest = this.jsl.env.pathJoin(file_path, name + '.pdf');
      this.jsl.file_system.writeFile(dest, pdf);
      win.close();
      this.jsl.env.disp('@presentationToPdf: ' + language.string(244) + dest);
    }
  }
  
  /**
   * Waits for slide elements to be loaded
   * @param {Window} win - Window context with presentation.
   * @param {HTMLElement} slide - HTML element of slide.
   */
  async _waitForSlide(win, slide) {
    var img_pdfs = Array.from(slide.querySelectorAll('img-pdf'));
    var plot_jsons = Array.from(slide.querySelectorAll('plot-json'));
    var scene_3d_jsons = Array.from(slide.querySelectorAll('scene-3d-json'));
    for(var e of [...img_pdfs, ...plot_jsons]) {
      while(!e._finished_loading) {
        await waitMSeconds(1);
      }
    }
    var videos = Array.from(slide.querySelectorAll('video'));
    for(var v of videos) {
      await this._waitForVideo(v);
    }
    
    await this._replaceCanvases(win, slide);
  }
  
  /**
   * Waits for video elements to be loaded
   * @param {HTMLElement} slide - HTML element of video.
   */
  async _waitForVideo(video) {
    if(video.preload === 'none') {
      video.preload = 'auto';
      video.load();
    }

    await new Promise(resolve => {
      if(video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
        resolve();
      } else {
        video.addEventListener('loadeddata', resolve, { once: true });
      }
    });
    
    video.controls = false;
    video.muted = true;
    try { await video.play(); } catch { }
    video.pause();

    if('requestVideoFrameCallback' in video) {
      await new Promise(res => video.requestVideoFrameCallback(() => res()));
    } else {
      if(video.currentTime === 0) {
        video.currentTime = 0.05;
        video.currentTime = 0;
      }
    }
  }
  
  /**
   * Replaces all canvases with static images.
   * @param {Window} win - Window context with presentation.
   * @param {HTMLElement} slide - HTML element of slide.
   */
  async _replaceCanvases(win, slide) {
    var plot_divs = Array.from(slide.querySelectorAll('.js-plotly-plot'))
                         .filter(div => div.querySelector('canvas'));
    for(var plot_div of plot_divs) {
      var data_url;
      try {
        data_url = await win.Plotly.toImage(plot_div, {
          format : 'png',
          width  : plot_div.clientWidth  * win.devicePixelRatio,
          height : plot_div.clientHeight * win.devicePixelRatio
        });
      } catch(err) {}
      
      var img = new win.Image();
      img.src = data_url;
      img.style.width  = (plot_div.style.width  || plot_div.width  + 'px');
      img.style.height = (plot_div.style.height || plot_div.height + 'px');
      img.style.maxWidth  = '100%';
      img.style.maxHeight = '100%';
      plot_div.parentNode.replaceChild(img, plot_div);
      await waitMSeconds(1);
    }
  }
  
  /**
   * Resolves and returns a presentation directory path, prompting the user if necessary.
   * @param {String} method - Name of the calling method for error reporting.
   * @param {String} [file_path] - Candidate path supplied by the caller.
   * @returns {(String|false)} Resolved presentation directory path or false if cancelled.
   */
  _getPath(method, file_path) {
    if(!file_path) {
      var options = {
        title: language.currentString(239),
        buttonLabel: language.currentString(231),
        properties: ['openDirectory'],
      };
      file_path = this.jsl.env.showOpenDialogSync(options);
      if(file_path === undefined) {
        this.jsl.env.error('@' + method + ': '+language.string(119)+'.');
        return false;
      } else {
        file_path = file_path[0];
      }
    }    
    return file_path;
  }
  
  /**
   * Checks whether the supplied directory contains a valid presentation structure.
   * @param {String} method - Name of the calling method for error reporting.
   * @param {String} file_path - Path to the presentation directory to validate.
   * @returns {Boolean} True if the directory contains a `index.html` file, otherwise false.
   */
  _checkPresentation(method, file_path) {
    if(!this.jsl.file_system.existFile(this.jsl.env.pathJoin(file_path, 'index.html'))) {
      this.jsl.env.error('@' + method + ': '+language.string(240));
      return false;
    }
    return true;
  }
  
  /**
   * Starts the portable HTTP server that serves the presentation and
   * resolves once the server prints the listening URL.
   * @param {String} exe_file - Absolute path to the portable server executable.
   * @returns {Promise<String>} Resolves to the presentation URL.
   */
  _startPresentation(exe_file) {
    var obj = this;
    return new Promise((resolve, reject) => {
      const child = obj.jsl.env.spawn(exe_file, ['--prog'], {
        stdio: ['ignore', 'pipe', 'inherit']
      });
      
      let buffer = '';
      child.stdout.setEncoding('utf8');
      child.stdout.on('data', chunk => {
        buffer += chunk;
        const nl = buffer.indexOf('\n');
        if(nl !== -1) {
          let line = buffer.slice(0, nl).replace(/\r$/, '').trim();
          child.stdout.removeAllListeners('data');
          let url = line.replace(/^\s*url:/i, '');
          resolve(url);
        }
      });

      child.once('error', reject);
      child.once('exit', code => {
        reject(`Server exited early with code ${code}`);
      });
    });
  }
  
  /**
   * Convert file to JavaScript base64 buffer.
   * @param {String} file_path - Path to presentation.
   * @param {String} rel - Path to file.
   */
  _fileToBuffer(file_path, rel) {
    var abs = this.jsl.env.pathResolve(this.jsl.env.pathJoin(file_path, rel));
    var bin = this.jsl.env.readFileSync(abs);
    var b64  = bin.toString('base64');
    var name = encodeURIComponent(rel.replace(/\\/g, "/"));
    this.jsl.file_system.writeFile(abs + '.buf.js',
      'registerFile("'+name+'", "'+b64+'");');
  }
}

exports.PRDC_JSLAB_LIB_PRESENTATION = PRDC_JSLAB_LIB_PRESENTATION;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={render.js}]
/**
 * @file JSLAB library render submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB render submodule.
 */
class PRDC_JSLAB_LIB_RENDER {
  
  /**
   * Initializes a new instance of the render submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }
  
  /**
   * Debounces a function, ensuring it's only invoked once at the beginning of consecutive calls during the wait period.
   * @param {Function} func - The function to debounce.
   * @param {number} wait - The period to wait before allowing another call, in milliseconds.
   * @returns {Function} The debounced function.
   */
  debounceIn(func, wait) {
    var timeout;
    let last_args;
    
    return function(...args) {
      var context = this;
      last_args = args;
      var later = function() {
        timeout = null;
      };
      if(!timeout) {
        timeout = setTimeout(later, wait);
        func.apply(context, last_args);
      }
    };
  }

  /**
   * Debounces a function, calling it at the first and last of consecutive calls during the wait period.
   * @param {Function} func - The function to debounce.
   * @param {number} wait - The period to wait before allowing another call, in milliseconds.
   * @returns {Function} The debounced function.
   */
  debounceInOut(func, wait) {
    var timeout;
    var hit = false;
    let last_args;
    
    return function(...args) {
      var context = this;
      last_args = args;
      var later = function() {
        if(hit) {
          hit = false;
          func.apply(context, last_args);
          setTimeout(later, wait);
        } else {
          timeout = null;
        }
      };
      if(!timeout) {
        timeout = setTimeout(later, wait);
        func.apply(context, last_args);
      } else {
        hit = true;
      }
    };
  }

  /**
   * Debounces a function, ensuring it's only invoked once at the end of consecutive calls during the wait period.
   * @param {Function} func - The function to debounce.
   * @param {number} wait - The period to wait before allowing another call, in milliseconds.
   * @returns {Function} The debounced function.
   */
  debounceOut(func, wait) {
    var timeout;
    let last_args;
    
    return function(...args) {
      var context = this;
      last_args = args;
      var later = function() {
        timeout = null;
        func.apply(context, last_args);
      };
      if(!timeout) {
        timeout = setTimeout(later, wait);
      }
    };
  }
}

exports.PRDC_JSLAB_LIB_RENDER = PRDC_JSLAB_LIB_RENDER;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={serial-device.js}]
/**
 * @file JSLAB library serial device submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB serial device submodule.
 */
class PRDC_JSLAB_LIB_SERIAL_DEVICE {
  
  /**
   * Constructs a serial device submodule object with access to JSLAB's device functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }
  
  /**
   * Retrieves all available serial ports.
   * @returns {Promise<Array>} Resolves with an array of serial port info.
   */
  async listSerialPorts() {
    return await this.jsl.env.SerialPort.list();
  }
  
  /**
   * Checks if there is a USB device connected with the specified Vendor ID and Product ID.
   * @param {string} VID - Vendor ID of the USB device.
   * @param {string} PID - Product ID of the USB device.
   * @returns {boolean} True if the device is found, false otherwise.
   */
  async checkDeviceUSB(VID, PID){
    var devices = await this.listSerialPorts();
    if(Array.isArray(devices)) {
      if(this.jsl.debug) {
        this.jsl.env.disp('@checkDeviceUSB: ' + JSON.stringify(devices));
      }
      return devices.some(device => device.vendorId === VID && device.productId === PID);
    }
    return false; 
  }

  /**
   * Checks for a connected USB device by STM and an optional Product ID.
   * @param {string} [PID='5740'] - Product ID of the USB device, default is for Virtual COM Port.
   * @returns {boolean} True if the device is found, false otherwise.
   */
  async checkDeviceSTM(PID = '5740') {
    return await this.checkDeviceUSB('0483', PID);
  }
 
  /**
   * Checks if there is a USB device connected using a CH340 chip.
   * @returns {boolean} True if the device is found, false otherwise.
   */
  async checkDeviceCH340() {
    return await this.checkDeviceUSB('1A86', '7523');
  }
  
  /**
   * Opens a serial port.
   * @param {string} port - Port path.
   * @param {number} [baudrate=9600] - Baud rate.
   * @param {object} [opts={}] - Additional options.
   * @returns {SerialPort} The opened SerialPort instance.
   */
  connectSerialPorts(port_path, baudrate = 9600, opts_in = {}) {
    var opts = { 
      dataBits: 8, 
      parity: 'none', 
      stopBits: 1, 
      flowControl: false,
      ...opts_in
    }
    var port = new this.jsl.env.SerialPort({
      path: port_path,
      baudRate: baudrate,
      ...opts
    });
    port.on('open', function() {
      try {
        port.set({
          dtr: true,
          rts: false
        });
      } catch(err) {}
    });
    
    this.jsl.addForCleanup(this, function() {
      if(port && port.isOpen) {
        port.close();
      }
    });
    
    return port;
  }
  
  /**
   * Opens a window to choose a serial port.
   * @returns {Promise<string|false>}
   */
  async chooseSerialPort() {
    var context = await this.jsl.windows.openWindowBlank();
    context.setTitle('Choose serial port');
    var ports = await this.listSerialPorts();
    var ports_list = '';
    if(ports.length > 0) {
      for(var port of ports) {
        ports_list += `<li class="ui" port='${port.path}'>${port.friendlyName}</li>`;
      }
    } else {
      ports_list += '<li class="ui"><str sid="230"></str></li>'
    }
    context.document.body.innerHTML = `<ul class="ui">${ports_list}</ul>`;
    var win = this.jsl.windows.open_windows[context.wid];
    win._updateLanguage();
    win.addUI();
    context.setSize(300, 100);
    await this.jsl.non_blocking.waitMSeconds(30);
    var win_height = context.document.body.offsetHeight;
    context.setSize(300, (win_height > 500 ? 500 : win_height));
    
    
    if(ports.length == 0) {
      return false;
    } else {
      var returned = false;
      var p = new Promise((resolve, reject) => {
        context.document.querySelectorAll('li').forEach(function(li) {
          li.addEventListener('click', function(e) {
            if(!returned) {
              returned = true;
              resolve(this.getAttribute('port'));
              context.close();
            }
          });
        });
        win.onClosed = function() {
          if(!returned) {
            returned = true;
            resolve(false);
          }
        }
      });
      return await p;
    }
  }
  

  /**
   * Opens a window to choose serial options.
   * @returns {Promise<string|false>}
   */
  async chooseSerialOptions() {
    var context = await this.jsl.windows.openWindowBlank();
    context.setTitle('Choose serial options');
    var ports = await this.listSerialPorts();
    var ports_list = '';
    if(ports.length > 0) {
      for(var port of ports) {
        ports_list += `<option value='${port.path}'>${port.friendlyName}</option>`;
      }
    } else {
      ports_list += "<option value='' str='230'></option>"
    }
    context.document.body.innerHTML = `
    <label class="ui"><str sid="232"></str>:</label>
    <select class="ui" id="port">${ports_list}</select>
    <label class="ui"><str sid="233"></str>:</label>
    <input  class="ui"type="text" id="baudrate" str="233"></input>
    <button class="ui blue" id="choose"><str sid="231"></str></button>`;
    var win = this.jsl.windows.open_windows[context.wid];
    win._updateLanguage();
    win.addUI();
    context.setSize(400, 100);
    await this.jsl.non_blocking.waitMSeconds(30);
    var win_height = context.document.body.offsetHeight;
    context.setSize(400, (win_height > 500 ? 500 : win_height));
    
    if(ports.length == 0) {
      warn('@chooseSerialOptions: '+language.currentString(230));
      context.close();
      return [false, false];
    } else {
      var returned = false;
      var p = new Promise((resolve, reject) => {
        context.document.getElementById('choose').
            addEventListener('click', function(e) {
          if(!returned) {
            returned = true;
            resolve([context.document.getElementById('port').value, 
              Number(context.document.getElementById('baudrate').value)]);
            context.close();
          }
        });
        win.onClosed = function() {
          if(!returned) {
            returned = true;
            resolve([false, false]);
          }
        }
      });
      return await p;
    }
  }
  
  /**
   * Opens a serial terminal.
   * @param {string} port_path - The identifier or path of the serial port to connect to.
   * @param {number} [baudrate] - The communication speed in bits per second.
   * @param {Object} [opts={}] - An optional configuration object for additional settings.
   * @returns {Promise<Object>} A promise that resolves with the terminal context.
   */
  async openSerialTerminal(port_path, baudrate = 9600, opts = {}) {
    var obj = this;
    
    if(!baudrate) {
      baudrate = 9600;
    }
    
    this.port_path = port_path;
    this.baudrate = baudrate;
    this.opts = opts;
    
    var wid = this.jsl.windows.openWindow('serial_terminal.html');
    var win = this.jsl.windows.open_windows[wid];
    await win.ready;
    win.addUI();
    win.addScript("../js/windows/terminal.js");
    var context = win.context;
    context.setTitle(port_path + ' (' + baudrate + ') | Serial Terminal');
    context.setSize(500, 500);
    context.document.getElementById('terminal-title').innerText = 
      port_path + ' (' + baudrate + ')';
    win._updateLanguage();
    
    // Wait for terminal
    while(!context.terminal) {
      await waitMSeconds(1);
    }
    
    context.terminal.setOptions(opts);
    
    win.onClosed = function() {
      if(obj.port && obj.port.isOpen) {
        obj.port.close();
      }
      delete obj.port;
    }

    this.port = this.connectSerialPorts(port_path, baudrate);
    
    this.port.on('data', (data) => {
      var data_in = data;
      if(obj.opts && typeof obj.opts.decodeData == 'function') {
        data_in = obj.opts.decodeData(data);
      } else {
        data_in = data.toString('utf8');
      }
      if(data_in !== false) {
        if(Array.isArray(data_in) && data_in.length) {
          for(var message of data_in) {
            context.terminal.addMessage('', message);
          }
        } else {
          context.terminal.addMessage('', data_in);
        }
      }
    });
    
    function sendMessage() {
      var data_out_raw = context.terminal.message_input.value;
      var data_out;
      if(obj.opts && typeof obj.opts.encodeData == 'function') {
        data_out = obj.opts.encodeData(data_out_raw);
      } else {
        data_out = data_out_raw;
      }
      if(data_out !== false) {
        obj.port.write(data_out);
        context.terminal.message_input.value = '';
        context.terminal.autoResizeInput();
      }
    }
    
    context.terminal.message_input.addEventListener('keydown', function(e) {
      if(e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    context.document.getElementById('send-button')
        .addEventListener('click', function(e) {
      sendMessage();
    });
    
    context.document.getElementById('timestamp').addEventListener('click', () => {
      setTimeout(function() {
        win._updateLanguage();
      }, 30);
    });
    context.document.getElementById('autoscroll').addEventListener('click', () => {
      setTimeout(function() {
        win._updateLanguage();
      }, 30);
    });
    
    function saveLog() {
      let options = {
       title: language.currentString(58),
       defaultPath: 'terminal_'+ obj.jsl.time.getDateTimeStr() + '.log',
       buttonLabel: language.currentString(58),
       filters :[
        {name: 'Log', extensions: ['log', 'txt']},
        {name: 'All Files', extensions: ['*']}
       ]
      };
      var log_path = obj.jsl.env.showSaveDialogSync(options);
      if(log_path) {
        var data = context.terminal.getLog();
        obj.jsl.env.writeFileSync(log_path, data);
      }
    }
    context.document.getElementById('save-log').addEventListener('click', () => {
      saveLog();
    });
    
    return context;
  }
  
  /**
   * Prompts the user to choose serial options and opens a serial terminal if a valid port is selected.
   * @param {Object} [opts={}] - An optional configuration object for additional settings.
   * @returns {Promise<Object|undefined>} A promise that resolves with the terminal context if a serial port is chosen.
   */
  async chooseSerialTerminal(opts) {
    var [port, baudrate] = await this.chooseSerialOptions();
    if(port) {
      return await this.openSerialTerminal(port, baudrate, opts);
    }
  }
}

exports.PRDC_JSLAB_LIB_SERIAL_DEVICE = PRDC_JSLAB_LIB_SERIAL_DEVICE;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={sym-math.js}]
/**
 * @file JSLAB library symbolic submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB symbolic submodule.
 */
class PRDC_JSLAB_SYMBOLIC_MATH {
  
  /**
   * Constructs a symbolic submodule object with access to JSLAB's symbolic functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
    
    this.loaded = false;
    
    this._var_counter = 0;
    this._symbols = [];
  }
  
  /**
   * Loads the symbolic math libraries (SymPy and NumPy) using Pyodide.
   * Initializes the Python environment for symbolic computations.
   * @returns {Promise<void>} A promise that resolves when the libraries are loaded.
   */
  async load() {
    if(!this.loaded) {
      this.pyodide = await loadPyodide({ 
        indexURL: app_path+'/lib/sympy-0.26.2/'
      });
      await this.pyodide.loadPackage(['sympy', 'numpy'], { messageCallback: () => {}});
      this.loaded = true;
      this.pyodide.runPython('globals().clear()');
      this.pyodide.runPython(`
        from sympy import *
        import numpy as np
      `);
    }
  }
  
  /**
   * Generates the next unique variable name for symbolic expressions.
   * @returns {string} The next unique variable name (e.g., 'jslabVar1').
   */
  _nextVar() {
    this._var_counter += 1;
    return 'jslabVar'+this._var_counter;
  }
  
  /**
   * Creates a new symbolic variable with an optional name and value.
   * @param {string} [name] - The name of the symbolic variable. If undefined, a unique name is generated.
   * @param {*} [value] - The initial value of the symbolic variable.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The newly created symbolic variable.
   */
  _newSymbol(name, value) {
    if(typeof name == 'undefined') {
      name = this._nextVar();
    }
    var symbol = new PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL(name, value);
    this._symbols.push(symbol);
    return symbol;
  }
  
  /**
   * Retrieves the name of a symbolic variable.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} symbol - The symbolic variable or its name.
   * @returns {string} The name of the symbolic variable.
   */
  getSymbolName(symbol) {
    if(typeof symbol == 'object' && symbol.constructor.name === 'PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL') {
      return symbol.name;
    } else {
      return symbol;
    }
  }
  
  /**
   * Checks if the symbolic libraries are loaded. Throws an error if not.
   * @throws {Error} If the symbolic libraries are not loaded.
   */
  checkLoaded() {
    if(!this.loaded) {
      this.jsl.env.error('@sym: '+language.string(175));
    }
  }
  
  /**
   * Evaluates a Python code string within the symbolic math environment.
   * @param {string} code - The Python code to evaluate.
   * @returns {*} The result of the evaluated code.
   * @throws {Error} If there is an error during code evaluation.
   */
  eval(code) {
    this.checkLoaded();
    if(this.jsl.config.DEBUG_SYM_PYTHON_EVAL_CODE) {
      this.jsl._console.log('@sym: eval: ' + code);
    }
    try {
      return this.pyodide.runPython(code);
    } catch(err) {
      this.jsl.env.error('@sym: ' + err);
    }
    return false;
  }
  
  /**
   * Creates a single symbolic variable.
   * @param {string} name - The name of the symbolic variable.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The created symbolic variable.
   */
  sym(name) {
    this.checkLoaded();
    
    this.eval(`${name} = Symbol('${name}')`);
    return this._newSymbol(name, name);
  }
  
  /**
   * Creates multiple symbolic variables.
   * @param {string[]} names - An array of names for the symbolic variables.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL[]} An array of created symbolic variables.
   */
  syms(names) {
    var obj = this;
    this.checkLoaded();
    
    this.eval(`${names.join(', ')} = symbols('${names.join(' ')}')`);
    
    var symbols = [];
    names.forEach(function(name) {
      symbols.push(obj._newSymbol(name, name));
    });
    return symbols;
  }
  
  /**
   * Creates a symbolic matrix from a nested array expression.
   * @param {Array<Array<PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string|number>>} expr - The nested array representing the matrix.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The symbolic matrix.
   */
  mat(expr) {
    this.checkLoaded();
    
    expr = JSON.stringify(expr.map(row => row.map(el => this.getSymbolName(el)))).replaceAll('"', '');
    
    var symbol = this._newSymbol();
    symbol.setValue(this.eval(`
      ${symbol.name} = Matrix(${expr})
      ${symbol.name}
    `));
    return symbol;
  }
  
  /**
   * Multiplies multiple symbolic expressions.
   * @param {...PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string|number} args - The symbolic expressions to multiply.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The resulting symbolic expression after multiplication.
   */
  mul(...args) {
    var obj = this;
    this.checkLoaded();
    
    var expr = args
      .map(function(item) {
        return obj.getSymbolName(item);
      }).join(' * '); 
      
    var symbol = this._newSymbol();
    symbol.setValue(this.eval(`
      ${symbol.name} = ${expr}
      ${symbol.name}
    `));
    return symbol;
  }

  /**
   * Divides multiple symbolic expressions.
   * @param {...PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string|number} args - The symbolic expressions to divide.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The resulting symbolic expression after division.
   */
  div(...args) {
    var obj = this;
    this.checkLoaded();
    
    var expr = args
      .map(function(item) {
        return obj.getSymbolName(item);
      }).join(' / '); 
      
    var symbol = this._newSymbol();
    symbol.setValue(this.eval(`
      ${symbol.name} = ${expr}
      ${symbol.name}
    `));
    return symbol;
  }

  /**
   * Adds multiple symbolic expressions.
   * @param {...PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string|number} args - The symbolic expressions to add.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The resulting symbolic expression after addition.
   */
  plus(...args) {
    var obj = this;
    this.checkLoaded();
    
    var expr = args
      .map(function(item) {
        return obj.getSymbolName(item);
      }).join(' + '); 
      
    var symbol = this._newSymbol();
    symbol.setValue(this.eval(`
      ${symbol.name} = ${expr}
      ${symbol.name}
    `));
    return symbol;
  }

  /**
   * Subtracts multiple symbolic expressions.
   * @param {...PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string|number} args - The symbolic expressions to subtract.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The resulting symbolic expression after subtraction.
   */
  minus(...args) {
    var obj = this;
    this.checkLoaded();
    
    var expr = args
      .map(function(item) {
        return obj.getSymbolName(item);
      }).join(' - '); 
      
    var symbol = this._newSymbol();
    symbol.setValue(this.eval(`
      ${symbol.name} = ${expr}
      ${symbol.name}
    `));
    return symbol;
  }
  
  /**
   * Raises a symbolic expression to a power.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string|number} expr - The base expression.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string|number} n - The exponent.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The resulting symbolic expression after exponentiation.
   */
  pow(expr, n) {
    this.checkLoaded();
    
    expr = this.getSymbolName(expr);
    n = this.getSymbolName(n);
        
    var symbol = this._newSymbol();
    symbol.setValue(this.eval(`
      ${symbol.name} = ${expr}**${n}
      ${symbol.name}
    `));
    return symbol;
  }

  /**
   * Transposes a symbolic matrix expression.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} expr - The matrix expression to transpose.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The transposed matrix expression.
   */
  transp(expr) {
    this.checkLoaded();
    
    expr = this.getSymbolName(expr);
    
    var symbol = this._newSymbol();  
    symbol.setValue(this.eval(`
      ${symbol.name} = ${expr}.T
      ${symbol.name}
    `));
    return symbol;
  }
  
  /**
   * Computes the inverse of a symbolic matrix expression.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} expr - The matrix expression to invert.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The inverse of the matrix expression.
   */
  inv(expr) {
    this.checkLoaded();
    
    expr = this.getSymbolName(expr);
        
    var symbol = this._newSymbol();
    symbol.setValue(this.eval(`
      ${symbol.name} = ${expr}.inv()
      ${symbol.name}
    `));
    return symbol;
  }
  
  /**
   * Computes the determinant of a symbolic matrix expression.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} expr - The matrix expression whose determinant is to be computed.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The determinant of the matrix expression.
   */
  det(expr) {
    this.checkLoaded();
    
    expr = this.getSymbolName(expr);
        
    var symbol = this._newSymbol();
    symbol.setValue(this.eval(`
      ${symbol.name} = ${expr}.det()
      ${symbol.name}
    `));
    return symbol;
  }
  
  /**
   * Differentiates a symbolic expression with respect to a variable.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} expr - The expression to differentiate.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} x - The variable with respect to which differentiation is performed.
   * @param {number} [n=1] - The order of differentiation.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The differentiated expression.
   */
  diff(expr, x, n = 1) {
    this.checkLoaded();
    
    expr = this.getSymbolName(expr);
    
    var symbol = this._newSymbol();
    symbol.setValue(this.eval(`
      ${symbol.name} = diff(${expr}, ${x}, ${n})
      ${symbol.name}
    `));
    return symbol;
  }

  /**
   * Integrates a symbolic expression with respect to a variable.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} expr - The expression to integrate.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} x - The variable with respect to which integration is performed.
   * @param {Array<PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string>|undefined} lims - The limits of integration as [lower, upper]. If undefined, indefinite integration is performed.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The integrated expression.
   */
  intg(expr, x, lims) {
    this.checkLoaded();
    
    expr = this.getSymbolName(expr);
    x = this.getSymbolName(x);
    
    var symbol = this._newSymbol();
    if(lims) {
      lims[0] = this.getSymbolName(lims[0]);
      lims[1] = this.getSymbolName(lims[1]);
      symbol.setValue(this.eval(`
        ${symbol.name} = integrate(${expr}, (${x}, ${lims[0]}, ${lims[1]}))
        ${symbol.name}
      `));
    } else {
      symbol.setValue(this.eval(`
        ${symbol.name} = integrate(${expr}, ${x})
        ${symbol.name}
      `));
    }
    return symbol;
  }

  /**
   * Substitutes a value into a symbolic expression.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} expr - The expression in which to substitute.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} x - The variable to substitute.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string|number|Array} val - The value or array of values to substitute.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The expression after substitution.
   */
  subs(expr, x, val) {
    this.checkLoaded();
    
    expr = this.getSymbolName(expr);
    x = this.getSymbolName(x);
    
    var symbol = this._newSymbol();
    if(Array.isArray(val)) {
      val = JSON.stringify(val);
      symbol.setValue(this.eval(`
        ${symbol.name} = [${expr}.subs(${x}, val).evalf() for val in ${val}]
        ${symbol.name}
      `));
    } else {
      val = this.getSymbolName(val);
      if(isNumber(val)) {
        symbol.setValue(this.eval(`
          ${symbol.name} = ${expr}.subs(${x}, ${val}).evalf()
          ${symbol.name}
        `));
      } else {
        symbol.setValue(this.eval(`
          ${symbol.name} = ${expr}.subs(${x}, ${val})
          ${symbol.name}
        `));
      }
    }
    return symbol;
  }
  
  /**
   * Simplifies a symbolic expression.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} expr - The expression to simplify.
   * @returns {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL} The simplified expression.
   */
  simplify(expr) {
    this.checkLoaded();
    
    expr = this.getSymbolName(expr);
    
    var symbol = this._newSymbol();  
    symbol.setValue(this.eval(`
      ${symbol.name} = simplify(${expr})
      ${symbol.name}
    `));
    return symbol;
  }
  
  /**
   * Displays the LaTeX representation of a symbolic expression.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} expr - The expression to display in LaTeX format.
   */
  showLatex(expr) {
    expr = this.getSymbolName(expr);
    this.jsl.env.dispLatex(this.eval(`latex(${expr})`));
  }
  
  /**
   * Displays the LaTeX string of a symbolic expression.
   * @param {PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL|string} expr - The expression to convert to a LaTeX string.
   */
  dispLatex(expr) {
    expr = this.getSymbolName(expr);
    this.jsl.env.disp(this.eval(`latex(${expr})`));
  }
  
  /**
   * Clears all symbolic variables and resets the symbolic math environment.
   */
  clear() {
    if(this.loaded) {
      this.pyodide.runPython('globals().clear()');
      this.pyodide.runPython(`
        from sympy import *
        import numpy as np
      `);
      this._var_counter = 0;
      this._symbols = [];
    }
  }
}

exports.PRDC_JSLAB_SYMBOLIC_MATH = PRDC_JSLAB_SYMBOLIC_MATH;

/**
 * Class for JSLAB symbolic math symbol.
 */
class PRDC_JSLAB_SYMBOLIC_MATH_SYMBOL {
  
  /**
   * Constructs a symbolic math symbol with a name and initial value.
   * @constructor
   * @param {string} name - The name of the symbolic variable.
   * @param {*} value - The initial value of the symbolic variable.
   */
  constructor(name, value) {
    this.name = name;
    this.value = value;
  }
  
  /**
   * Sets the value of the symbolic variable.
   * @param {*} value - The new value to assign to the symbolic variable.
   */
  setValue(value) {
    this.value = value;
    this.parsed_value = parseString(value.toString());
  }

  /**
   * Returns a string representation of the vector.
   * @returns {string} The string representation in the format 'Vector(x:, y:, z:)'.
   */
  toString() {
    return 'Symbolic(' + JSON.stringify(this.toJSON(), null, 2) + ')';
  }

  /**
   * Converts the symbolic value to a numeric value.
   * @returns {*} The numeric representation of the symbolic value.
   */
  toNumeric() {
    return this.parsed_value;
  }
  
  /**
   * Converts the symbolic value to a JSON string.
   * @returns {string} The JSON string representation of the symbolic value.
   */
  toJSON() {
    if(typeof this.parsed_value == undefined) {
      return this.name;
    }
    return this.parsed_value;
  }
  
  /**
   * Converts the object to a safe JSON representation.
   * @returns {Object} The safe JSON representation of the object.
   */
  toSafeJSON() {
    return this.toJSON();
  }
  
  /**
   * Converts the object to a pretty string representation.
   * @returns {string} The pretty string representation of the object.
   */
  toPrettyString() {
    return this.toString();
  }
}

/**
 * Parses a string representation of Python objects into JavaScript objects.
 * Specifically handles conversion of SymPy Matrix objects to nested arrays.
 * @param {string} str - The string to parse.
 * @returns {Array<Array<*>>|Array<Array<Array<*>>>} The parsed JavaScript representation of the input string.
 */
function parseString(str) {
  // Remove any leading or trailing square brackets if the input is a list
  const trimmed_str = str.trim().replace(/^\[|\]$/g, '');

  // Find all occurrences of "Matrix([[...]])" using regex
  const matrix_regex = /Matrix\(\[\[(.*?)\]\]\)/g;
  const matrices = [];
  let match;

  // Iterate over all matches of the regex
  while((match = matrix_regex.exec(trimmed_str)) !== null) {
    // Each match's first capture group contains the matrix content
    const matrix_content = match[1];

    // Split rows by detecting "],[" pattern
    const rows = matrix_content.split(/\],\s*\[/);

    // For each row, split by commas while ignoring any spaces
    const parsed_rows = rows.map(row => row.split(',').map(entry => {
      const trimmed_entry = entry.trim();
      // Convert numeric strings to numbers
      return isNaN(trimmed_entry) ? trimmed_entry : Number(trimmed_entry);
    }));

    // Push the parsed rows (matrix) into the matrices array
    matrices.push(parsed_rows);
  }

  // If only one Matrix(...) was found, return the array directly instead of wrapping in another array
  return matrices.length === 1 ? matrices[0] : matrices;
}
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={system.js}]
/**
 * @file JSLAB library system submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB system submodule.
 */
class PRDC_JSLAB_LIB_SYSTEM {
  
  /**
   * Initializes a new instance of the system submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
  }

  /**
   * Executes a system command and returns the output.
   * @param {...*} args Command arguments.
   * @returns {string|boolean} The output of the command as a string, or false if an error occurred.
   */
  system(...args) {
    try {
      return this.jsl.env.execSync(...args).toString();
    } catch(err) {
      this.jsl.env.error('@system: '+err);
      return false;
    }
  }

  /**
   * Executes a system command.
   * @param {...*} args Command arguments.
   */
  exec(...args) {
    try {
      return this.jsl.env.exec(...args);
    } catch(err) {
      this.jsl.env.error('@exec: '+err);
      return false;
    }
  }

  /**
   * Executes a system command.
   * @param {...*} args Command arguments.
   */
  spawn(...args) {
    try {
      return this.jsl.env.spawn(...args);
    } catch(err) {
      this.jsl.env.error('@spawn: '+err);
      return false;
    }
  }
  
  /**
   * Retrieves a list of all running tasks on the system.
   * @returns {Array} An array containing the tasklist output or [false, []] if an error occurred.
   */
  getTaskList() {
    try {
      return this.jsl.env.execSync('tasklist').toString();
    } catch(err) {
      this.jsl.env.error('@getTaskList: '+err);
      return false;
    }
  }

  /**
   * Checks if a specific program is running and retrieves its process IDs.
   * @param {string} program_name - The name of the program to check.
   * @returns {Array} An array where the first element is a boolean indicating if the program is running, 
   *                  and the second element is an array of process IDs if the program is running.
   */
  isProgramRunning(program_name) {
    try {
      // Execute the tasklist command and get the output
      const output = this.jsl.env.execSync('tasklist').toString();
      
      // Convert the output to lowercase for case-insensitive comparison
      const output_lower = output.toLowerCase();
      const program_nameLower = program_name.toLowerCase();

      // Split the output into lines and filter the ones containing the program name
      const lines = output_lower.split('\n');
      const matching_lines = lines.filter(function(line) {
        return line.includes(program_nameLower);
      });

      // Extract PIDs from the matching lines
      const pids = matching_lines.map(line => {
        // Split the line by spaces and filter out empty elements
        const columns = line.trim().split(/\s+/);
        return parseInt(columns[1], 10); // PID is the second column
      }).filter(function(pid) { 
        return !isNaN(pid);
      }); // Filter out NaN values (if any)

      const is_running = pids.length > 0;
      return [is_running, pids];
    } catch(err) {
      this.jsl.env.error('@isProgramRunning: '+err);
      return [false, []];
    }
  }
  
  /**
   * Attempts to kill a process by its process ID.
   * @param {number} pid - The process ID of the process to kill.
   * @returns {string|boolean} The output of the kill command as a string, or false if an error occurred.
   */
  killProcess(pid) {
    try {
      // Execute the tasklist command and get the output
      return this.jsl.env.execSync('taskkill /pid '+pid+' /T /F').toString();
    } catch(err) {
      this.jsl.env.error('@killProcess: '+err);
      return false;
    }
  }
}

exports.PRDC_JSLAB_LIB_SYSTEM = PRDC_JSLAB_LIB_SYSTEM;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={time.js}]
/**
 * @file JSLAB library time submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB time submodule.
 */
class PRDC_JSLAB_LIB_TIME {
  
  /**
   * Initializes the time submodule, setting up properties for time tracking and exposing time measurement utilities.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;

    /**
     * Current timezone string.
     * @type {string}
     */
    this.timezone = 'Europe/Belgrade';
    
    /**
     * Last tic timestamp.
     * @type {number}
     */
    this.last_tic = 0;
    
    /**
     * Starts a timer for measuring elapsed time. To be used with `toc` to measure time intervals.
     * @name tic
     * @kind function
     * @memberof PRDC_JSLAB_LIB_TIME
     */
    Object.defineProperty(this.jsl.context, 'tic', {configurable: true, get: this._tic });
  }
  
  /**
   * Records the current wall-clock time to measure elapsed time.
   * @returns {number} The current wall-clock time in milliseconds.
   */
  _tic() {
    this.jsl.context.last_tic = performance.now()/1000; // [s]
    return this.jsl.context.last_tic;
  }

  /**
   * Calculates the wall-clock time elapsed since a specified start time or the last call to `tic()`, in seconds.
   * @param {number} [tic] - The start time in milliseconds from which to calculate elapsed time. If omitted, uses the last time recorded by `tic()`.
   * @returns {number} The elapsed time in seconds.
   */
  toc(tic) {
    var dt = performance.now()/1000;
    if(arguments.length < 1) {
      return dt-this.jsl.context.last_tic;
    } else {
      return dt-tic;
    } 
  }

  /**
   * Calculates the wall-clock time elapsed since a specified start time or the last call to `tic()`, in seconds.
   * @param {number} [tic] - The start time in milliseconds from which to calculate elapsed time. If omitted, uses the last time recorded by `tic()`.
   * @returns {number} The elapsed time in milliseconds.
   */
  tocms(tic) {
    if(!tic) {
      tic = global.last_tic;
    }
    return (performance.now()-tic*1000);
  }

  /**
   * Gets the current Unix timestamp adjusted for a specified timezone.
   * @returns {number} The current Unix timestamp as an integer.
   */
  getTimestamp() {
    return luxon.DateTime.now().setZone(this.timezone).toMillis();
  }

  /**
   * Gets the current time as a string adjusted for a specified timezone.
   * @returns {string} The current time in 'HH:mm:ss' format.
   */
  getTime() {
    return luxon.DateTime.now().setZone(this.timezone).toFormat('HH:mm:ss');
  }

  /**
   * Gets the current time with milliseconds as a string adjusted for a specified timezone.
   * @returns {string} The current time in 'HH:mm:ss.SSS' format.
   */
  getFullTime() {
    return luxon.DateTime.now().setZone(this.timezone).toFormat('HH:mm:ss.SSS');
  }

  /**
   * Gets the current date as a string adjusted for a specified timezone.
   * @returns {string} The current date in 'dd.MM.yyyy.' format.
   */
  getDate() {
    return luxon.DateTime.now().setZone(this.timezone).toFormat('dd.MM.yyyy.');
  }

  /**
   * Gets the current date and time as a string adjusted for a specified timezone.
   * @returns {string} The current date and time in 'dd.MM.yyyy. HH:mm:ss' format.
   */
  getDateTime() {
    return luxon.DateTime.now().setZone(this.timezone).toFormat('dd.MM.yyyy. HH:mm:ss');
  }

  /**
   * Gets the current date and time with milliseconds as a string adjusted for a specified timezone.
   * @returns {string} The current date and time in 'dd.MM.yyyy. HH:mm:ss.SSS' format.
   */
  getDateTimeFull() {
    return luxon.DateTime.now().setZone(this.timezone).toFormat('dd.MM.yyyy. HH:mm:ss.SSS');
  }

  /**
   * Gets the current date and time as a string suitable for filenames, adjusted for a specified timezone.
   * @returns {string} The current date and time in 'ddMMyyyy_HHmmss' format for use in filenames.
   */
  getDateTimeStr() {
    return luxon.DateTime.now().setZone(this.timezone).toFormat('ddMMyyyy_HHmmss');
  }
  
  /**
   * Sets the timezone to be used for time calculations and formatting. This method allows the application to adjust displayed times according to a specific timezone.
   * @param {String} tz The timezone identifier (e.g., "America/New_York", "Europe/Paris") to be set for all time-related operations.
   */
  setTimezone(tz) {
    this.timezone = tz;
  }
}

exports.PRDC_JSLAB_LIB_TIME = PRDC_JSLAB_LIB_TIME;
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={vector-math.js}]
/**
 * @file JSLAB library vector math submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB vector math submodule.
 */
class PRDC_JSLAB_VECTOR_MATH {

  /**
   * Constructs vector math submodule object with access to JSLAB's vector functions.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   */
  constructor(jsl) {
    this.jsl = jsl;
  }
  
  /**
   * Creates a new vector with specified x, y, z components.
   * @param {number} x - The x-component of the vector.
   * @param {number} y - The y-component of the vector.
   * @param {number} z - The z-component of the vector.
   * @returns {PRDC_JSLAB_VECTOR} A new vector instance.
   */
  new(x, y, z) {
    return new PRDC_JSLAB_VECTOR(this.jsl, x, y, z);
  }
  
  /**
   * Creates a vector from polar coordinates.
   * @param {number} length - The length of the vector.
   * @param {number} radian - The angle in radians.
   * @returns {PRDC_JSLAB_VECTOR} The resulting vector.
   */
  polar(length, radian) {
    const x = length * Math.cos(radian);
    const y = length * Math.sin(radian);
    const z = 0;
    return new PRDC_JSLAB_VECTOR(this.jsl, x, y, z);
  }
  
  /**
   * Creates a vector from spherical coordinates.
   * @param {number} length - The length (magnitude) of the vector.
   * @param {number} azimuth - The azimuth angle in radians (angle from the X-axis in the XY plane).
   * @param {number} elevation - The elevation angle in radians (angle from the XY plane towards Z).
   * @returns {PRDC_JSLAB_VECTOR} The resulting vector.
   */
  spherical(length, azimuth, elevation) {
    const x = length * Math.cos(elevation) * Math.cos(azimuth);
    const y = length * Math.cos(elevation) * Math.sin(azimuth);
    const z = length * Math.sin(elevation);
    return new PRDC_JSLAB_VECTOR(this.jsl, x, y, z);
  }
}

exports.PRDC_JSLAB_VECTOR_MATH = PRDC_JSLAB_VECTOR_MATH;

/**
 * Class for JSLAB vector.
 */
class PRDC_JSLAB_VECTOR {
  
  #jsl;
  
  /**
   * Creates a new vector instance.
   * @constructor
   * @param {Object} jsl - Reference to the main JSLAB object.
   * @param {number|Object} x - The x-component or an object with x, y, z properties.
   * @param {number} [y=0] - The y-component of the vector.
   * @param {number} [z=0] - The z-component of the vector.
   */
  constructor(jsl, x, y, z) {
    this.#jsl = jsl;
    this._set(x, y, z);
  }
  
  /**
   * Sets the components of the vector.
   * @param {number|Object} x - The x-component or an object with x, y, z properties.
   * @param {number} [y=0] - The y-component of the vector.
   * @param {number} [z=0] - The z-component of the vector.
   * @returns {PRDC_JSLAB_VECTOR} The updated vector instance.
   */
  _set(x, y, z) {
    if(Array.isArray(x)) {
      z = x[2];
      y = x[1];
      x = x[0];
    } else if(isObject(x)) {
      z = x.z;
      y = x.y;
      x = x.x;
    }
    
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  }

  /**
   * Calculates the length (magnitude) of the vector.
   * @returns {number} The length of the vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }

  /**
   * Calculates the length (magnitude) of the vector.
   * @returns {number} The length of the vector.
   */
  norm() {
    return this.length();
  }
  
  /**
   * Adds two vectors and returns the result.
   * @param {PRDC_JSLAB_VECTOR} v - The second vector.
   * @returns {PRDC_JSLAB_VECTOR} The resulting vector after addition.
   */
  add(v) {
    return this.#jsl.vec.new(this.x + v.x, this.y + v.y, this.z + v.z);
  }

  /**
   * Adds two vectors and returns the result.
   * @param {PRDC_JSLAB_VECTOR} v - The second vector.
   * @returns {PRDC_JSLAB_VECTOR} The resulting vector after addition.
   */
  plus(v) {
    return this.add(v);
  }
  
  /**
   * Subtracts the second vector from the first and returns the result.
   * @param {PRDC_JSLAB_VECTOR} v - The vector to subtract.
   * @returns {PRDC_JSLAB_VECTOR} The resulting vector after subtraction.
   */
  subtract(v) {
    return this.#jsl.vec.new(this.x - v.x, this.y - v.y, this.z - v.z);
  }

  /**
   * Subtracts the second vector from the first and returns the result.
   * @param {PRDC_JSLAB_VECTOR} v - The vector to subtract.
   * @returns {PRDC_JSLAB_VECTOR} The resulting vector after subtraction.
   */
  minus(v) {
    return this.subtract(v);
  }
  
  /**
   * Scales a vector by the given factors.
   * @param {number|Object} scale_x - The scale factor for the x-component or an object with x, y, z properties.
   * @param {number} [scale_y] - The scale factor for the y-component.
   * @param {number} [scale_z] - The scale factor for the z-component.
   * @returns {PRDC_JSLAB_VECTOR} The scaled vector.
   */
  scale(scale_x, scale_y, scale_z) {
    if(isObject(scale_x)) {
      scale_x = scale_x.x;
      scale_y = scale_x.y;
      scale_z = scale_x.z;
    } else if(!isNumber(scale_y)) {
      scale_y = scale_x;
      scale_z = scale_x;
    }
    return this.#jsl.vec.new(this.x * scale_x, this.y * scale_y, this.z * scale_z);
  }
  
  /**
   * Scales a vector by the given factor.
   * @param {number} s - The scale factor.
   * @returns {PRDC_JSLAB_VECTOR} The scaled vector.
   */
  multiply(s) {
    return this.scale(s);
  }
  
  /**
   * Scales a vector by dividing each element by given factor.
   * @param {number} s - The scale factor.
   * @returns {PRDC_JSLAB_VECTOR} The scaled vector.
   */
  divide(s) {
    return this.scale(1 / s);
  }
  
  /**
   * Checks if two vectors are equal.
   * @param {PRDC_JSLAB_VECTOR} v - The second vector.
   * @returns {boolean} True if vectors are equal, false otherwise.
   */
  equals(v) {
    return this.x == v.x && this.y == v.y && this.z == v.z;
  }

  /**
   * Calculates the angle of a vector.
   * @param {PRDC_JSLAB_VECTOR} v - The vector.
   * @returns {number} The angle in degrees.
   */
  angleTo(v) {
    let cos_theta = this.dot(v) / (this.norm() * v.norm());
    return Math.acos(cos_theta) * (180 / Math.PI);
  }

  /**
   * Projects vector to given vector.
   * @param {PRDC_JSLAB_VECTOR} v - The vector.
   * @returns {PRDC_JSLAB_VECTOR} The projected vector.
   */
  projectTo(v) {
    return v.multiply(this.dot(v) / Math.pow(v.norm(), 2));
  }
  
  /**
   * Calculates the angles of a vector.
   * @param {PRDC_JSLAB_VECTOR} v - The vector.
   * @returns {Array} The angles azimuth and elevation in degrees.
   */
  angles() {
    const length_xy = Math.sqrt(this.x * this.x + this.y * this.y);
    const azimuth = Math.atan2(this.y, this.x) * (180 / Math.PI);
    const elevation = Math.atan2(this.z, length_xy) * (180 / Math.PI);
    return [ azimuth, elevation ];
  }
  
  /**
   * Calculates the distance between two vectors.
   * @param {PRDC_JSLAB_VECTOR} v - The second vector.
   * @returns {number} The distance between the two vectors.
   */
  distance(v) {
    var a = this.x - v.x;
    var b = this.y - v.y;
    var c = this.z - v.z;
    return Math.sqrt(a * a + b * b + c * c);
  }
  
  /**
   * Calculates the dot product of two vectors.
   * @param {PRDC_JSLAB_VECTOR} v - The second vector.
   * @returns {number} The dot product.
   */
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  
  /**
   * Calculates the cross product of two vectors.
   * @param {PRDC_JSLAB_VECTOR} v - The second vector.
   * @returns {PRDC_JSLAB_VECTOR} The cross product vector.
   */
  cross(v) {
    var cross_x = this.y * v.z - this.z * v.y;
    var cross_y = this.z * v.x - this.x * v.z;
    var cross_z = this.x * v.y - this.y * v.x;
    return this.#jsl.vec.new(cross_x, cross_y, cross_z);
  }
  
  /**
   * Interpolates between two vectors by a factor.
   * @param {PRDC_JSLAB_VECTOR} v - The ending vector.
   * @param {number} f - The interpolation factor.
   * @returns {PRDC_JSLAB_VECTOR} The interpolated vector.
   */
  interpolate(v, f) {
    var dx = v.x - this.x;
    var dy = v.y - this.y;
    var dz = v.y - this.y;
    return this.#jsl.vec.new(this.x + dx * f, this.y + dy * f, this.z + dz * f);
  }
  
  /**
   * Offsets the vector by the given amounts.
   * @param {number|Object} x - The amount to offset in the x-direction or an object with x, y, z properties.
   * @param {number} [y=0] - The amount to offset in the y-direction.
   * @param {number} [z=0] - The amount to offset in the z-direction.
   * @returns {PRDC_JSLAB_VECTOR} The updated vector instance.
   */
  offset(x, y, z) {
    if(isObject(x)) {
      x = x.x;
      z = x.z;
      y = x.y;
    }
    
    x = this.x + x || 0;
    y = this.y + y || 0;
    z = this.z + z || 0;
    
    return this.#jsl.vec.new(x, y, z);
  }
  
  /**
   * Normalizes the vector to have a length of 1.
   * @returns {PRDC_JSLAB_VECTOR} The normalized vector.
   */
  normalize() {
    var length = this.length();
    
    if(length > 0) {
      var x = this.x / length;
      var y = this.y / length;
      var z = this.z / length;
      return this.#jsl.vec.new(x, y, z);
    }
    return this.clone();
  }
  
  /**
   * Negates the vector components.
   * @returns {PRDC_JSLAB_VECTOR} The negated vector.
   */
  negate() {
    var x = this.x * -1;
    var y = this.y * -1;
    var z = this.z * -1;
    
    return this.#jsl.vec.new(x, y, z);
  }
  
  /**
   * Creates a clone of this vector.
   * @returns {PRDC_JSLAB_VECTOR} A new vector instance with the same components.
   */
  clone() {
    return this.#jsl.vec.new(this.x, this.y, this.z);
  }
  
  /**
   * Converts the vector to an array.
   * @returns {number[]} An array containing the x, y, z components of the vector.
   */
  toArray() {
    return [this.x, this.y, this.z];
  }

  /**
   * Converts the vector to a matrix.
   * @returns {Object} A matrix representation of the vector.
   */
  toMatrix() {
    return this.#jsl.mat.new([this.x, this.y, this.z], 3, 1);
  }

  /**
   * Converts the vector to a column matrix.
   * @returns {Object} A column matrix representation of the vector.
   */
  toColMatrix() {
    return this.#jsl.mat.new([this.x, this.y, this.z], 1, 3);
  }

  /**
   * Converts the vector to a row matrix.
   * @returns {Object} A row matrix representation of the vector.
   */
  toRowMatrix() {
    return this.toMatrix();
  }
  
  /**
   * Returns a string representation of the vector.
   * @returns {string} The string representation in the format 'Vector(x:, y:, z:)'.
   */
  toString() {
    return 'Vector([' + this.x + ', ' + this.y + ', ' + this.z + '])';
  }
  
  /**
   * Returns a string representation of the vector.
   * @returns {string} The string representation in the format 'Vector(x:, y:, z:)'.
   */
  toJSON() {
    return { x: this.x, y: this.y, z: this.z };
  }
  
  /**
   * Returns a string representation of the vector.
   * @returns {string} The string representation in the format 'Vector(x:, y:, z:)'.
   */
  toSafeJSON() {
    return this.toJSON();
  }
  
  /**
   * Converts the object to a pretty string representation.
   * @returns {string} The pretty string representation of the object.
   */
  toPrettyString() {
    return this.toString();
  }
}

\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={windows.js}]
/**
 * @file JSLAB library windows submodule
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB windows submodule.
 */
class PRDC_JSLAB_LIB_WINDOWS {
  
  /**
   * Initializes a new instance of the windows submodule.
   * @param {Object} jsl Reference to the main JSLAB object.
   */
  constructor(jsl) {
    var obj = this;
    this.jsl = jsl;
    this._wid = 0;

    /**
     * Current active window ID.
     * @type {Number}
     */
    this.active_window;
    
    /**
     * Array of open windows.
     * @type {Array}
     */
    this.open_windows = {};
  }

  /**
   * Opens a new window with the specified file.
   * @param {string} file - The path to the HTML file to open in the new window.
   * @returns {number} The identifier (wid) of the newly opened window.
   */
  openWindow(file) {
    if(!this.jsl.env.pathIsAbsolute(file)) {
      file = app_path + '/html/' + file;
    }
    
    if(!this.jsl.env.checkFile(file)) {
      this.jsl.env.error('@openWindow: '+language.string(199));
    }
    
    this._wid += 1;
    var wid = this._wid;
    this.open_windows[wid] = new PRDC_JSLAB_WINDOW(this.jsl, wid);
    this.open_windows[wid].open(file);
    this._setActiveWindow(wid);
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
    return wid;
  }
  
  /**
   * Opens the developer tools for a specified window by ID if it exists.
   * @param {string} wid - The window ID.
   * @returns {boolean} True if the developer tools were opened; otherwise, false.
   */
  openWindowDevTools(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].openDevTools();
    } else {
      return false;
    }
  }

  /**
   * Returns media source id for a specified window in the renderer process.
   * @param {string} wid - The window ID.
   * @returns {String|boolean} Media source id if there is window; otherwise, false.
   */
  getWindowMediaSourceId(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].getMediaSourceId();
    } else {
      return false;
    }
  }

  /**
   * Starts video recording of the window.
   * @param {string} wid - The window ID.
   * @param {Object} - Optional settings. 
   * @returns {Object|boolean} - Returns recorder object if there is window; otherwise, false.
   */
  startWindowVideoRecording(wid, opts) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].startVideoRecording(opts);
    } else {
      return false;
    }
  }
  
  /**
   * Closes the specified window.
   * @param {number} wid - Identifier for the window to close.
   */
  closeWindows(wid) {
    this.jsl.env.closeWindow(wid);
    this.jsl.no_ans = true;
    this.jsl.ignore_output = true;
  }
  
  /**
   * Closes the specified window.
   * @param {number} wid - Identifier for the window to close.
   */
  closeWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].close();
    } else {
      return false;
    }
  }
  
  /**
   * Retrieves the window object with the specified ID.
   * @param {number} wid - The ID of the window.
   * @returns {Object|boolean} - The window object if found, otherwise false.
   */
  getWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid];
    } else {
      return false;
    }
  }

  /**
   * Retrieves current active window object.
   * @returns {Object|boolean} - The window object if found, otherwise false.
   */
  getCurrentWindow() {
    if(this.open_windows.hasOwnProperty(this.active_window)) {
      return this.open_windows[this.active_window];
    } else {
      return false;
    }
  }

  /**
   * Retrieves current active window object.
   * @returns {Object|boolean} - The window object if found, otherwise false.
   */
  gcw() {
    return this.getCurrentWindow();
  }

  /**
   * Shows the specified window.
   * @param {number} wid - The ID of the window to show.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the show() method.
   */
  showWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].show();
    } else {
      return false;
    }
  }
  
  /**
   * Hides the specified window.
   * @param {number} wid - The ID of the window to hide.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the hide() method.
   */
  hideWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].hide();
    } else {
      return false;
    }
  }
  
  /**
   * Brings the specified window to the foreground.
   * @param {number} wid - The ID of the window to focus.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  focusWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].focus();
    } else {
      return false;
    }
  }
  
  /**
   * Minimizes the specified window.
   * @param {number} wid - The ID of the window to minimize.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the minimize() method.
   */
  minimizeWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].minimize();
    } else {
      return false;
    }
  }
  
  /**
   * Centers the specified window on the screen.
   * @param {number} wid - The ID of the window to center.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the center() method.
   */
  centerWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].center();
    } else {
      return false;
    }
  }
  
  /**
   * Moves the specified window to the top of the window stack.
   * @param {number} wid - The ID of the window to move to the top.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the moveTop() method.
   */
  moveTopWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].moveTop();
    } else {
      return false;
    }
  }
  
  /**
   * Sets the size of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} width - The new width of the window.
   * @param {number} height - The new height of the window.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  setWindowSize(wid, width, height) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].setSize(width, height);
    } else {
      return false;
    }
  }
  
  /**
   * Sets the position of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} left - The new left position of the window.
   * @param {number} top - The new top position of the window.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  setWindowPos(wid, left, top) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].setPos(left, top);
    } else {
      return false;
    }
  }

  /**
   * Sets the resizable state of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {boolean} state - Whether the window should be resizable.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the setResizable() method.
   */
  setWindowResizable(wid, state) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].setResizable(state);
    } else {
      return false;
    }
  }
  
  /**
   * Sets the movable state of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {boolean} state - Whether the window should be movable.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the setMovable() method.
   */
  setWindowMovable(wid, state) {
    if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].setMovable(state);
    } else {
      return false;
    }
  }
  
  /**
   * Sets the aspect ratio of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} aspect_ratio - The desired aspect ratio of the window.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the setAspectRatio() method.
   */
  setWindowAspectRatio(wid, aspect_ratio) {
    if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].setAspectRatio(aspect_ratio);
    } else {
      return false;
    }
  }
  
  /**
   * Sets the opacity of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} opacity - The desired opacity level (0 to 1).
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the setOpacity() method.
   */
  setWindowOpacity(wid, opacity) {
    if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].setOpacity(opacity);
    } else {
      return false;
    }
  }
  
  /**
   * Sets the fullscreen state of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} state - The fullscreen state
   * @returns {boolean|undefined} - Returns false if the window ID is invalid, otherwise the result of the setFullscreen() method.
   */
  setWindowFullscreen(wid, state) {
    if(this.jsl.windows.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].setFullscreen(state);
    } else {
      return false;
    }
  }
  
  /**
   * Sets the position of the specified window.
   * @param {number} wid - The ID of the window.
   * @param {number} left - The new left position of the window.
   * @param {number} top - The new top position of the window.
   * @returns {boolean|undefined} - Returns false if the window ID is invalid.
   */
  setWindowTitle(wid, title) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].setTitle(title);
    } else {
      return false;
    }
  }
  
  /**
   * Retrieves the size of the specified window.
   * @param {number} wid - The ID of the window.
   * @returns {Array|boolean} - An array [width, height] if the window exists, otherwise false.
   */
  getWindowSize(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].getSize();
    } else {
      return false;
    }
  }
  
  /**
   * Retrieves the position of the specified window.
   * @param {number} wid - The ID of the window.
   * @returns {Array|boolean} - An array [left, top] if the window exists, otherwise false.
   */
  getWindowPos(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].getPos();
    } else {
      return false;
    }
  }

  /**
   * Prints window to PDF format.
   * @param {string} wid - The window ID.
   * @param {Object} options - Options for printing
   * @returns {Buffer} Generated PDF data.
   */
  printWindowToPdf(wid, options) {
    if(this.open_windows.hasOwnProperty(wid)) {
      return this.open_windows[wid].printToPdf(options);
    } else {
      return false;
    }
  }
  
  /**
   * Opens window with documentation
   */
  async openDocumentation(query) {
    var wid = this.openWindow('../docs/documentation.html');
    var win = this.open_windows[wid];
    await win.ready;
    if(query) {
      win.context.location.href = '../docs/documentation.html#'+encodeURI(query);
      win.context.location.reload(true);
    }
    win.setTitle('JSLAB / DOCUMENTATION');
  }
  
  /**
   * Opens window with documentation
   */
  async openDoc(query) {
    await this.openDocumentation(query);
  }
  
  /**
   * Opens a new 3D window and imports specified modules.
   * @param {Array<Object>} [imports=[]] - An array of import objects specifying modules to import.
   * @returns {Promise<Object>} A promise that resolves to the window object once imports are ready.
   */
  async openWindow3D(imports = []) {
    var obj = this;
    var wid = this.openWindow('three.html');
    await this.open_windows[wid].ready;
    var context = this.open_windows[wid].context;
    var script = context.document.createElement('script');
    script.type = 'module';

    const import_statements = [];
    const window_assignments = [];
    var imports_array = [{import: '*', as: 'THREE', from: 'three'}];
    imports_array.push(...imports);
    
    imports_array.forEach((item) => {
      const { import: imported, as, from } = item;

      if(imported === '*') {
        if(!as) {
          this.jsl.env.error('@openWindow3D: '+language.string(200)+from+'.');
        }
        // Namespace import
        import_statements.push(`import * as ${as} from '${from}';`);
        window_assignments.push(`window.${as} = ${as};`);
      } else if(Array.isArray(imported)) {
        // Named imports with multiple specifiers
        const specifiers = imported.join(', ');
        import_statements.push(`import { ${specifiers} } from '${from}';`);
        imported.forEach((spec) => {
          window_assignments.push(`window.${spec} = ${spec};`);
        });
      } else {
        // Single named import
        import_statements.push(`import { ${imported} } from '${from}';`);
        window_assignments.push(`window.${imported} = ${imported};`);
      }
    });
    
    script.textContent = `${import_statements.join('\n')}\n\n${window_assignments.join('\n')}\n window.imports_ready = true;`;
    
    context.imports_ready = false;
    context.document.body.appendChild(script);
    while(!context.imports_ready) {
      await this.jsl.non_blocking.waitMSeconds(1);
    }
    context.sceneToJSON = function(file_path, scene = context.scene) {
      if(!scene) return;
      if(!file_path) {
        let options = {
         title: language.currentString(144),
         defaultPath: 'window-3d.json',
         buttonLabel: language.currentString(144),
         filters :[
          {name: 'json', extensions: ['json']},
         ]
        };
        file_path = obj.jsl.env.showSaveDialogSync(options);
        if(!file_path) return;
      }
      var scene_json = scene.toJSON();
      obj.jsl.env.writeFileSync(file_path, JSON.stringify(scene_json));
    }
    
    context.sceneFromJSON = function(file_path) {
      if(!file_path) {
        var options = {
          title: language.currentString(247),
          buttonLabel: language.currentString(231)
        };
        file_path = obj.jsl.env.showOpenDialogSync(options);
        if(file_path === undefined) {
          obj.jsl.env.error('@openWindow3D.fromJSON: '+language.string(132)+'.');
          return false;
        } else {
          file_path = file_path[0];
        }
      }    
      if(!obj.jsl.file_system.existFile(pwd + file_path)) {
        obj.jsl.env.error('@openWindow3D.fromJSON: '+language.string(248));
        return false;
      }
      var data = JSON.parse(obj.jsl.env.readFileSync(pwd + file_path).toString());

      const loader = new context.THREE.ObjectLoader();
      return loader.parse(data)
    }
    return context;
  }

  /**
   * Opens a Plotly.js window and initializes the plot container.
   * @returns {Promise<Window>} The window object where Plotly.js is loaded and the plot container is available.
   */
  async openPlotlyjs() {
    var wid = this.openWindow('plotlyjs.html');
    await this.open_windows[wid].ready;
    var context = this.open_windows[wid].context;
    context.imports_ready = false;
    while(!context.imports_ready) {
      if(typeof context.Plotly != 'undefined') {
        context.imports_ready = true;
      }
      await this.jsl.non_blocking.waitMSeconds(1);
    }
    context.plot_cont = context.document.getElementById('plot-cont');
    context.plot_cont.style = 'position: absolute;top:0;left:0;right:0;bottom:0;';
    return context;
  }

  /**
   * Opens a window with canvas and D3 and initializes the canvas element.
   * @returns {Promise<Window>} The window object where D3 is loaded and the canvas element is available.
   */
  async openCanvas() {
    var wid = this.openWindow('d3.html');
    await this.open_windows[wid].ready;
    var context = this.open_windows[wid].context;
    context.imports_ready = false;
    while(!context.imports_ready) {
      if(typeof context.d3 != 'undefined') {
        context.imports_ready = true;
      }
      await this.jsl.non_blocking.waitMSeconds(1);
    }
    context.svg = context.document.getElementById('d3-svg');
    context.canvas = context.document.getElementById('d3-canvas');
    context.svg.style = 'position: absolute;top:0;left:0;right:0;bottom:0;';
    context.canvas.style = 'position: absolute;top:0;left:0;right:0;bottom:0;';
    return context;
  }
  
  /**
   * Opens a new blank window.
   * @returns {Promise<Object>} A promise that resolves to the window object once it is ready.
   */
  async openWindowBlank() {
    var wid = this.openWindow('blank.html');
    await this.open_windows[wid].ready;
    var context = this.open_windows[wid].context;
    context.document.custom_style = context.document.getElementById('custom-style');
    return context;
  }
  
  /**
   * Renders a Mermaid diagram in a new window.
   * @param {string} graph_definition - The Mermaid graph definition.
   * @returns {Promise<Object>} A promise that resolves to the window context once the graph is rendered.
   */
  async showMermaidGraph(graph_definition) {
    var wid = this.openWindow('mermaid_graph.html');
    await this.open_windows[wid].ready;
    var context = this.open_windows[wid].context;
    context.document.custom_style = context.document.getElementById('custom-style');
    var graph = context.document.getElementById('graph');
    while(!graph.svg_viewer) {
      await this.jsl.non_blocking.waitMSeconds(1);
    }
    context.showGraph = async function(graph_definition) {
      try {
        var res = await context.mermaid.parse(graph_definition);
        if(res) {
          var { svg } = await context.mermaid.render('id1', graph_definition);
          graph.innerHTML = svg;
          graph.svg_viewer.attach();
          graph.style.display = 'block';
        }
      } catch(err) {
        error('@showGraph: '+err);
      }
    }
    await context.showGraph(graph_definition);
    return context;
  }
  
  /**
   * Sets the specified window as the active window.
   * @param {number} wid - The identifier of the window to set as active.
   */
  _setActiveWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      this.active_window = wid;
    } else {
      this.active_window = -1;
    }
  }
  
  /**
   * Updates the language of the text elements within all open windows.
   */
  _updateLanguage() {
    Object.values(this.open_windows).forEach(function(win) {
      win._updateLanguage(false);
    });
  }

  /**
   * Closes a window identified by the given ID and updates the active window if necessary.
   * @param {number} wid - The identifier of the window to close.
   */
  _closedWindow(wid) {
    if(this.open_windows.hasOwnProperty(wid)) {
      var new_wid = -1;
      if(this.active_window == wid) {
        var wids = Object.keys(this.open_windows);
        var N = wids.length;
        if(N > 1) {
          if(wids[N-1] !== wid) {
            new_wid = wids[N-1];
          } else {
            new_wid = wids[N-2];
          }
        }
        this._setActiveWindow(new_wid);
      }
      this.open_windows[wid].onClosed();
      delete this.open_windows[wid];
    }
  }
}

exports.PRDC_JSLAB_LIB_WINDOWS = PRDC_JSLAB_LIB_WINDOWS;

/**
 * Class for JSLAB window.
 */
class PRDC_JSLAB_WINDOW {
  
  #jsl;
  
  /**
   * Initializes a new instance of the JSLAB window.
   * @param {Object} jsl - Reference to the main JSLAB object.
   * @param {number} wid - Identifier for the window.
   */
  constructor(jsl, wid) {
    var obj = this;
    
    this.#jsl = jsl;
    this.wid = wid;

    this.context;
    this.dom;
    
    this.opened = false;
    this.ready = new Promise((resolve) => {
      obj._readyResolve = resolve;
    });
    
    this.onClosed = function() {};
  }

  /**
   * Opens the window with the specified file or url.
   * @param {string} file - The path to the HTML file or url to open in the window.
   * @returns {Promise<void>} A promise that resolves when the window is opened and ready.
   */
  async open(file) {
    if(!this.opened) {
      var obj = this;
      this.opened = true;
      var [context, ready] = this.#jsl.env.openWindow(this.wid, file);
      this.context = context;
      this.context.getWindow = function() {
        return obj;
      }
      await ready;
      this.dom = this.context.document;
      this._onReady();
    }
  }
  
  /**
   * Shows the window.
   * @returns {Promise<boolean|undefined>} - Resolves to `true` if the window was shown successfully, or `false` if the window ID is invalid.
   */
  async show() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.showWindow(this.wid);
  }

  /**
   * Hides the window.
   * @returns {Promise<boolean|undefined>} - Resolves to `true` if the window was hidden successfully, or `false` if the window ID is invalid.
   */
  async hide() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.hideWindow(this.wid);
  }
  
  /**
   * Brings focus to the window.
   * @returns {Promise} - Resolves when the window size is focused.
   */
  async focus() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.focusWindow(this.wid);
  }

  /**
   * Minimizes the window.
   * @returns {Promise<boolean|undefined>} - Resolves to `true` if the window was minimized successfully, or `false` if the window ID is invalid.
   */
  async minimize() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.minimizeWindow(this.wid);
  }

/**
 * Centers the window on the screen.
 * @returns {Promise<boolean|undefined>} - Resolves to `true` if the window was centered successfully, or `false` if the window ID is invalid.
 */
  async center() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.centerWindow(this.wid);
  }

  /**
   * Moves the window to the top of the window stack.
   * @returns {Promise<boolean|undefined>} - Resolves to `true` if the window was moved to the top successfully, or `false` if the window ID is invalid.
   */
  async moveTop() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.moveTopWindow(this.wid);
  }
  
  /**
   * Sets the size of the current window.
   * @param {number} width - The desired width of the window.
   * @param {number} height - The desired height of the window.
   * @returns {Promise} - Resolves when the window size is set.
   */
  async setSize(width, height) {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.setWindowSize(this.wid, width, height);
  }
  
  /**
   * Sets the position of the current window.
   * @param {number} left - The desired left position of the window.
   * @param {number} top - The desired top position of the window.
   * @returns {Promise} - Resolves when the window position is set.
   */
  async setPos(left, top) {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.setWindowPos(this.wid, left, top);
  }

  /**
   * Sets the resizable state of the window.
   * @param {boolean} state - Whether the window should be resizable (`true`) or not (`false`).
   * @returns {Promise<boolean|undefined>} - Resolves to `true` if the resizable state was set successfully, or `false` if the window ID is invalid.
   */
  async setResizable(state) {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.setWindowResizable(this.wid, state);
  }

  /**
   * Sets the movable state of the window.
   * @param {boolean} state - Whether the window should be movable (`true`) or not (`false`).
   * @returns {Promise<boolean|undefined>} - Resolves to `true` if the movable state was set successfully, or `false` if the window ID is invalid.
   */
  async setMovable(state) {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.setWindowMovable(this.wid, state);
  }

  /**
   * Sets the aspect ratio of the window.
   * @param {number} aspect_ratio - The desired aspect ratio (width divided by height) for the window.
   * @returns {Promise<boolean|undefined>} - Resolves to `true` if the aspect ratio was set successfully, or `false` if the window ID is invalid.
   */
  async setAspectRatio(aspect_ratio) {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.setWindowAspectRatio(this.wid, aspect_ratio);
  }

  /**
   * Sets the opacity of the window.
   * @param {number} opacity - The desired opacity level of the window (ranging from `0` for fully transparent to `1` for fully opaque).
   * @returns {Promise<boolean|undefined>} - Resolves to `true` if the opacity was set successfully, or `false` if the window ID is invalid.
   */
  async setOpacity(opacity) {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.setWindowOpacity(this.wid, opacity);
  }

  /**
   * Sets the fullscreen state of the window.
   * @param {number} state - State of fullscreen
   * @returns {Promise<boolean|undefined>} - Resolves to `true` if the fullscreen was set successfully, or `false` if the window ID is invalid.
   */
  async setFullscreen(state) {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.setWindowFullscreen(this.wid, state);
  }
  
  /**
   * Sets the title of the current window.
   * @param {string} title - The new title for the window.
   * @returns {Promise<*>} A promise that resolves when the title is set.
   */
  async setTitle(title) {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.setWindowTitle(this.wid, title);
  }

  /**
   * Prints the current window to PDF.
   * @param {Object} options - Options for printing.
   * @returns {Buffer} Generated PDF data.
   */
  async printToPdf(options) {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.printWindowToPdf(this.wid, options);
  }
  
  /**
   * Retrieves the size of the current window.
   * @returns {Promise<Array>} - Resolves with an array [width, height].
   */
  async getSize() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.getWindowSize(this.wid);
  }
  
  /**
   * Retrieves the position of the current window.
   * @returns {Promise<Array>} - Resolves with an array [left, top].
   */
  async getPos() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.getWindowPos(this.wid);
  }
  
  /**
   * Closes the current window.
   * @returns {Promise} - Resolves when the window is closed.
   */
  async close() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.closeWindows(this.wid);
  }
  
  /**
   * Opens the developer tools for the current window asynchronously.
   * @returns {Promise<boolean>} A promise that resolves to true when dev tools are opened.
   */
  async openDevTools() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.openWindowDevTools(this.wid);
  }

  /**
   * Returns media source id for this window.
   * @returns {String|boolean} Media source id if there is window; otherwise, false.
   */
  async getMediaSourceId() {
    await this.#jsl.promiseOrStoped(this.ready);
    return this.#jsl.env.getWindowMediaSourceId(this.wid);
  }

  /**
   * Starts video recording of this window.
   * @param {Object} - Optional settings. 
   * @returns {Object|boolean} - Returns recorder object.
   */
  async startVideoRecording(opts) {
    await this.#jsl.promiseOrStoped(this.ready);
    return await this.#jsl.device.startVideoRecording(this.#jsl.env.getWindowMediaSourceId(this.wid), opts);
  }
  
  /**
   * Appends a script to the document head.
   * @param {string} script_path The script's URL.
   */
  addScript(script_path) {
    const script = this.context.document.createElement("script");
    script.src = script_path;
    this.context.document.head.appendChild(script);
  }

  /**
   * Appends a stylesheet link to the document head.
   * @param {string} stylesheet_path The stylesheet's URL.
   */
  addLinkStylesheet(stylesheet_path) {
    const link = this.context.document.createElement("link");
    link.rel = "stylesheet";
    link.href = stylesheet_path;
    this.context.document.head.appendChild(link);
  }
  
  /**
   * Loads the UI script.
   */
  addUI() {
    this.addScript("../js/windows/ui.js");
    this.addLinkStylesheet("../css/ui.css");
  }
  
  /**
   * Handles actions to perform when the window is ready.
   * @returns {void}
   */
  _onReady() {
    var style = this.dom.createElement('style');
    this.dom.head.appendChild(style);
    this.lang_styles = style.sheet;
    this.lang_styles.insertRule("lang { display: none; }", 0);
    this._updateLanguage();
    this._readyResolve(true);
  }
  
  /**
   * Updates the language of the text elements within the DOM.
   * @param {boolean} [flag=true] - Whether to update the language.
   * @returns {void}
   */
  _updateLanguage(flag = true) {
    if(flag) {
      this.dom.querySelectorAll('str').forEach(function(el) {
        var id = el.getAttribute('sid');
        el.innerHTML = language.string(id);
      });
    }

    if(this.lang_styles.cssRules.length > 1) {
      this.lang_styles.deleteRule(1);
    }
    this.lang_styles.insertRule("lang."+language.lang+" { display: initial }", 1);
      
    this.dom.querySelectorAll('[title-str]').forEach(function(el) {
      var id = el.getAttribute('title-str');
      if(id in language.s) {
        el.setAttribute('title', language.s[id][language.lang]);
      }
    });
    
    this.dom.querySelectorAll('textarea[str]').forEach(function(el) {
      var id = el.getAttribute('str');
      if(id in language.s) {
        el.setAttribute('placeholder', language.s[id][language.lang]);
      }
    });
    
    this.dom.querySelectorAll('input[str]').forEach(function(el) {
      var id = el.getAttribute('str');
      if(id in language.s) {
        el.setAttribute('placeholder', language.s[id][language.lang]);
      }
    });

    this.dom.querySelectorAll('option[str]').forEach(function(el) {
      var id = el.getAttribute('str');
      if(id in language.s) {
        el.textContent = language.s[id][language.lang];
      }
    });
  }
}

\end{lstlisting}

% ------------------------------
\subsection{windows}


\begin{lstlisting}[style=JavaScriptStyle, caption={mathjax-config.js}]
window.MathJax = {
  tex: {
    macros: {
      bm: ["\\mathbfit{#1}", 1],   // \bm{X} → \mathbfit{X}
      norm: ["\\left\\lVert #1 \\right\\rVert", 1],
      abs:  ["\\left\\lvert #1 \\right\\rvert", 1],
      diff: ["\\,\\mathrm{d}#1", 1]
    }
  },
  startup: { 
    typeset: false 
  } 
};
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={plot.js}]
/**
 * @file JSLAB library plot script
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

/**
 * Class for JSLAB plot.
 */
class PRDC_JSLAB_PLOT {
  
  /**
   * Initializes an instance of the PRDC_JSLAB_PLOT class.
   */
  constructor() {
    var obj = this;
    this.figure_content = document.getElementById('figure-content');
    this.plot_cont;
    
    this.update_queue = new Map();
    this.frame_requested = false;
  }
  
  /**
   * Set a new plot container to the figure content.
   */
  setCont() {
    this.plot_cont = document.createElement('div');
    this.plot_cont.className = 'plot-cont';
    this.figure_content.appendChild(this.plot_cont);
  }
  
  /**
   * Creates a new plot using Plotly in the plot container.
   * @param {Object} plot_in - An object containing plot initial settings.
   * @param {Array} traces - Data traces for the plot.
   * @param {Object} layout - Layout configuration for the plot.
   * @param {Object} config - Additional configuration settings for the plot.
   */
  async newPlot(plot_in, traces, layout, config) {
    await Plotly.newPlot(this.plot_cont, traces, layout, config);
  }

  /**
   * Queues trace-update objects for the next animation-frame batch flush.
   * @param {Object} traces - The trace data to apply styling changes to.
   * @param {number} N - The index or length of data for styling adjustments.
   */
  updateData(traces, N) {
    var obj = this;
    traces = Array.isArray(traces) ? traces : [traces];
    var idxs = typeof N === 'undefined'
      ? this.plot_cont.data.map((_, i) => i)
      : (Array.isArray(N) ? N : [N]);

    idxs.forEach(function(idx, k) {
      if(idx == null || Number.isNaN(idx)) return;
      var update = (traces.length === idxs.length) ? traces[k] : traces[0];
      obj.update_queue.set(idx, { ...obj.update_queue.get(idx), ...update });
    });
    
    if(!this.frame_requested) {
      this.frame_requested = true;
      requestAnimationFrame(function() {
        obj._flushUpdates();
      });
    }
  }
  
  /**
   * Queues trace-update objects for the next animation-frame batch flush.
   * @param {Object|Object[]} data - Single trace or array of traces, each with an `id` and properties to restyle.
   */
  updateDataById(data) {
    var obj = this;
    var list = Array.isArray(data) ? data : [data];
    
    list.forEach(function(item) {
      if(!item || !item.id) {
        return;
      }
      obj.update_queue.set(item.id, { ...obj.update_queue.get(item.id), ...item });
    });

    if(!this.frame_requested) {
      this.frame_requested = true;
      requestAnimationFrame(function() {
        obj._flushUpdates();
      });
    }
  }
  
  /**
   * Flushes all queued updates (internal).
   */
  _flushUpdates() {
    var obj = this;
    this.frame_requested = false;

    var restyle_indices = [];
    var restyle_props = {};

    this.update_queue.forEach((update, key) => {
      var idx = (typeof key === 'number')
        ? key
        : obj.plot_cont.data.findIndex(t => t.id === key);

      var flat = {};
      for(var prop in update) {
        if(prop === 'id') continue;
        var val = update[prop];

        if(val && typeof val === 'object' && !Array.isArray(val)) {
          for(var sub in val) {
            flat[`${prop}.${sub}`] = val[sub];
          }
        } else {
          flat[prop] = val;
        }
      }

      if(idx !== -1 && obj.plot_cont.data[idx]) {
        var slot = restyle_indices.push(idx) - 1;
        for(var prop in flat) {
          if(!restyle_props[prop]) restyle_props[prop] = [];
          var v = flat[prop];
          restyle_props[prop][slot] =
            Array.isArray(v) && v.length === 1 && Array.isArray(v[0]) ? v[0] : v;
        }
      }
     });
    
    if(restyle_indices.length) {
      Plotly.restyle(this.plot_cont, restyle_props, restyle_indices);
    }
    this.update_queue.clear();
  }
  
  /**
   * Updates the layout of the existing plot.
   * @param {Object} layout - Layout configuration to apply to the plot.
   */
  relayout(layout) {
    Plotly.relayout(this.plot_cont, layout);
  }

  /**
   * Restyles the plot with updated trace data.
   * @param {Object} traces - The trace data to apply styling changes to.
   * @param {number} N - The index or length of data for styling adjustments.
   */
  restyle(traces, N) {
    Plotly.restyle(this.plot_cont, traces, N);
  }
  
  /**
   * Resizes the plot to fit its container.
   */
  resize() {
    Plotly.Plots.resize(this.plot_cont);
  }

  /**
   * Converts the plot to an image.
   * @param {string} ext - The image format extension (e.g., 'png', 'jpeg').
   * @param {Array} size - Optional size of image.
   * @returns {String} Image of the plot.
   */
  async toImage(ext, size) {
    var width = this.plot_cont.clientWidth;
    var height =  this.plot_cont.clientHeight;
    if(typeof size != 'undefined') {
      width = size[0];
      height = size[1];
    }
    return await Plotly.toImage(this.plot_cont, {format: ext,
      width: width,
      height: height
    });
  }
  
  /**
   * Converts the plot to an json object.
   * @param {Function} callback - Callback function that handles the image URL.
   * @returns {Object} JSON of the plot.
   */
  toJSON() {
    return Plotly.Plots.graphJson(this.plot_cont, 
      undefined, undefined, undefined, true);
  }
  
  /**
   * Sets the plot data from JSON.
   * @param {Array} data Data for the plot.
   */
  async fromJSON(data) {
    await Plotly.newPlot(this.plot_cont, data);
  }
}

var plot = new PRDC_JSLAB_PLOT();
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={presentation-editor.js}]
/**
 * @file JSLAB library presentation editor script
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
const { ipcRenderer } = require('electron');
 
const fs = require('fs');
const path = require('path');
const { ESLint } = require("eslint");
require("../js/init-config.js");

const { PRDC_POPUP } = require('../lib/PRDC_POPUP/PRDC_POPUP');
const { PRDC_PANEL } = require('../lib/PRDC_PANEL/PRDC_PANEL');

/**
 * Class for JSLAB presentation editor code tab.
 */
class PRDC_JSLAB_PRESENTATION_EDITOR_CODE_TAB {
  
  /**
   * Initializes an instance of the PRDC_JSLAB_PRESENTATION_EDITOR class.
   */
  constructor(editor, name, file) {
    var obj = this;
    this.editor = editor;
    
    this.tab = this.editor.tabs.addTab({
      title: name,
      favicon: false
    });
    this.tab.tab_obj = this;

    this.code_editor = CodeMirror(document.getElementById("code"), {
      theme: "notepadpp",
      rulers: [{ color: "#aff", column: 75, lineStyle: "solid" }],
      indentUnit: 2,
      tabSize: 2,
      lineNumbers: true,
      lineWrapping: true,
      styleActiveLine: true,
      matchBrackets: true,
      gutter: true,
      gutters: [
        "CodeMirror-linenumbers",
        "CodeMirror-foldgutter",
        "CodeMirror-lint-markers",
      ],
      foldGutter: true,
      searchDialog: true,
      highlightSelectionMatches: { annotateScrollbar: true },
    });
    
    CodeMirror.keyMap.default["Shift-Tab"] = "indentLess";
    CodeMirror.keyMap.default["Tab"] = "indentMore";
    CodeMirror.keyMap.default["Ctrl-F"] = "showSearchDialog";
    CodeMirror.keyMap.default['Ctrl-G'] = 'findNext';
    CodeMirror.keyMap.default['Shift-Ctrl-G'] = 'findPrev';
    CodeMirror.keyMap.default['Shift-Ctrl-F'] = 'replace';
    CodeMirror.keyMap.default['Shift-Ctrl-R'] = 'replaceAll';
    CodeMirror.keyMap.default['Ctrl-/'] = 'toggleComment';
    
    // Keypress events
    this.code_editor.on("keypress", function (cm, event) {
      if(
        !cm.state.completionActive &&
        !event.ctrlKey &&
        event.key != "Enter" &&
        event.key != ";" &&
        event.key != " " &&
        (event.key != "{") & (event.key != "}")
      ) {
        CodeMirror.commands.autocomplete(cm, null, { completeSingle: false });
      }
    });
    
    this.code_editor.getInputField().setAttribute('title', name);
    
    if(name == 'html') {
      this.code_editor.setOption("mode", "htmlmixed");
      this.code_editor.setOption("lint", {});

      function collectSlideRanges(source) {
        const ranges = [];
        const re = /<\s*slide\b[^>]*>([\s\S]*?)<\/\s*slide\s*>/gi;
        let m;
        while ((m = re.exec(source))) ranges.push({ start: m.index, end: re.lastIndex });
        return ranges;
      }

      function cursorSlideIndex(pos, ranges) {
        for(let i = 0; i < ranges.length; i++)
          if(pos >= ranges[i].start && pos <= ranges[i].end) return i;
        return -1;
      }
      
      this.getSlide = function() {
        var pos = obj.code_editor.indexFromPos(obj.code_editor.getCursor());
        var txt = obj.code_editor.getValue();
        return cursorSlideIndex(pos, collectSlideRanges(txt));
      }
      this.setSlide = function(index) {
        var txt = obj.code_editor.getValue();
        var rngs = collectSlideRanges(txt);
        if(index >= 0 && index < rngs.length) {
          var r = rngs[index];
          var gt = txt.indexOf('>', r.start);
          var offset = gt !== -1 && gt < r.end ? gt + 1 : r.start;
          var pos = obj.code_editor.posFromIndex(offset);
          obj.code_editor.setCursor(pos);
          obj.code_editor.scrollIntoView({ line: pos.line, ch: pos.ch }, 80)
        }
      }
      this.foldSlides = function() {
        var cursor = obj.code_editor.getSearchCursor(/<\s*slide\b[^>]*>/ig, CodeMirror.Pos(0, 0));
        obj.code_editor.operation(() => {
          while(cursor.findNext()) {
            const pos = cursor.from();
            obj.code_editor.foldCode(pos, null, 'fold');
          }
        });
      }
      this.unfoldSlides = function() {
        var cursor = obj.code_editor.getSearchCursor(/<\s*slide\b[^>]*>/ig, CodeMirror.Pos(0, 0));
        obj.code_editor.operation(() => {
          while(cursor.findNext()) {
            const pos = cursor.from();
            obj.code_editor.foldCode(pos, null, 'unfold');
          }
        });
      }
    } else if(name == 'css') {
      this.code_editor.setOption("mode", "css");
      this.code_editor.setOption("lint", {});
    } else if(name == 'js') {
      this.code_editor.setOption("mode", "javascript");
      this.code_editor.setOption("lint", {
        getAnnotations: async function(text, callback) {
          var results = await obj.editor.eslint.lintText(text);
          callback(results[0].messages.map(message => ({
            from: CodeMirror.Pos(message.line - 1, message.column - 1),
            to: CodeMirror.Pos(
              message.endLine ? message.endLine - 1 : message.line - 1,
              message.endColumn ? message.endColumn - 1 : message.column
            ),
            severity: message.severity === 2 ? "error" : "warning",
            message: message.message,
          })));
        },
        async: true
      });
    }
  }
  
  /**
   * On code changed
   */ 
  codeChanged() {
    this.tab.classList.add("changed");
  }
  
  /**
   * Activates this tab and shows code
   */
  show() {
    $(".CodeMirror").hide();
    this.editor.tabs.setCurrentTab(this.tab);
    $(this.code_editor.display.wrapper).show();
    this.code_editor.focus();
    this.code_editor.refresh();
  }
  
  /**
   * Save code
   */
  save() {
    if(this.tab.classList.contains("changed")) {
      this.tab.classList.remove("changed");
      fs.writeFileSync(this.file_path, this.code_editor.getValue())
    }
  }

  /**
   * Opens search dialog in the code editor.
   */
  openSearchDialog() {
    this.code_editor.execCommand('showSearchDialog');
  }
  
  /**
   * Sets file path for code
   * @param {String} file_path - Absolute path to the code file
   */
  setPath(file_path) {
    var obj = this;
    this.file_path = file_path;
    this.code = fs.readFileSync(file_path).toString();
    this.code_editor.setValue(this.code);
    this.code_editor.clearHistory();
    
    this.code_editor.on("change", function() {
      obj.codeChanged();   
    });
  }
}

/**
 * Class for JSLAB presentation editor.
 */
class PRDC_JSLAB_PRESENTATION_EDITOR {
  
  /**
   * Initializes an instance of the PRDC_JSLAB_PRESENTATION_EDITOR class.
   */
  constructor() {
    var obj = this;
    
    this.webview = document.getElementById('preview');
    this.webview_wrap = document.getElementById('webview-wrap');
    this.left = document.getElementById('left-panel-cont');
    
    this.eslint = new ESLint(config.LINT_OPTIONS);
    this.editor_more_popup = new PRDC_POPUP(document.getElementById('editor-more-icon'),
      document.getElementById('editor-more-popup'));
    this.current_slide = 0;
    this.total_slides = 0;

    this.columns = new PRDC_PANEL('presentation-editor-columns', 'vertical', document.body, [document.getElementById('left-panel'), document.getElementById('right-panel')], [60, 40], function() {
      obj.scaleSlide();
    });    
    
    // Initialize panels
    window.addEventListener('resize', function() {
      obj.columns.onResize();
    });
    
    // Tabs
    this.tabs_cont = document.querySelector(".tabs");
    this.tabs = new PRDC_TABS();
    this.tabs.init(this.tabs_cont);

    // On tab change
    this.tabs_cont.addEventListener("activeTabChange", function({ detail }) {
      obj.active_tab = detail.tabEl;
      if(obj.active_tab.hasOwnProperty('tab_obj')) {
        obj.active_tab.tab_obj.show();
      }
    });
    
    this.html_editor = new PRDC_JSLAB_PRESENTATION_EDITOR_CODE_TAB(this, 'html');
    this.js_editor = new PRDC_JSLAB_PRESENTATION_EDITOR_CODE_TAB(this, 'js');
    this.css_editor = new PRDC_JSLAB_PRESENTATION_EDITOR_CODE_TAB(this, 'css');
    
    this.html_editor.show();

    document.addEventListener("keydown", function(e) {
      if(e.ctrlKey && e.key.toLowerCase() === "s" && !e.shiftKey) {
        obj.saveCode();
      }
    });

    this.webview.addEventListener('ipc-message', (e) => {
      if(e.args[0].ready !== undefined) {
        obj.total_slides = e.args[0].ready; 
        document.getElementById('total-slides').innerText = '/ ' + obj.total_slides;
      } else if(e.args[0].slide !== undefined) {
        obj.current_slide = e.args[0].slide;
        document.getElementById('set-slide').value = obj.current_slide + 1;
      }
    });
    
    $("#tab-save").click(function() { obj.saveCode(); });
    $("#search-dialog-menu").click(function() { 
      obj.active_tab.tab_obj.openSearchDialog();
      obj.editor_more_popup.close();
    });
    $("#fold-slides").click(function() { 
      obj.html_editor.show();
      obj.html_editor.foldSlides() 
      obj.editor_more_popup.close();
    });
    $("#unfold-slides").click(function() { 
      obj.html_editor.show();
      obj.html_editor.unfoldSlides() 
      obj.editor_more_popup.close();
    });
    
    $("#first-slide").click(function() {
      obj.webview.send('data',{ show: 0 });
    }); 
    $("#prev-slide").click(function() {
      obj.webview.send('data',{ show: obj.current_slide - 1 });
    });
    $("#next-slide").click(function() {
      obj.webview.send('data',{ show: obj.current_slide + 1 });
    });
    $("#last-slide").click(function() {
      obj.webview.send('data',{ show: obj.total_slides - 1 });
    });
    $("#set-slide").on( "change", function() {
      obj.webview.send('data',{ show: $(this).val() - 1 });
    });

    // On IPC message
    ipcRenderer.on("PresentationEditorWindow", function(event, action, data) {
      switch(action) {
        case "go-to-code":
          obj.html_editor.show();
          obj.html_editor.setSlide(obj.current_slide);
          break;
        case "go-to-slide":
          obj.webview.send('data', { show: obj.html_editor.getSlide() });
          break;
      }
    });
  }
  
  /**
   * Sets file path for presentation editor
   * @param {String} file_path - Absolute path to the presentation directory.
   */
  setPath(file_path, url) {
    var obj = this;
    this.file_path = file_path;
    this.url = url;
    var name = path.basename(file_path);;
    
    this.exe_file = name;
    this.html_editor.setPath(path.join(file_path, 'index.html'));
    this.js_editor.setPath(path.join(file_path, 'main.js'));
    this.css_editor.setPath(path.join(file_path, 'main.css'));
    
    document.getElementById('presentation-title').innerText = name;
    this.webview.src = url+'?lazy';
    this.presentation_config = JSON.parse(fs.readFileSync(path.join(file_path, 'res/internal/config.json')).toString());
    
    // Slide scale
    this.webview.style.width = this.presentation_config.slide_width + 'px';
    this.webview.style.height = this.presentation_config.slide_height + 'px';
    this.scaleSlide();
  }
  
  /**
   * Saves code and triggers frame update
   */
  saveCode() {
    this.html_editor.save();
    this.js_editor.save();
    this.css_editor.save();
    this.webview.reload();
  }
  
  /**
   * Scale slide
   */
  scaleSlide() {
    const scale = Math.min((this.left.clientWidth - 20) / this.presentation_config.slide_width, (this.left.clientHeight- 20) / this.presentation_config.slide_height);
    this.webview.style.transform = `scale(${scale})`;
    this.webview_wrap.style.height  = `${this.presentation_config.slide_height * scale}px`;
  }
}

var presentation_editor = new PRDC_JSLAB_PRESENTATION_EDITOR();
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={presentation.js}]
/**
 * @file JSLAB library presentation script
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */

window.file_buffers = {};
var has_node = typeof window.process === 'object' &&
   !!(window.process.versions && window.process.versions.electron);
if(has_node) {
  var { ipcRenderer } = require('electron');
}

var is_iframe = window.parent != window;
var is_lazy = new URLSearchParams(location.search).has('lazy');

/**
 * Stores file buffer.
 * @param {string} file_path The key for the file.
 * @param {ArrayBuffer} data The file contents.
 */
window.registerFile = function(file_path, data) {
  window.file_buffers[file_path] = atob(data);
}

/**
 * Class for JSLAB presentation.
 */
class PRDC_JSLAB_PRESENTATION {
  
  /**
   * Initializes an instance of the PRDC_JSLAB_PRESENTATION class.
   */
  constructor() {
    var obj = this;
    
    this.config = %presentation_config%;
    this.slides = document.querySelectorAll('slide');
    this.slides_cont = document.getElementById('slides-cont');
    this.current_slide = -1;
    this.total_slides = this.slides.length;
    this._interpolated = new WeakSet();
    this._standalone = window.location.protocol == 'file:'
    this._animating = false;

    const style = document.createElement('style');
    style.textContent = `
    @media print {
      slide {
        display: block !important;
        width : ${this.config.slide_width}px;
        height: ${this.config.slide_height}px;
      }
    }`;
    document.head.appendChild(style);
    
    this._buildSlideNav();
    
    this._validTransitions = new Set([
      'none', 'fade', 'zoom', 
      'cover', 'uncover',
      'flip', 'flip-x', 'flip-y',
      'slide', 'slide-left','slide-right','slide-up','slide-down',
      'cube', 'cube-left','cube-right','cube-up','cube-down',
      'push', 'push-left','push-right','push-up','push-down',
      
    ]);
    this.transition = this.slides_cont.getAttribute('transition') || 'fade';
    if(!this._validTransitions.has(this.transition)) this.transition = 'fade';
    
    document.addEventListener('keydown', (event) => {
      if(event.ctrlKey && event.key.toLowerCase() === 's'){
        event.preventDefault();
        this._toggleSlideNav();
      }
      switch(event.key) {
        case 'ArrowRight':
        case 'PageDown':
          this._lastNavKey = 'right';
          obj.nextSlide();
          break;

        case 'ArrowLeft':
        case 'PageUp':
          this._lastNavKey = 'left';
          obj.prevSlide();
          break;

        case 'ArrowDown':
          this._lastNavKey = 'down';
          obj.nextSlide();
          break;

        case 'ArrowUp':
          this._lastNavKey = 'up';
          obj.prevSlide();
          break;
        case 'F11':
          if(has_node) {
            ipcRenderer.sendToHost('data', { key: 'F11' });
          }
          if(is_iframe) {
            window.parent.postMessage({ key: 'F11' }, '*');
          }
          break;
      }
    });
    
    const WHEEL_DEBOUNCE = 250;
    var wheelGuard = false;
    document.addEventListener('wheel', (event) => {
      if(event.target.closest('.js-plotly-plot') ||
        event.target.closest('input')) return;
      if(Math.abs(event.deltaY) < 10 || wheelGuard) {
        return;
      }

      if(event.deltaY > 0) {
        this._lastNavKey = 'down';
        obj.nextSlide();
      } else {
        this._lastNavKey = 'up';
        obj.prevSlide();
      }

      wheelGuard = true;
      setTimeout(() => (wheelGuard = false), WHEEL_DEBOUNCE);
    }, { passive: true });

    window.addEventListener('DOMContentLoaded', () => {
      var m = window.location.hash.match(/^#s(\d+)$/);
      var wanted = m ? parseInt(m[1], 10) - 1 : 
        this.current_slide > -1 ? this.current_slide : 0;
      this.setSlide(wanted);
    })

    window.addEventListener('hashchange', () => {
      const m = location.hash.match(/^#s(\d+)$/);
      if(!m) return;
      const idx = parseInt(m[1], 10) - 1;
      if(idx !== this.current_slide) this.showSlide(idx);
    });
    
    window.addEventListener('beforeprint', () => {
      obj._interpolateAllSlides();
    }) 

    window.addEventListener('message', (e) =>{
      if(typeof e.data.set === 'number'){
        obj.setSlide(e.data.set);
      } else if(typeof e.data.show === 'number'){
        obj.showSlide(e.data.show);
      }
    });
    
    if(has_node) {
      ipcRenderer.on('data', (e, data) => {
        if(typeof data.set === 'number'){
          obj.setSlide(data.set);
        } else if(typeof data.show === 'number'){
          obj.showSlide(data.show);
        }
      });
    
      ipcRenderer.sendToHost('data', { ready: this.total_slides });
    }

    this.slides_cont.style.width = this.config.slide_width + 'px';
    this.slides_cont.style.height = this.config.slide_height + 'px';
    
    function scaleSlides() {
      const scale = Math.min(document.body.clientWidth / obj.config.slide_width, 
        document.body.clientHeight / obj.config.slide_height);
      obj.slides_cont.style.transform = `scale(${scale}) translate(-50%, -50%)`;
    }
    window.addEventListener('resize', function(e) {
      scaleSlides();
    });
    scaleSlides();
    
    if(!this._standalone) {
      const ping = () => fetch('/keepalive', 
        { method: 'HEAD', cache: 'no-store', mode: "no-cors" })
      .then((data) => {}).catch((err) => {
        console.log(err);
      }); 

      ping();
      setInterval(ping, 10_000);
    }
    
    this._attachGestureControl();
    if(!is_lazy) {
      MathJax.typesetPromise();
    }
  }

  /**
   * Shows the slide at the supplied zero-based index.
   * @param {number} index – Index of the <slide> element to activate.
   */
  setSlide(index) {
    if(this._animating) this._stopAllAnimations();
    if(index == this.current_slide) return;
    if(index < 0 || index >= this.slides.length) return;
    this.slides.forEach((slide, i) => {
      slide.classList.toggle('active', i === index);
      if(i === index) {
        slide.style.display = 'block';
      } else {
        slide.style.display = 'none';
      }
    });
    this.current_slide = index;
    
    this._updateSlideNav();
    
    const active = this.slides[index];
    if(!this._interpolated.has(active)) {
      this._interpolateSlide(active);
      this._interpolated.add(active);
    }
    
    this._updateHash(index);
    if(has_node) {
      ipcRenderer.sendToHost('data', { slide: index });
    }
    if(is_iframe) {
      window.parent.postMessage({ slide: index }, '*');
    }
    if(is_lazy) {
      this._lazyRender(this.slides[index]);
    }
  }

  /**
   * Shows the slide at the supplied zero-based index with animation.
   * @param {number} index – Index of the <slide> element to activate.
   */
  showSlide(index) {
    if(this._animating) return;
    if(index === this.current_slide) return;
    if(index < 0 || index >= this.slides.length) return;

    var outgoing = this.slides[this.current_slide];
    var incoming = this.slides[index];

    var slideOverride = incoming.getAttribute('transition');
    var base = slideOverride || this.transition;

    var forward = index > this.current_slide;
    var navKey = this._lastNavKey || (forward ? 'right' : 'left');
    var t = this._resolveDir(base, navKey, forward);

    if(t == 'none') {
      if(outgoing) {
        outgoing.classList.remove('active');
        outgoing.style.display = 'none';
      }

      incoming.style.display = 'block';
      incoming.classList.add('active');
    } else {
      this._animating = true;
      
      if(outgoing) {
        outgoing.classList.remove('active');
        outgoing.classList.add('slide-out', `${t}-out`);

        outgoing.addEventListener('animationend', () => {
          outgoing.classList.remove('slide-out', `${t}-out`);
          outgoing.style.display = 'none';
        }, { once: true });
      }
    
      incoming.style.display = 'block';
      incoming.classList.add('slide-in', `${t}-in`, 'active');

      incoming.addEventListener('animationend', () => {
        incoming.classList.remove('slide-in', `${t}-in`);
        this._animating = false;
      }, { once: true });
    }
    
    this.current_slide = index;
    
    this._updateSlideNav();
    
    if(!this._interpolated.has(incoming)) {
      this._interpolateSlide(incoming);
      this._interpolated.add(incoming);
    }
    
    this._updateHash(index);
    if(has_node) {
      ipcRenderer.sendToHost('data', { slide: index });
    }
    if(is_iframe) {
      window.parent.postMessage({ slide: index }, '*');
    }
    if(is_lazy) {
      this._lazyRender(this.slides[index]);
    }
  }
  
  /**
   * Advances to the next slide (no-op if already on the last one).
   */
  nextSlide() {
    this.showSlide(this.current_slide + 1);
  }

  /**
   * Goes back to the previous slide (no-op if already on the first one).
   */
  prevSlide() {
    this.showSlide(this.current_slide - 1);
  }

  /**
   * Sets transition animation by name
   * @param {string} name – transition animation name.
   */
  setTransition(name) {
    if(this._validTransitions.has(name)) this.transition = name;
  }
    
  /**
   * Returns the current slide’s position as a human-friendly 1-based index.
   * @returns {number} The 1-based index of the slide that is currently active.
   */
  slideNumber() {
    return this.current_slide + 1;
  }

  /**
   * Returns the total number of slides in the presentation.
   * @returns {number} The total count of <slide> elements detected at startup.
   */
  slideCount() {
    return this.total_slides;
  }
  
  /**
   * Returns size in pixels based on input string
   * @param {string} Size in vw, vh or % format.
   * @returns {number} Size in pixels.
   */
  toPixels(str, ref) {
    if(!str) return 0;
    if(str.endsWith('vw')) return this.config.slide_width * parseFloat(str) / 100;
    if(str.endsWith('vh')) return this.config.slide_height * parseFloat(str) / 100;
    if(str.endsWith('%')) {
      if(ref == 'width') {
         return this.config.slide_width * parseFloat(str) / 100;
      } else if(ref == 'height') {
        return this.config.slide_height * parseFloat(str) / 100;
      }
    }
    return parseFloat(str);
  }
  
  /**
   * Builds slides navigation.
   */
  _buildSlideNav() {
    var html = `
      <div id="first-slide" class="button" title="First slide">⏮</div>
      <div id="prev-slide" class="button" title="Previous">⏴</div>
      <input id="set-slide" type="number" min="1" step="1">
      <span id="total-slides">/ 0</span>
      <div id="next-slide" class="button" title="Next">⏵</div>
      <div id="last-slide" class="button" title="Last slide">⏭</div>`;
    
    this.slide_nav = document.createElement('div');
    this.slide_nav.id = 'slide-controls';
    this.slide_nav.innerHTML = html;
    this.slide_nav.hidden = true;
    document.body.appendChild(this.slide_nav);

    this.slide_nav.querySelector('#first-slide').onclick = ()=> this.setSlide(0);
    this.slide_nav.querySelector('#prev-slide').onclick = ()=> this.prevSlide();
    this.slide_nav.querySelector('#next-slide').onclick = ()=> this.nextSlide();
    this.slide_nav.querySelector('#last-slide').onclick = ()=> this.setSlide(this.total_slides - 1);

    this.slide_nav_input = this.slide_nav.querySelector('input');
    this.slide_nav_input.onchange = e => {
      this.setSlide((+this.slide_nav_input.value || 1) - 1);
    };
    this.slide_nav_total = this.slide_nav.querySelector('#total-slides');
  
    this._updateSlideNav();
  }
  
  /**
   * Builds slides navigation.
   */
  _toggleSlideNav(){
    this.slide_nav.hidden = !this.slide_nav.hidden;
    if(!this.slide_nav.hidden){
      this.slide_nav_input.focus(); 
      this.slide_nav_input.select();
    }
  }
  
  /**
   * Builds slides navigation.
   */
  _updateSlideNav(){
    this.slide_nav_input.value = this.slideNumber();
    this.slide_nav_total.textContent = `/ ${this.total_slides}`;
  }

  /**
   * Synchronises the URL hash with the currently visible slide.
   * Uses history.replaceState so it never clutters the browser history.
   * @param {number} idx – zero-based slide index.
   */
  _updateHash(idx) {
    const newHash = `#s${idx + 1}`;
    if(location.hash !== newHash) {
      history.replaceState(null, '', newHash);
    }
  }

  /**
   * Lazy-render MathJax, <img-pdf> and <plot-json> elements that
   * live inside the currently visible slide.
   * @param {HTMLElement} slide – the active <slide> element
   */
  _lazyRender(slide) {
    if(!slide) return;
    slide.querySelectorAll('img-pdf, plot-json').forEach(el => {
      if (el._lazyRendered) return;
      if (typeof el._render === 'function') {
        el._lazyRendered = true;
        el._render();
      }
    });

    if(window.MathJax && typeof MathJax.typesetPromise === 'function') {
      MathJax.typesetPromise([slide]).catch(err => console.error(err));
    }
  }

  /**
   * Replaces every ${expr} text placeholder inside *root*
   * with the evaluated value of *expr* in the window scope.
   * @param {HTMLElement} root – Slide element to interpolate.
   */
  _interpolateSlide(root) {
    const AVOID = new Set(['SCRIPT', 'STYLE']);
    const re = /\$\{([^}]+)\}/g;

    const walker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_TEXT,
      {
        acceptNode: n =>
          AVOID.has(n.parentNode.tagName)
            ? NodeFilter.FILTER_REJECT
            : NodeFilter.FILTER_ACCEPT
      }
    );

    for(let node; (node = walker.nextNode()); ) {
      const src = node.nodeValue;
      if(!re.test(src)) continue;
      re.lastIndex = 0;

      const out = src.replace(re, (_, expr) => {
        try {
          const fn  = new Function(`with (window) { return (${expr}); }`);
          const val = fn.call(window);
          return val == null ? '' : String(val);
        } catch (err) {
          return `\${${expr}}`;
        }
      });

      if(out !== src) node.nodeValue = out;
    }
  }
  
  /**
   * Calls _interpolateSlide method for each slide
   */
  _interpolateAllSlides() {
    var current_slide = this.current_slide;
    for(var i = 0; i < this.slideCount(); i++) {
      this.setSlide(i);
    };
    this.setSlide(current_slide);
  }

  /**
   * Removes all “-in/-out” classes from slide and hard-stops its animation.
   * @param {HTMLElement} el – slide element.
   */
  _clearAnimClasses(el) {
    el.classList.forEach(c => {
      if(c.endsWith('-in') || c.endsWith('-out')) el.classList.remove(c);
    });
    el.style.animation = 'none';
    void el.offsetWidth;
    el.style.animation = '';
  }

  /**
   * Stops all slides that may be mid-transition.
   */
  _stopAllAnimations() {
    this.slides.forEach(s => this._clearAnimClasses(s));
    this._animating = false;
  }

  /**
   * Expands a base transition into a direction-specific variant.
   * @param base    {string}  e.g. "slide", "flip", "cover"
   * @param navKey  {string}  "left" | "right" | "up" | "down"
   * @param forward {boolean} true when index grows
   */
  _resolveDir(base, navKey, forward) {
    if(/-(left|right|up|down)$/.test(base)) return base;
    if(base === 'flip') {
      return (navKey === 'up' || navKey === 'down') ? 'flip-x' : 'flip-y';
    }
    if(base === 'slide' || base === 'cube' || base === 'push') {
      if(navKey === 'up')   return `${base}-down`; 
      if(navKey === 'down') return `${base}-up`;
      return `${base}-${forward ? 'left' : 'right'}`;
    }
    if(base === 'cover' || base === 'uncover') {
      if(navKey === 'up')   return `${base}-up`;
      if(navKey === 'down') return `${base}-down`;
      return `${base}-${forward ? 'left' : 'right'}`;
    }
    return base;
  }
  
  /**
   * Attaches gesture control
   */
  _attachGestureControl() {
    let startX = 0, startY = 0, tracking = false;
    const PX_THRESHOLD = 40;
    const slidesArea = this.slides_cont;

    slidesArea.addEventListener('pointerdown', e => {
      if(e.target.closest('.js-plotly-plot') ||
        e.target.closest('input')) return;
      if(e.pointerType !== 'mouse' || e.buttons === 1) {
        tracking = true;
        startX = e.clientX;
        startY = e.clientY;
      }
    }, { passive: true });

    slidesArea.addEventListener('pointerup', e => {
      if(e.target.closest('.js-plotly-plot') ||
        e.target.closest('input')) return;
      if(!tracking) return;
      tracking = false;

      const dx = e.clientX - startX;
      const dy = e.clientY - startY;

      if(Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > PX_THRESHOLD) {
        if(dx < 0) {
          this._lastNavKey = 'right';
          this.nextSlide();
        } else {
          this._lastNavKey = 'left';
          this.prevSlide();
        }
      } else if(Math.abs(dy) > Math.abs(dx) && Math.abs(dy) > PX_THRESHOLD) {
        if(dy < 0) {
          this._lastNavKey = 'up';
          this.prevSlide();
        } else {
          this._lastNavKey = 'down';
          this.nextSlide();
        }
      }
    }, { passive: true });
    slidesArea.addEventListener('pointercancel', () => { tracking = false; });
  }
}

var presentation = new PRDC_JSLAB_PRESENTATION();

/**
 * Loads file from buffer
 * @param {string} buf_url – URL to buffered file.
 */
async function loadFileBuf(buf_url) {
  var name = encodeURIComponent(buf_url);
  if(window.file_buffers[name]) return Promise.resolve(window.file_buffers[name]);
  return new Promise((resolve, reject) => {
    const s = document.createElement('script');
    s.src = buf_url + '.buf.js';
    s.onload = () => {
      resolve(window.file_buffers[name]);
    }
    document.head.appendChild(s);
  });
}

/**
 * Class for ImagePDF HTML element
 */
class ImagePDF extends HTMLElement {

  static observedAttributes = ['src', 'page', 'width', 'height'];
  
  /**
   * Initializes an instance of the ImagePDF class.
   */
  constructor() {
    super();
    this._canvas = document.createElement('canvas');
    this._context = this._canvas.getContext('2d');
    this.appendChild(this._canvas);
  }
  
  /**
   * Callback called when element is added to page
   */
  connectedCallback() {
    if(!is_lazy) this._render();
    this.is_connected = true;
  }
  /**
   * Callback called when element's attribute is changed
   */
  attributeChangedCallback() { 
    if(!this.is_connected) return;
    if(!is_lazy || this.closest('slide')?.classList.contains('active')) {
      this._render();
    }
  }
  
  /**
   * Renders element
   */
  async _render() {
    var src_attr = this.getAttribute('src');
    if(!src_attr) return;
    
    let loadingTask;
    try {
      if(this.src != src_attr) {
        if(presentation._standalone){
          var buf = await loadFileBuf(src_attr);
          loadingTask = pdfjsLib.getDocument({ data: buf });
        } else {
          loadingTask = pdfjsLib.getDocument(src_attr);
        }
        this.src = src_attr;
        this.pdf = await loadingTask.promise;;
      }
      
      var page_n = parseInt(this.getAttribute('page') || '1', 10) || 1;
      var page = await this.pdf.getPage(page_n);
      
      var vp0  = page.getViewport({ scale: 1 });
      var wanted_w = presentation.toPixels(this.getAttribute('width'), 'width') || vp0.width;
      var wanted_h = presentation.toPixels(this.getAttribute('height'), 'height') || vp0.height;

      var scale = wanted_w ? wanted_w / vp0.width : wanted_h ? wanted_h / vp0.height : 1;
      var vps = page.getViewport({ scale });
      
      this._canvas.style.display = 'block';
      this._canvas.width = vps.width;
      this._canvas.height = vps.height;

      await page.render({ canvasContext: this._context, viewport: vps }).promise;
      this._finished_loading = true;
    } catch(err){
      console.error('img-pdf:', err);
    }
  }
}

customElements.define('img-pdf', ImagePDF);

/**
 * Class for PlotJSON HTML element
 */
class PlotJSON extends HTMLElement {

  static observedAttributes = ['src', 'width', 'height'];
  
  /**
   * Initializes an instance of the PlotJSON class.
   */
  constructor() {
    super();
    this._cont = this.appendChild(document.createElement('div'));
  }
  
  /**
   * Callback called when element is added to page
   */
  connectedCallback() {
    if(!is_lazy) this._render();
    this.is_connected = true;
  }
  /**
   * Callback called when element's attribute is changed
   */
  attributeChangedCallback() { 
    if(!this.is_connected) return;
    if(!is_lazy || this.closest('slide')?.classList.contains('active')) {
      this._render();
    }
  }
  
  /**
   * Renders element
   */
  async _render() {
    var src_attr = this.getAttribute('src');
    if(!src_attr) return;
    
    try {
      if(this.src != src_attr) {
        if(presentation._standalone){
          const buf = await loadFileBuf(src_attr);
          this.data = JSON.parse(buf);
        } else {
          var resp = await fetch(src_attr, { cache: 'no-store' });
          this.data = await resp.json();
        }
        this.src = src_attr;
      }
      
      var w = presentation.toPixels(this.getAttribute('width'), 'width') || 0;
      var h = presentation.toPixels(this.getAttribute('height'), 'height') || 0;
      if(w) this.data.layout.width = w;
      if(h) this.data.layout.height = h;

      await Plotly.newPlot(this._cont, this.data);
      this._finished_loading = true;
    } catch(err){
      console.error('plot-json:', err);
    }
  }
}

customElements.define('plot-json', PlotJSON);
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={terminal.js}]
/**
 * @file JSLAB library terminal script
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB ui.
 */
class PRDC_JSLAB_TERMINAL {
  
  /**
   * Initializes an instance of the PRDC_JSLAB_TERMINAL class.
   */
  constructor() {
    var obj = this;
    
    this.messages = document.getElementById('messages-container');
    this.message_input = document.getElementById('message-input');
    this.autoscroll = true;
    this.show_timestamp = true;
    this.write_timestamps = true;
    this.log = [];
    this.log_dialog = document.getElementById('log-dialog');
    this.settings_dialog = document.getElementById('settings-dialog');
    this.dialogs = [this.log_dialog, this.settings_dialog]
    this.N_messages = 1;
    this.N_messages_max = Infinity;
    this.last_class = null;
    this.last_tic = 0;

    for(var dialog of this.dialogs) {
      dialog.addEventListener('input', function(e) {
        if(e.key == 'Escape') {
          // ESC
          obj.closeDialog(dialog);
          e.stopPropagation();
          e.preventDefault();
        }
      });
    }
    
    // Terminal settings button click
    document.getElementById('settings').addEventListener('click', () => {
      this.openDialog(this.settings_dialog);
    });
    
    // Terminal timestamp button click
    document.getElementById('timestamp').addEventListener('click', () => {
      this.setTimestamp(!this.show_timestamp);
    });
    this.setTimestamp(this.show_timestamp);
    
    // Terminal auto scroll button click
    document.getElementById('autoscroll').addEventListener('click', () => {
      this.setAutoscroll(!this.autoscroll);
    });
    this.setAutoscroll(this.autoscroll);
    
    // Terminal clear button click
    document.getElementById('clear').addEventListener('click', () => {
      this.clear();
    });
    
    // Terminal save log button click
    document.getElementById('log').addEventListener('click', () => {
      this.openDialog(this.log_dialog);
    });
    
    // Terminal scroll to bottom button click
    document.getElementById('to-bottom').addEventListener('click', () => {
      this.scrollToBottom();
      this.message_input.focus();
      const len = this.message_input.value.length;
      this.message_input.setSelectionRange(len, len);
    });
    
    document.querySelector('#settings-dialog .options-close').addEventListener('click', () => {
      this.closeDialog(this.settings_dialog);
    });
    
    document.getElementById('N-messages-max').value = this.N_messages_max;
    document.querySelector('#settings-dialog .change-settings').addEventListener('click', () => {
      obj.closeDialog(obj.settings_dialog);
      obj.setNMessagesMax(Number(document.getElementById('N-messages-max').value));
    });
    this.setNMessagesMax(this.N_messages_max);
    
    document.querySelector('#log-dialog .options-close').addEventListener('click', () => {
      this.closeDialog(this.log_dialog);
    });
    document.getElementById('write-timestamps').addEventListener('click', function() {
      obj.setWriteTimestamps(this.checked);
    });
    this.setWriteTimestamps(this.write_timestamps);
    
    this.autoResizeInput();
    this.message_input.addEventListener('keydown', () => {
      this.autoResizeInput();
    });
  }
  
  /**
   * Sets options.
   */
  setOptions(opts) {
    if(opts.hasOwnProperty('show_timestamp')) {
      this.setTimestamp(opts.show_timestamp);
    }
    
    if(opts.hasOwnProperty('show_timestamp')) {
      this.setAutoscroll(opts.autoscroll);
    }
    
    if(opts.hasOwnProperty('N_messages_max')) {
      this.setNMessagesMax(opts.N_messages_max);
    }
    
    if(opts.hasOwnProperty('write_timestamps')) {
      this.setWriteTimestamps(opts.write_timestamps);
    }
  }
  
  /**
   * Auto resizes input
   */
  autoResizeInput() {
    this.message_input.style.height = 'auto';
    this.message_input.style.height = this.message_input.scrollHeight + 'px';
  }
  
  /**
   * Clears all messages from the command window.
   */
  clear() {
    this.N_messages = 1;
    this.messages.innerHTML = '';
  }
  
  /**
   * Scrolls the command window to the bottom.
   */
  scrollToBottom() {
    this.messages.scrollTop = this.messages.scrollHeight;
  }
  
  /**
   * Returns a formatted timestamp string.
   */
  getTimestamp() {
    const date = new Date();
    const pad = (num, size) => ('000' + num).slice(size * -1);
    const time = parseFloat(date.getTime() / 1000).toFixed(3);
    const hours = date.getHours();
    const minutes = Math.floor(time / 60) % 60;
    const seconds = Math.floor(time - minutes * 60);
    const milliseconds = time.slice(-3);
    return pad(hours, 2) + ':' + pad(minutes, 2) + ':' +
           pad(seconds, 2) + '.' + pad(milliseconds, 3);
  }
  
  /**
   * Toggles the visibility of timestamps in the command window.
   */
  setTimestamp(show_timestamp) {
    this.show_timestamp = show_timestamp;
    const timestampButton = document.getElementById('timestamp');
    if(this.show_timestamp) {
      if(this.messages.classList.contains('no-timestamp')) {
        this.messages.classList.remove('no-timestamp');
        timestampButton.classList.add('active');
        timestampButton.setAttribute('title-str', 41);
      }
    } else {
      if(!this.messages.classList.contains('no-timestamp')) {
        this.messages.classList.add('no-timestamp');
        timestampButton.classList.remove('active');
        timestampButton.setAttribute('title-str', 166);
      }
    }
  }
  
  /**
   * Toggles the autoscroll feature.
   */
  setAutoscroll(autoscroll) {
    this.autoscroll = autoscroll;
    const autoscrollButton = document.getElementById('autoscroll');
    if(this.autoscroll) {
      if(!autoscrollButton.classList.contains('active')) {
        autoscrollButton.classList.add('active');
        autoscrollButton.setAttribute('title-str', 42);
      }
    } else {
      if(autoscrollButton.classList.contains('active')) {
        autoscrollButton.classList.remove('active');
        autoscrollButton.setAttribute('title-str', 167);
      }
    }
  }
  
  /**
   * Sets the maximum number of messages to display.
   */
  setNMessagesMax(N_messages_max) {
    if(!N_messages_max) return;
    this.N_messages_max = N_messages_max;
    const nMessagesMaxInput = document.getElementById('N-messages-max');
    if(this.N_messages_max < 5) {
      this.N_messages_max = 5;
    }
    if(this.N_messages >= this.N_messages_max) {
      while(this.N_messages > this.N_messages_max) {
        this.messages.firstChild.remove();
        this.N_messages -= 1;
      }
    }
    if(nMessagesMaxInput.value != this.N_messages_max) {
      nMessagesMaxInput.value = this.N_messages_max;
    }
  }
  
  /**
   * Toggles whether timestamps are written to the log file.
   */
  setWriteTimestamps(write_timestamps) {
    this.write_timestamps = write_timestamps;
    const writeTimestampsInput = document.getElementById('write-timestamps');
    if(this.write_timestamps) {
      if(!writeTimestampsInput.checked) {
        writeTimestampsInput.checked = true;
      }
    } else {
      if(writeTimestampsInput.checked) {
        writeTimestampsInput.checked = false;
      }
    }
  }
  
  /**
   * Adds a message to the terminal output.
   * @param {string} msg_class - The CSS class for the message.
   * @param {string} data - The HTML content of the message.
   * @param {string} [raw] - The raw text data (defaults to data if undefined).
   * @param {boolean} [merge_messages=true] - Whether to merge with the previous message.
   * @returns {HTMLElement} The created message element.
   */
  addMessage(msg_class, data, raw, merge_messages = true) {
    if(typeof raw === 'undefined') {
      raw = data;
    }
    const t = performance.now();
    let el;
    
    if(msg_class !== this.last_class) {
      this.last_class = msg_class;
      this.last_tic = t;
      const ts = this.getTimestamp();
      if(this.N_messages < this.N_messages_max) {
        this.N_messages++;
      } else if(this.messages.firstChild) {
        this.messages.firstChild.remove();
      }
      
      el = document.createElement('div');
      el.className = msg_class;
      el.innerHTML = `<span class="timestamp">${ts}</span>${data}`;
      this.messages.appendChild(el);
      this.log.push({ 'class': msg_class, 'timestamp': ts, 'data': raw });
      
    } else {
      if(!merge_messages || t - this.last_tic > 5) {
        this.last_tic = t;
        const ts = this.getTimestamp();
        if(this.N_messages <= this.N_messages_max) {
          this.N_messages++;
        } else if(this.messages.firstChild) {
          this.messages.firstChild.remove();
        }
        
        el = document.createElement('div');
        el.className = msg_class;
        el.innerHTML = `<span class="timestamp">${ts}</span>${data}`;
        this.messages.appendChild(el);
        this.log.push({ 'class': msg_class, 'timestamp': ts, 'data': raw });
      } else {
        // Merge data with the last message element
        el = this.messages.querySelector('div:last-child');
        if(el) {
          el.innerHTML += data;
        }
        this.log[this.log.length - 1].data += raw;
      }
    }
    
    if(this.autoscroll) {
      this.scrollToBottom();
    }
    return el;
  }
  
  /**
   * Gets the current log of the command window to a file.
   */
  getLog() {
    var obj = this;
    var data = '';
    this.log.forEach(function(x) {
      if(x.class) {
        data += x.class + ' ';
      }
      if(obj.write_timestamps) {
        data += '[' + x.timestamp + '] ';
      }
      data += x.data + '\r\n';
    });
    return data;
  }
  
  /**
   * Opens a specified dialog (e.g., settings or log).
   * For simplicity, fade animations are replaced by immediate show/hide.
   * @param {HTMLElement} dialog - The dialog element to show.
   */
  openDialog(dialog) {
    if(window.getComputedStyle(dialog).display === 'none') {
      document.querySelectorAll('.terminal-dialog').forEach(el => {
        el.style.display = 'none';
      });
      dialog.style.display = 'block';
      dialog.focus();
    }
  }
  
  /**
   * Closes a specified dialog.
   * @param {HTMLElement} dialog - The dialog element to hide.
   */
  closeDialog(dialog) {
    dialog.style.display = 'none';
    this.message_input.focus();
    const len = this.message_input.value.length;
    this.message_input.setSelectionRange(len, len);
  }
}

var terminal = new PRDC_JSLAB_TERMINAL();
\end{lstlisting}

\begin{lstlisting}[style=JavaScriptStyle, caption={ui.js}]
/**
 * @file JSLAB library ui script
 * @author Milos Petrasinovic <mpetrasinovic@pr-dc.com>
 * PR-DC, Republic of Serbia
 * info@pr-dc.com
 */
 
/**
 * Class for JSLAB ui.
 */
class PRDC_JSLAB_UI {
  
  /**
   * Initializes an instance of the PRDC_JSLAB_UI class.
   */
  constructor() {
    // Tabs
    var container = document.querySelector('.ui.tabs-cont');
    if(container) {
      var headers = [...container.querySelectorAll('.ui.tab-name')];
      var panels  = [...container.querySelectorAll('.ui.tab')];

      function showTab(idx) {
        headers.forEach((h, i) => h.classList.toggle('active', i === idx));
        panels.forEach((p, i) => p.style.display = i === idx ? 'block' : 'none');
      };

      var start_idx = headers.findIndex(h => h.classList.contains('active'));
      if(start_idx === -1) {
        start_idx = 0;
      }
      showTab(start_idx);
      headers.forEach((h, i) => h.addEventListener('click', () => showTab(i)));
    }
  }
}

var ui = new PRDC_JSLAB_UI();
\end{lstlisting}


% ----------------------------------------
% End of document
% ----------------------------------------
\end{document}